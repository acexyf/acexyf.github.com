[{"title":"前端抢饭碗系列之深入Nginx","date":"2021-06-22T10:33:00.000Z","path":"2021/06/22/Front-Nginx.html","text":"在大部分童鞋的印象里，Nginx应该都是属于后台工作的范畴，前端只要写好页面就好了；然后随着大前端范围的不断扩展，前端也在不断的进军服务器领域，而Nginx就是进军服务器领域必备的技能之一；以前我们都需要“低声下气”的让后端的同事给我们配置页面域名，但是学会了Nginx配置，域名配置、代理转发什么的完全就可以我们自己来了，这样抢来的饭碗它。。。。它难道不香吗？ 简介 那么Nginx到底是什么，首先我们来看一下百度百科对Nginx的定义： Nginx是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。 这里有三个词很关键，我们来拆解一下，分别是是高性能、反向代理和web服务器；首先这个web服务器自不用多说，像我们熟知的Apache、IIS、Tomcat等都是web服务器；然后是高性能，一个服务器的性能自然是网站开发者最为关心的，那么服务器的性能如何来进行衡量呢？一般可以通过CPU和内存的使用量来进行衡量。经过笔者简单的并发测试，在20000个并发链接时，CPU和内存占用也非常低，CPU仅占5%，内存占用也才2MB不到。 我们可以通过一个web压力测试工具Apache Bench，对Nginx进行简单的压力测试；通过在命令行ab -n 20000 -c 10000 [url]，我们对Nginx的首页发起请求总数为20000，并发数为10000的请求测试，测试结果如下： 我们看到总的请求时间（Time taken for tests）是25秒，平均每个请求耗时（Time per request）1.25毫秒，在这么高的并发量下面，服务器响应性能还是挺不错的。 然后是反向代理，与之对应的就是正向代理，这两者的区别也是面试中经常被问到的。我们先来看一下什么是正向代理，一个正向代理最典型的例子就是我们常用的“梯子”。 我们直接访问Google，是访问不到的，但是如果我们使用了代理服务器，那么通过访问代理服务器就可以浏览Google，这里的代理服务器就属于正向代理；通过正向代理我们可以访问原来无法访问的资源。 那么什么是反向代理呢？反向代理最典型的例子就是我们的Nginx服务器了；比如我们在访问某个网站时，由代理服务器去目标服务器获取数据后返回给客户端，这样就能够隐藏真实服务器的IP地址，只对外开放代理服务器，以防止外网对内网服务器的恶性攻击。 理解了上面两个典型的案例，相信大家对正向反向代理也了解了，我们总结一下： 正向代理，代理客户端，服务端不知道实际发起请求的客户端。 反向代理，代理服务端，客户端不知道实际提供服务的服务端。 安装配置 Nginx安装程序分为Linux版和Windows版，Windows版本的Nginx下载解压后就可以直接运行了，而Linux版本的需要make、configure等命令编译安装，好处是可以方便灵活的编译不同的模块到Nginx；网上也有很多的安装教程，这里就不再赘述了，可以从官网下载适合自己的版本，下载好后我们来看一下他的目录结构： 12345678├── conf #所有配置文件的目录 ├── nginx.conf #主配置文件 ├── mime.types #媒体类型控制文件├── contrib #存放一些实用工具├── docs #文档资料├── html #默认解析的静态文件目录├── logs #日志目录├── sbin #启动运行程序 我们经常用到的就是conf目录和html目录；而在根目录可以运行常用的一些命令对Nginx进行操作控制： 1234567891011121314nginx -s reopen #重启Nginxnginx -s reload #重新加载Nginx配置文件，然后以优雅的方式重启Nginxnginx -s stop #强制停止Nginx服务nginx -s quit #优雅地停止Nginx服务（即处理完所有请求后再停止服务）nginx -h #打开帮助信息nginx -v #显示版本信息并退出nginx -V #显示版本和配置选项信息，然后退出nginx -t #检测配置文件是否有语法错误，然后退出nginx -T #检测配置文件是否有语法错误，转储并退出nginx -q #在检测配置文件期间屏蔽非错误信息nginx -p prefix #设置前缀路径(默认是:/usr/share/nginx/)nginx -c filename #设置配置文件(默认是:/etc/nginx/nginx.conf)nginx -g directives #设置配置文件外的全局指令killall nginx #杀死所有nginx进程 我们看前四个命令会发现，这四个命令可以分为两种，重启和停止Nginx，不过一种是强制的方式，另一种是优雅的方式；强制的方式就是让Nginx立即停止当前处理的所有请求，丢弃链接，停止工作；而优雅的方式是允许Nginx将当前正在处理的请求处理完成，但是不再接收新的请求，所有处理完成后再停止工作。 我们再来看一下主要配置文件nginx.conf的基本结构： 123456789101112131415161718192021222324252627# nginx进程数，建议设置为等于CPU总核心数worker_processes 1;# 进程文件pid logs/nginx.pid;# 单个进程最大连接数events &#123; worker_connections 1024;&#125;http &#123; # 文件扩展名与类型映射表 include mime.types; # 默认文件类型 default_type application/octet-stream; # 开启gzip压缩 gzip on; sendfile on; keepalive_timeout 65; server &#123; # 监听端口 listen 80; server_name localhost; location / &#123; root html; index index.html index.htm; &#125; &#125;&#125; 配置文件中主要可以分为以下几个块： 全局模块：从配置文件开始到events块之间的内容，此处的配置影响nginx服务器整体的运⾏，⽐如worker进程的数量、错误⽇志的位置等 events：配置影响nginx服务器或与用户的网络连接。 http：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。 server：配置虚拟主机的相关参数，一个http中可以有多个server。 location：配置请求的路由，以及各种页面的处理情况。 很多时候，我们不会将所有的配置全都写在一个主配置文件，因为这样会显得冗长，也不知道每个模块是做什么用的；而是会根据项目来拆分多个配置文件，每个配置文件彼此独立，互不干扰，然后在主配置文件中引入；我们在conf目录下新建一个projects目录，然后可以新建多个.conf配置文件： 1234567891011121314151617# /conf/projects/home.confserver &#123; listen 8080; server_name localhost; location / &#123; root html; index index.html index.htm; &#125;&#125;server &#123; listen 8081; server_name localhost; location / &#123; root html; index index.html index.htm; &#125;&#125; 然后在主配置nginx.conf中将projects目录下的所有配置文件引入： 123456789http &#123; include mime.types; default_type application/octet-stream; gzip on; sendfile on; keepalive_timeout 65; ## 引入projects目录下所有的配置文件 include projects/*.conf;&#125; 这样我们可以直接在projects目录下新增.conf后缀的配置文件，而不用修改主配置文件；但是我们修改完还不能确定是否会有错误，可以通过命令对配置文件进行检测： 123nginx -t#nginx: the configuration file nginx/conf/nginx.conf syntax is ok#nginx: configuration file nginx/conf/nginx.conf test is successful 通过检测发现没有任何报错，就可以优雅的重启服务器了： 1nginx -s reload 静态服务器 作为一个web服务器，最重要的就是能够对静态资源提供访问服务，我们的Nginx服务器可以用来托管一些静态的资源，比如js、css、图片等，访问某一特定的静态资源路径时会转发到本地目录文件上；那么我们就来看Nginx是如何一步一步的通过域名配置、URI配置以及目录配置来命中请求的。 server_name配置 在上面的配置中，我们主要是将server_name设置为localhost，但是这样仅能让局域网内的主机访问到；我们想要让广域网上的其他主机访问，可以将server_name匹配域名，它的参数值可以是以下几种： 精确的域名，如www.my.com 通配符名称，但通配符只能用在由三段字符串组成的名称的首段或尾段，如*.my.com或者www.my.* 正则表达式，使用波浪号~作为正则表达式字符串的开始标记，如~^www\\d+\\.my\\.com$ ip地址 在上面正则表达式中，^表示以www开头，紧跟一个或多个数字（\\d+），然后跟上域名my.com，最后以$结尾；因此上面的表达式可以匹配的域名比如www1.my.com，但是www.my.com就不行。 正则表达式还支持字符串捕获功能，即将正则表达式匹配成功的名称中的一部分字符串截取出来，放在变量中供后面使用；比如将server_name进行如下设置： 12345678server &#123; listen 80; server_name ~^(.+)?\\.my\\.com$; location / &#123; root /usr/share/nginx/html/$1; index index.html index.htm; &#125;&#125; 这样，通过二级域名home.my.com到达Nginx时，被server_name正则表达式捕获，将其中的home字符串存入$1变量中，我们在/usr/share/nginx/html/home目录下的静态资源就能通过home.my.com域名来访问了；我们服务器的目录就可以是这样的： 123456789/usr/share/nginx/html/ |- home |- index.html |- blog |- index.html |- mail |- index.html |- photo |- index.html 这样就只需要一个server块来完成多个站点的配置。 nginx允许一个虚拟主机有多个域名，因此我们可以给server_name同时配置多个域名，多个之间以空格分隔： 12345server &#123; listen 80; server_name a.com b.com c.com; # ...其他配置&#125; 由于server_name支持以上三种配置方式，如果出现多个server块同时匹配了相同的域名，那么这个请求交给哪个server呢？因此优先级顺序如下： 精确匹配server_name 通配符在开始时匹配server_name 通配符在结尾时匹配server_name 正则表达式匹配server_name 如果我们想让局域网内的设备访问nginx，可以将server_name设置ip地址的方式： 1234server &#123; listen 80; server_name localhost 192.168.1.101;&#125; 如果还不能访问，可以查看下是否是防火墙的原因，在防火墙允许通过的应用中将Nginx勾选（没有找到Nginx可以点击允许其他应用进行新增）： 有时候我们还会见到将server_name设置为_（下划线），意味着server_name为空，即匹配全部的主机；我们可以配置host，将a.com、b.com和c.com都指向本机，然后配置nginx： 12345678server &#123; listen 80; server_name _; location / &#123; root html; index index.html index.htm; &#125;&#125; 这样我们不仅可以通过域名a.com、b.com、c.com来访问，也能通过ip的方式。 location配置 location用于匹配不同的URI请求，它的语法如下： 12location [ = | ~ | ~* | ^~ ] uri &#123; ... &#125;location @/name/ &#123; … &#125; 这里的uri就是待匹配的请求字符串，可以是不含正则的字符串，比如/home，称为标准URI；也可以是包含正则的字符串，比如\\.html$（表示以.html结尾），称为正则URI。而方括号中的四种匹配符都是可选的，用来改变请求字符串与URI的匹配方式，我们来看下四种匹配符的解释： 匹配符 解释 不填 location后没有参数，直接跟着标准URI，表示前缀匹配，代表跟请求中的URI从头开始匹配 = 用于标准URI前，要求请求字符串与其精准匹配，成功则立即处理，nginx停止搜索其他匹配 ^~ 用于标准URI前，要求一旦匹配就会立即处理，不再去匹配其他正则URI，一般用来匹配目录 ~ 用于正则URI前，表示URI包含正则表达式，区分大小写 ~* 用于正则URI前，表示URI包含正则表达式，不区分大小写 @ 定义一个命名的location，@定义的location名字一般用在内部定向 我们来看下每种匹配规则能匹配的url，首先不填代表的话表示前缀匹配，如果我们有多个相似的前缀匹配： 123456location /pre/fix &#123; # ...&#125;location /pre &#123; # ...&#125; 对于请求/pre/fix/home，根据最大匹配原则，匹配第一个location。 然后是=，要求路径完全匹配： 12345678location = /abc &#123; # ...&#125;# /abc 匹配# /abcde 不匹配# /abc/ 不匹配，带有结尾的/# /cde/abc不匹配 其次是^~最佳匹配，它的优先级高于正则表达式： 12345678location ^~ /login &#123; # ...&#125;# /login 匹配# /loginss 匹配# /login/ 匹配# /home/login 不匹配 接着是~正则表达式匹配，它区分大小写匹配（注意：windows版本nginx不区分）： 1234567location ~ \\.(gif|jpg|png|js|css)$ &#123; # ...&#125;# /bg.png 匹配# /bg.PNG 不匹配 # /bg.png?a=1 匹配# /bg.jpeg 不匹配 ~*同样也是正则匹配，只不过它不区分大小写，这里就不再演示。 如果我们的URI匹配到了多个location，其并不完全按照在配置文件中出现的顺序来进行匹配，URI会按照如下规则进行匹配： = 精确匹配会第一个被处理。如果发现精确匹配，nginx停止搜索其他匹配。 普通字符匹配，正则表达式规则和长的块规则将被优先和查询匹配，也就是说如果该项匹配还需去看有没有正则表达式匹配和更长的匹配。 ^~ 则只匹配该规则，nginx停止搜索其他匹配，否则nginx会继续处理其他location指令。 最后匹配理带有~和~*的指令，如果找到相应的匹配，则nginx停止搜索其他匹配；当没有正则表达式或者没有正则表达式被匹配的情况下，那么匹配程度最高的逐字匹配指令会被使用。 请求目录配置 在location匹配URI后，就需要在服务器指定的目录中寻找请求资源，而root和alias就是用来指定目录的两种指令，两者主要的区别在于如何解析location后面的路径；我们首先来看下root的用法，假如我们需要将/data/下面的所有路径转发到html/roottest下面： 123location /data/ &#123; root html/roottest;&#125; 当location接收到/data/index.html的请求时，会在html/roottest/data/目录下找到index.html文件并进行相应，root会将root路径和location路径进行拼接。 而alias指令则改变location接收到的请求路径，假如我们需要将/data1/下面的所有路径转发到html/aliastest下面： 123location /data1/ &#123; alias html/aliastes/;&#125; 当location接收到/data1/index.html的请求时，会在html/aliastes/目录下查找index.html文件并响应。 需要注意的是：alias指令后面的路径必须以/结束，否则会找不到文件，而root则可有可无。 访问权限控制 针对一些静态资源，我们可能会设置一些用户访问权限，比如和js一起打包产出的.map文件，会对源码进行映射；但是我们想让它只能针对公司的ip进行开放，对外网的ip禁止访问，这时就需要用到allow和deny命令了。 假如局域网还有两个设备，我们只能让这两个设备的ip通过访问： 123456location / &#123; alias html/aliastes/; allow 192.168.1.102; allow 192.168.1.103; deny all;&#125; deny和allow指令是由ngx_http_access_module模块提供，Windows版本的Nginx并不包含该模块。 还可以对前端的.map文件进行访问权限控制，打包后的map文件一般会放在服务器上，但是如果能对所有人开放，别人就能查看到对应源码；因此我们可以控制只有公司的ip才有访问权限： try_files 前端在配置路由时经常会用到history路由模式，因此后台就需要映射对应的路由到index.html；但是如果我们给每个路由都配置一个location就会比较繁琐，因此可以通过try_files指令来进行尝试解析；try_files的语法规则如下： 1234# 格式1：try_files file ... uri; # 格式2：try_files file ... =code; 假设我们打包出来的单页面位于/html/my/index.html，我们想要将/login、/regisrer等路由指向index.html，我们可以配置try_files： 1234567server &#123; listen 8080; server_name localhost; location / &#123; try_files $uri /my/index.html; &#125;&#125; 对于多页面的应用，假设我们的页面都放在/html/pages/目录下，我们想要访问/login时响应/html/pages/login.html页面，可以通过$uri： 123456789server &#123; listen 8080; server_name localhost; location / &#123; index index.html index.htm; root html/pages; try_files $uri /$uri.html $uri/index.html /index.html; &#125;&#125; 这里我们设置root目录为html/pages，当我们访问/login路由时，这里的$uri就是/login，try_files会去尝试在根目录下找/login.html；如果找不到就尝试/login/index.html，最后找不到则会默认返回index.html。 gzip 我们都知道在服务端开启gzip压缩能够使得js、css、html等文件在传输时大幅提高访问速度，优化网站性能；gzip压缩后的文件大小可以变为原来的30%甚至更小；而对于图片、视频、音频等其他多媒体文件，因为压缩效果不好，所以不会开启压缩。 gzip压缩本质上是服务器端压缩，传输到浏览器后解压解析，我们来看下gzip的原理示意： 可以看到在请求和相应头上分别加了accept-encoding和content-encoding来进行传输；我们可以通过一个js的请求数据来查看： 既然gzip有这么多的好处，我们来看下nginx如何进行配置，gzip的配置可以在http块或者server块中： 1234567891011121314151617# 开启gzipgzip on;# 设置gzip申请内存的大小gzip_buffers 32 4K;# 设置gzip压缩等级# 压缩级别 1-9，级别越高压缩率越大但耗CPUgzip_comp_level 6;# 正则匹配User-Agent中的值，匹配上则不进行gzipgzip_disable &quot;MSIE [1-6]\\.(?!.*SV1)&quot;;# 设置允许压缩的页面最小字节数gzip_min_length 1024;# 设定进行gzip压缩的最小http版本gzip_http_version 1.0;# 需要压缩哪些响应类型的资源gzip_types application/javascript text/css text/xml;# 添加“Vary: Accept-Encoding”响应头gzip_vary on; 密码控制 对于一些简单的页面，我们想要通过密码来限制其他用户的访问，但是又不想接入复杂的账号体系，Nginx提供了简单的账号密码控制；首先我们通过Linux的工具创建一个密码本存放账号密码： 12sudo yum install httpd-tools -ysudo htpasswd -c passwd/passwd admin passwd/passwd文件就是生成的密码文件，运行后会要求连续两次输入密码，成功后为admin用户添加了密码；然后我们就修改nginx的配置文件，对站点开启密码验证： 123456789server &#123; listen 8000; server_name localhost; auth_basic &quot;请输入账号密码&quot;; auth_basic_user_file /etc/nginx/conf/passwd/passwd; location / &#123; # ..... &#125;&#125; 重启nginx，再次访问站点就会出现需要身份验证的弹框了。 反向代理 上面我们介绍了正向代理和反向代理的区别，反向代理功能是nginx的三大主要功能之一（静态web服务器、反向代理、负载均衡）。反向代理不需要额外的模块，默认自带proxy_pass和fastcgi_pass指令，通过在location块中配置即可实现： 1234567server &#123; listen 80; server_name a.com; location / &#123; proxy_pass http://192.168.1.102:8080; &#125;&#125; 在配置proxy_pass时，我们需要注意url后面的/`；当我们通过下面几种情况访问/proxy/home.html``时： 123location /proxy/ &#123; proxy_pass http://192.168.1.102:8080/;&#125; 第一种情况url后面带上/，则会被代理到http://192.168.1.102:8080/home.html。 123location /proxy/ &#123; proxy_pass http://192.168.1.102:8080;&#125; 第二种情况url后不带/，则会被代理到http://192.168.1.102:8080/proxy/home.html 123location /proxy/ &#123; proxy_pass http://192.168.1.102:8080/doc/;&#125; 第三种情况代理/doc/，则会被代理到http://192.168.1.102:8080/doc/home.html 123location /proxy/ &#123; proxy_pass http://192.168.1.102:8080/doc;&#125; 第四种情况代理/doc，则会被代理到http://192.168.1.102:8080/dochome.html 在配置反向代理时，我们还可以修改代理请求的请求参数： 1234567891011121314location /proxy/ &#123; proxy_pass http://192.168.1.102:8080/; # 修改请求的method proxy_method GET; # 修改请求的http协议版本 proxy_http_version 1.1; # 将原来host字段放到转发请求中 proxy_set_header Host $host; #获取真实ip proxy_set_header X-Real-IP $remote_addr; # 代理服务器每成功收到一个请求，就把请求来源IP地址添加到右边 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_redirect off;&#125; 经过反向代理后，由于客户端和web服务器之间增加了一个代理层，因此web服务器无法拿到客户端请求的host和真实ip，我们通过proxy_set_header指令修改代理请求的头部；$host和$remote_addr是用户真实的host和ip，这里作为变量传入Host和X-Real-IP字段，因此我们在客户端服务器想要获取真实ip就可以通过request.getAttribute(“X-real-ip”)的方式。 负载均衡 随着互联网的发展，用户规模的增加，服务器的压力也越来越大，如果只使用一台服务器有时候不能承受流量的压力，这时我们就需要将部分流量分散到多台服务器上，使得每台服务器都均衡的承担压力。 nginx负载均衡目前支持六种策略：轮询策略、加权轮询策略、ip_hash策略、url_hash策略、fair策略和sticky策略；六种策略可以分为两大类，内置策略（轮询、加权轮询、ip_hash）和扩展策略（url_hash、fair、sticky）；默认情况下内置策略自动编译在Nginx中，而扩展策略需要额外安装。 既然是负载，那么我们需要启用多台服务器；这里为了方便演示，我们在一台电脑上运行node脚本来模拟3台服务器；同时为了方便看到每台服务器有多少流量，每访问一次就计数一次： 12345678910const express = require(&quot;express&quot;);const app = express();const PORT = 8080;const path = require(&quot;path&quot;);let count = 0;app.get(&quot;*&quot;, (req, res) =&gt; &#123; count++; res.sendFile(path.resolve(__dirname, &quot;./index.html&quot;));&#125;);app.listen(PORT); 然后我们修改端口号，这样我们就有8080、8081、8082三个服务器了。 轮询策略 轮询策略，顾名思义，就是按照请求顺序，逐一分配到不同的服务器节点；如果某台服务器出现问题，会自动剔除。 123456789101112upstream myserver &#123; server 192.168.1.101:8080; server 192.168.1.101:8081; server 192.168.1.101:8082;&#125;server &#123; listen 8070; server_name _; location / &#123; proxy_pass http://myserver; &#125;&#125; 我们还是通过测试工具Apache Bench来并发100个请求到Nginx： 1ab -n 100 -c 10 http://localhost:8070/ 最后统计每台服务器的结果，每台服务器的请求还是很平均的： 1238080：34个请求8081：33个请求8082：33个请求 加权轮询策略 加权轮询在基本轮询策略上考虑各服务器节点接受请求的权重，指定服务器节点被轮询的权重，主要用于服务器节点性能不均的情况。 通过在server节点后配置weight来设置权重，weight的大小和访问比率成正比（weight的默认值为1）；我们给三台服务器设置访问比是1:3:2。 12345upstream myserver &#123; server 192.168.1.101:8080; server 192.168.1.101:8081 weight=3; server 192.168.1.101:8082 weight=2;&#125; 压力测试后统计服务器的请求结果，和我们配置的比率还是几乎相同的： 1238080：16个请求8081：51个请求8082：33个请求 注：由于weight是内置，所以可以直接和其他策略配合使用。 ip_hash策略 ip_hash策略是将前端访问的ip进行hash操作后，然后根据hash的结果将请求分配到不同的节点上，这样使得每个ip都会固定访问服务节点；这样做的好处是用户的session只在一个后端服务器节点上，不必考虑一个session存在多台服务器节点出现session共享问题。 123456upstream myserver &#123; ip_hash; server 192.168.1.101:8080; server 192.168.1.101:8081 weight=3; server 192.168.1.101:8082 weight=2;&#125; 压力测试后统计服务器的请求结果，我们发现所有的请求都到固定一台服务器上了： 1238080：0个请求8081：0个请求8082：100个请求 url_hash策略 url_hash策略是将url地址进行hash操作，根据hash结果请求定向到同一服务器节点上；url_hash的优点是能够提高后端缓存服务器的效率。 123456upstream myserver &#123; hash $request_uri; server 192.168.1.101:8080; server 192.168.1.101:8081; server 192.168.1.101:8082;&#125; 压力测试后统计服务器的请求结果： 1238080：0个请求8081：0个请求8082：100个请求 如果我们切换不同的url，/home、/list等，都会分配到不同的服务器节点。 fair策略 fair策略请求转发到负载最小的后端服务器节点上。Nginx通过服务器节点对响应时间来判断负载情况，响应时间最短的节点负载就相对较轻，Nginx就会将前端请求转发到此服务器节点上。 注：fair策略默认不被编译进nginx内核，需要额外安装 123456upstream myserver &#123; fair; server 192.168.1.101:8080; server 192.168.1.101:8081; server 192.168.1.101:8082;&#125; 压力测试后统计服务器的请求结果： 1238080：33个请求8081：33个请求8082：34个请求 sticky策略 sticky策略是基于cookie的一种负载均衡解决方案，通过分发和识别cookie，使来自同一个客户端的请求落在同一台服务器上，默认cookie标识名为route。 sticky策略看起来和ip_hash策略类似，但是又有一定区别。假设在一个局域网内有3台电脑，他们有3个内网IP，但是他们发起请求时，却只有一个外网IP，如果使用ip_hash方式，则Nginx会将请求分配到同一服务器；如果使用sticky策略，则会把请求分配到不同服务器上，这是ip_hash无法做到的。 注：sticky策略默认不被编译进nginx内核，需要额外安装 123456upstream myserver &#123; sticky name=sticky_cookie expires=6h; server 192.168.1.101:8080; server 192.168.1.101:8081; server 192.168.1.101:8082;&#125; sticky默认的cookie的名称是route，我们可以通过name修改，还有一些其他的cookie参数可以进行修改： [name=route] 设置用来记录会话的cookie名称 [domain=.foo.bar] 设置cookie作用的域名 [path=/] 设置cookie作用的URL路径，默认根目录 [expires=1h] 设置cookie的生存期，默认不设置，浏览器关闭即失效 [hash=index|md5|sha1] 设置cookie中服务器的标识是用明文还是使用md5值，默认使用md5 [no_fallback] 设置该项，当sticky的后端机器挂了以后，nginx返回502 (Bad Gateway or Proxy Error) ，而不转发到其他服务器，不建议设置 [secure] 设置启用安全的cookie，需要HTTPS支持 [httponly] 允许cookie不通过JS泄漏，没用过 我们通过浏览器来访问，在cookie中可以看到sticky下发的cookie 注：由于cookie最初由服务器端下发，如果客户端禁用cookie，则cookie不会生效。 其他参数 upstream还有一些参数我们可以配合负载均衡： 参数 描述 fail_timeout 与max_fails结合使用 max_fails 设置在fail_timeout参数设置的时间内最大失败次数，如果在这个时间内，所有针对该服务器的请求都失败了，那么认为该服务器会被认为是停机了 fail_time 服务器会被认为停机的时间长度,默认为10s。 backup 标记该服务器为备用服务器。当主服务器停止时，请求会被发送到它这里。 down 标记服务器永久停机了。 keepalive 连接数（keepalive的值）指定了每个工作进程中保留的持续连接到nginx负载均衡器缓存的最大值。如果超过这个设置值的闲置进程想链接到nginx负载均衡器组，最先连接的将被关闭。 123456789101112upstream backserver&#123; ip_hash; # down 表示单前的server暂时不参与负载 server 192.168.1.101:8080 down; server 192.168.1.101:8081; # max_fails允许请求失败的次数默认为1，此处允许失败的次数为3。每次失败后暂停的时间为30s server 192.168.1.101:8082 max_fails=3 fail_timeout=30s; # 其它所有的非backup机器down或者忙的时候，请求backup机器 server 192.168.1.101:8083 backup; # 连接到nginx负载均衡器的最大 keepalive 16;&#125;","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"}]},{"title":"深度测评次世代打包工具Vite","date":"2021-06-10T04:00:00.000Z","path":"2021/06/10/Front-Package-Vite.html","text":"随着我们项目代码模块越来越多，打包和启动调试服务器所需要的时间也呈指数级增长，Vite是尤大大在推出Vue3时顺带推出升级的一个web构建工具，旨在解决构建慢的问题，那我们就来看一下，它构建有多快以及是如何构建的。 介绍 Vite对其自身的定义为： 下一代前端开发与构建工具 在深入对比Webpack、Parcel、Rollup打包工具的不同一章中，我们分别详细的对比了Rollup、Parcel和Webpack之间的异同，也分析了每个打包工具使用的场景；那么Vite作为次时代的打包工具，我们先来看下它的优点： 极速的服务启动：使用原生 ESM 文件，无需打包! 轻量快速的热重载：无论应用程序大小如何，都始终极快的模块热重载（HMR） 丰富的功能：对 TypeScript、JSX、CSS 等支持开箱即用。 优化的构建：可选 “多页应用” 或 “库” 模式的预配置 Rollup 构建 通用的插件：在开发和构建之间共享 Rollup-superset 插件接口。 完全类型化的API：灵活的 API 和完整 TypeScript 类型。 我们看到Vite主打的特点就是极速服务启动，也就是一个字：快！俗话说得好，天下武功，无坚不摧，唯快不破；我们先来搭建第一个项目看下，通过--template来指定预设的模板： 12345# npm 6.xnpm init @vitejs/app vite-vue-app --template vue# npm 7+, 需要额外的双横线：npm init @vitejs/app vite-vue-app -- --template vue Vite还支持以下模板预设： vanilla vue vue-ts react react-ts preact preact-ts lit-element lit-element-ts 接着我们运行npm run dev或者yarn dev来启动服务器，可以看到服务器很快就启动了，不到400毫秒： Vue预设模板的项目结构大概如下： 可以发现Vue预设模板的目录结构和vue-cli很相似，不同的是index.html文件的位置和配置文件，vite是vite.config.js，而不是vue.config.js。 最后就是我们的package.json，来看下vite需要哪些依赖： 1234567891011121314151617&#123; &quot;name&quot;: &quot;vite-vue-app&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;vite&quot;, &quot;build&quot;: &quot;vite build&quot;, &quot;serve&quot;: &quot;vite preview&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;vue&quot;: &quot;^3.0.5&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;@vitejs/plugin-vue&quot;: &quot;^1.2.1&quot;, &quot;@vue/compiler-sfc&quot;: &quot;^3.0.5&quot;, &quot;vite&quot;: &quot;^2.1.5&quot; &#125;&#125; 可以看到Vite的依赖非常简单，默认支持Vue3.0，@vitejs/plugin-vue和@vue/compiler-sfc都是Vue3.0的编译插件；如果想要支持Vue2.x，需要安装vite-plugin-vue2插件。 原生ES模块 我们知道vue-cli的页面模板是在/public/目录下，那么来看下vite根目录下index.html有什么不同的地方： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;link rel=&quot;icon&quot; href=&quot;/favicon.ico&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Vite App&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script type=&quot;module&quot; src=&quot;/src/main.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 我们发现这里多引用了一个main.js，并且还有一个type=&quot;module&quot;属性，那么这个属性有什么用呢？我们都知道我们代码中引用的ES模块必须要通过打包工具比如webpack等进行处理后才能在浏览器中进行使用；但是一些主流浏览器（Chrome、Edge、Safari、Firefox等）都在尝试原生支持ES模块，这是一个主要的新特性，也就是说我们在浏览器里就能直接使用ES的模块，不过让我们来看下浏览器对这个新特性的支持情况： 我们可以写个demo在浏览器上进行测试： 1234567891011//count.jsexport function add(num1, num2)&#123; return num1 + num2&#125;export function sub(num1, num2)&#123; return num1 + num2&#125;//index.jsimport &#123; add, sub &#125; from &#x27;./count.js&#x27;console.log(add(1, 3))console.log(sub(4, 2)) 我们先定义好es模块，然后需要通过script的方式进行引用： 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;module&quot; src=&quot;/static/js/count.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;module&quot; src=&quot;/static/js/index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 原生es和普通js脚本有写不同： es module默认使用严格模式 es module有自己的作用域，使用var并不会创建全局变量 export和import关键字仅可在es module中使用 es module只会被浏览器解析并执行一次，普通js脚本每次引入都会解析执行 es module有跨域限制 我们都知道，js的加载解析默认是会阻塞浏览器的，因此script标签一般都放在页面底部；但是我们可以给script加上defer来让js并发加载执行： 我们发现原生ES模块和加上defer属性的效果是一样的；vite利用了浏览器对原生ES模块的支持，跳过打包（no bundle）过程，将ES模块解析编译后直接提供给浏览器；只在必要请求时进行代码转换，这样自然就节省了费时费力的打包时间。 例如我们在请求首页home.vue模块时，只有在浏览器请求home.vue才将vue文件的template等解析编译，解析成浏览器可以执行的js返回。 我们看下官方给出的传统打包工具的打包过程，从入口一直解析庞大的模块，然后打包成bundle，最后才能启动服务器： 但是Vite可以直接启动服务器，加载入口的文件： 灰色部分的是暂时没有用到的模块，初始化不会参与构建，随着项目的路由越来越复杂，构建速度也不会变慢。 依赖预构建 当我们首次运行项目时可能会发现下面的提示小字： 我们上面说过Vite是不依赖构建的，那这里为什么还需要预构建呢？这里官方给出了两个原因： 兼容CommonJS和UMD：由于Vite服务器会将所有的模块当作原生ES模块在浏览器中使用，因此有一些依赖使用的CommonJS和UMD规范需要进行转换 提升性能：有些依赖包将内部的ESM模块拆分多个，预构建将多个模块转换为单个模块，提升页面加载性能 兼容CommonJS和UMD不用多说，就是为了模块引用规范的统一，对模块化规范不了解的童鞋可以看这篇深入学习CommonJS和ES6模块化规范；提升性能官方给了一个现成的案例就是lodash-es依赖，当我们import &#123; chunk &#125; from &quot;lodash-es&quot;，由于内部有600+个模块，相互导入，因此浏览器会去同时加载600+个http请求，虽然每个请求只有1~2kb，但是大量的请求也会造成网络堵塞；我们可以将lodash-es剔除预构建来看下效果： 123456import &#123; defineConfig &#125; from &quot;vite&quot;;export default defineConfig(&#123; optimizeDeps: &#123; exclude: [&quot;lodash-es&quot;], &#125;,&#125;); 我们在vite.config.js中修改optimizeDeps.exclude，然后就能在浏览器中看到效果： 我们看到虽然请求数据不多，但是架不住600+大量的请求，正所谓乱拳打死老师傅；如果通过预构建将这些模块都统一到一起，那么速度快了不是一点点；那么什么样的模块会进行预构建呢？ 默认情况下，Vite会将package.json中生产依赖dependencies的部分启用依赖预编译，即会先对该依赖进行编译，然后将编译后的文件缓存在内存中（node_modules/.vite文件下），在启动DevServer时直接请求该缓存内容 环境变量 很多情况下我们需要对打包的变量根据环境进行区分，比如请求的域名等，和vue-cli一样，vite也可以区分打包环境，不过它的变量比较特殊；我们知道它并不是通过webpack的DefinePlugin方式来定义全局变量，因此不能通过process.env来获取；而是通过一个特殊的import.meta.env对象来暴露，这个对象有一些公共的内在变量： import.meta.env.MODE：运行模式，通过--mode来设置 import.meta.env.BASE_URL：部署的公共基础路径，由config文件中的base确定 import.meta.env.PROD：boolean值，是否运行在生产环境 import.meta.env.DEV：boolean值，是否运行在开发环境 (永远与import.meta.env.PROD相反) Vite支持dotenv，可以从项目根目录的文件加载额外的环境变量： 123.env # 所有环境都加载.env.test # 测试环境.env.prod # 正式环境 加载的变量也会通过import.meta.env暴露给客户端代码，不过为了防止变量泄露，只有VITE_为前缀的变量才会暴露。 这里引入一个模式的概念，默认情况下serve命令运行开发模式（development），而build命令会运行生产模式（production），但是我们可以通过env文件定义自己需要的模式；可以通过--mode选项覆盖命令使用的默认模式。 比如我们项目在测试和正式环境之外可能还会设置一个预发环境，将一些线上的数据拷贝过来以便模拟真实场景，我们就可以定义一个staging模式： 1vite build --mode staging 我们可以将用到的环境配置放入.env.staging文件： 1234# .env.stagingNODE_ENV=productionVITE_APP_TITLE=My App (staging)VITE_HOST=https://xieyufei.com 这样staging模式就会打包和生产环境类似的代码，但是环境变量却是staging模式的，我们就成功新增了一种模式。 vite配置 当我们运行vite时，默认会解析项目目录下的vite.config.js地配置文件，基础的配置文件导出一个对象 1234//vite.config.jsexport default &#123; // 配置&#125; 但是我们一般会引入defineConfig帮手函数，这样在没有jsdoc的配合下，也能获取类型提示： 1234import &#123; defineConfig &#125; from &#x27;vite&#x27;export default defineConfig(&#123; // 配置&#125;) 如果我们的配置文件还需要根据环境或者模式的的不同来传递不同的插件或配置等，可以通过导出一个函数的方式： 1234567891011export default (&#123; command, mode &#125;) =&gt; &#123; if (command === &#x27;serve&#x27;) &#123; return &#123; // serve 独有配置 &#125; &#125; else &#123; return &#123; // build 独有配置 &#125; &#125;&#125; css预处理 对css预处理，Vite提供了开箱支持，我们只要安装对应的预处理依赖，无需配置，即可进行使用： 12345678# .scss and .sassnpm install -D sass# .lessnpm install -D less# .styl and .stylusnpm install -D stylus 这样我们就可以通过&lt;style lang=&quot;sass&quot;&gt;自动开启预处理了；针对postcss的功能，我们可以直接配置postcss.config.js，它会自动应用所有的css，不过也需要安装对应的插件。 resolve解析 和webpack类似，resolve字段用来表示如何来解析模块，首先我们看下常用的别名设置alias： 1234567export default defineConfig(&#123; resolve: &#123; alias: &#123; &quot;@&quot;: path.resolve(__dirname, &quot;./src&quot;), &#125;, &#125;,&#125;); 这样我们就能用@替换相对路径了，可以通过@来引入组件： 1import HelloWorld from &#x27;@/components/HelloWorld.vue&#x27; 还有mainFields，主字段解析，标志vite默认从模块的package.json中哪个字段引入模块，默认配置是： 12345export default defineConfig(&#123; resolve: &#123; mainFields: [&#x27;module&#x27;, &#x27;jsnext:main&#x27;, &#x27;jsnext&#x27;] &#125;,&#125;); server服务器 Vite提供了server选项来配置开发服务器，默认情况只允许localhost访问，我们可以指定server.host来让局域网主机也能访问： 123456export default defineConfig(&#123; server: &#123; host: &quot;0.0.0.0&quot;, port: 3001, &#125;,&#125;); 如果我们想让服务器启动时自动在浏览器中打开应用程序，可以配置server.open，配置类型boolean|string，配置为字符串时，会被用作 URL 的路径名： 12345export default defineConfig(&#123; server: &#123; open: &#x27;/other-page&#x27; &#125;,&#125;); 和webpack一样，我们可以通过server.proxy来为开发服务器配置代理，如果key值以^开头，则会被解析为正则表达式： 123456789101112131415161718export default defineConfig(&#123; server: &#123; // 字符串简写写法 &#x27;/foo&#x27;: &#x27;http://localhost:4567/foo&#x27;, // 选项写法 &#x27;/api&#x27;: &#123; target: &#x27;https://xieyufei.com&#x27;, changeOrigin: true, rewrite: (path) =&gt; path.replace(/^\\/api/, &#x27;&#x27;) &#125;, // 正则表达式写法 &#x27;^/fallback/.*&#x27;: &#123; target: &#x27;http://jsonplaceholder.typicode.com&#x27;, changeOrigin: true, rewrite: (path) =&gt; path.replace(/^\\/fallback/, &#x27;&#x27;) &#125; &#125;,&#125;); 按需引入 我们在使用element时，经常会需要按需引入组件，在vue-cli中使用的是babel的一个插件babel-plugin-component；vite有自己的按需引入插件vite-plugin-style-import，首先我们安装一下： 1npm install vite-plugin-style-import -D 然后在vite.config.js中进行配置： 123456789101112131415161718192021import styleImport from &quot;vite-plugin-style-import&quot;;export default defineConfig(&#123; plugins: [ vue(), styleImport(&#123; libs: [ &#123; libraryName: &quot;element-plus&quot;, esModule: true, ensureStyleFile: true, resolveStyle: (name) =&gt; &#123; return `element-plus/lib/theme-chalk/$&#123;name&#125;.css`; &#125;, resolveComponent: (name) =&gt; &#123; return `element-plus/lib/$&#123;name&#125;`; &#125;, &#125;, ], &#125;), ],&#125;); 接下来如果我们只希望引入部分组件，就可以在main.js中加入： 12345import &#123; ElButton, ElSelect &#125; from &#x27;element-plus&#x27;;const app = createApp(App)app.component(ElButton.name, ElButton);app.component(ElSelect.name, ElSelect);","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"打包工具","slug":"PackTool","permalink":"http://xieyufei.com/tags/PackTool/"}]},{"title":"全面总结Vue3.0的新特性","date":"2021-05-10T04:00:00.000Z","path":"2021/05/10/Vue3-Feature.html","text":"Vue3.0从20年九月发布第一个One Piece版本，到现在一直在更新优化；除了服务端渲染的工作，其他工作已经大部分完成了，中文版的官方文档也已经放出；那么作为终端用户的我们来看下Vue3新增了哪些功能和特性。 尤大大在B站直播时分享了Vue3.0的几个亮点： Performance：性能优化 Tree-shaking support：支持摇树优化 Composition API：组合API Fragment，Teleport，Suspense：新增的组件 Better TypeScript support：更好的TypeScript支持 Custom Renderer API：自定义渲染器 在性能方面，对比Vue2.x，性能提升了1.3~2倍左右；打包后的体积也更小了，如果单单写一个HelloWorld进行打包，只有13.5kb；加上所有运行时特性，也不过22.5kb。 那么作为终端用户的我们，在开发时，和Vue2.x有什么不同呢？Talk is cheap，我们还是来看代码。 Tree-shaking Vue3最重要的变化之一就是引入了Tree-Shaking，Tree-Shaking带来的bundle体积更小是显而易见的。在2.x版本中，很多函数都挂载在全局Vue对象上，比如$nextTick、$set等函数，因此虽然我们可能用不到，但打包时只要引入了vue这些全局函数仍然会打包进bundle中。 而在Vue3中，所有的API都通过ES6模块化的方式引入，这样就能让webpack或rollup等打包工具在打包时对没有用到API进行剔除，最小化bundle体积；我们在main.js中就能发现这样的变化： 1234567//src/main.jsimport &#123; createApp &#125; from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import router from &quot;./router&quot;;const app = createApp(App);app.use(router).mount(&quot;#app&quot;); 创建app实例方式从原来的new Vue()变为通过createApp函数进行创建；不过一些核心的功能比如virtualDOM更新算法和响应式系统无论如何都是会被打包的；这样带来的变化就是以前在全局配置的组件（Vue.component）、指令（Vue.directive）、混入（Vue.mixin）和插件（Vue.use）等变为直接挂载在实例上的方法；我们通过创建的实例来调用，带来的好处就是一个应用可以有多个Vue实例，不同实例之间的配置也不会相互影响： 12345const app = createApp(App)app.use(/* ... */)app.mixin(/* ... */)app.component(/* ... */)app.directive(/* ... */) 因此Vue2.x的以下全局API也需要改为ES6模块化引入： Vue.nextTick Vue.observable不再支持，改为reactive Vue.version Vue.compile (仅全构建) Vue.set (仅兼容构建) Vue.delete (仅兼容构建) 除此之外，vuex和vue-router也都使用了Tree-Shaking进行了改进，不过api的语法改动不大： 12345678910111213141516//src/store/index.jsimport &#123; createStore &#125; from &quot;vuex&quot;;export default createStore(&#123; state: &#123;&#125;, mutations: &#123;&#125;, actions: &#123;&#125;, modules: &#123;&#125;,&#125;);//src/router/index.jsimport &#123; createRouter, createWebHistory &#125; from &quot;vue-router&quot;;const router = createRouter(&#123; history: createWebHistory(process.env.BASE_URL), routes,&#125;); 更多关于Tree-Shaking的使用可以在Webpack配置全解析中查看。 生命周期函数 我们都知道，在Vue2.x中有8个生命周期函数： beforeCreate created beforeMount mounted beforeUpdate updated beforeDestroy destroyed 在vue3中，新增了一个setup生命周期函数，setup执行的时机是在beforeCreate生命函数之前执行，因此在这个函数中是不能通过this来获取实例的；同时为了命名的统一，将beforeDestroy改名为beforeUnmount，destroyed改名为unmounted，因此vue3有以下生命周期函数： beforeCreate（建议使用setup代替） created（建议使用setup代替） setup beforeMount mounted beforeUpdate updated beforeUnmount unmounted 同时，vue3新增了生命周期钩子，我们可以通过在生命周期函数前加on来访问组件的生命周期，我们可以使用以下生命周期钩子： onBeforeMount onMounted onBeforeUpdate onUpdated onBeforeUnmount onUnmounted onErrorCaptured onRenderTracked onRenderTriggered 那么这些钩子函数如何来进行调用呢？我们在setup中挂载生命周期钩子，当执行到对应的生命周期时，就调用对应的钩子函数： 123456789101112import &#123; onBeforeMount, onMounted &#125; from &quot;vue&quot;;export default &#123; setup() &#123; console.log(&quot;----setup----&quot;); onBeforeMount(() =&gt; &#123; // beforeMount代码执行 &#125;); onMounted(() =&gt; &#123; // mounted代码执行 &#125;); &#125;,&#125; 新增的功能 说完生命周期，下面就是我们期待的Vue3新增加的那些功能。 响应式API 我们在深入学习Object.defineProperty和Proxy讲解过Proxy优点以及Vue3为什么改用Proxy实现响应式，同时Vue3也将一些响应式的API进行抽离，以便代码更好的复用。 我们可以使用reactive来为JS对象创建响应式状态： 123456import &#123; reactive, toRefs &#125; from &quot;vue&quot;;const user = reactive(&#123; name: &#x27;Vue2&#x27;, age: 18,&#125;);user.name = &#x27;Vue3&#x27; reactive相当于Vue2.x中的Vue.observable。 reactive函数只接收object和array等复杂数据类型。 对于一些基本数据类型，比如字符串和数值等，我们想要让它变成响应式，我们当然也可以通过reactive函数创建对象的方式，但是Vue3提供了另一个函数ref： 1234567891011121314import &#123; ref &#125; from &quot;vue&quot;;const num = ref(0);const str = ref(&quot;&quot;);const male = ref(true);num.value++;console.log(num.value);str.value = &quot;new val&quot;;console.log(str.value);male.value = false;console.log(male.value); ref返回的响应式对象是只包含一个名为value参数的RefImpl对象，在js中获取和修改都是通过它的value属性；但是在模板中被渲染时，自动展开内部的值，因此不需要在模板中追加.value。 123456789101112131415161718&lt;template&gt; &lt;div&gt; &lt;span&gt;&#123;&#123; count &#125;&#125;&lt;/span&gt; &lt;button @click=&quot;count ++&quot;&gt;Increment count&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123; ref &#125; from &#x27;vue&#x27; export default &#123; setup() &#123; const count = ref(0) return &#123; count &#125; &#125; &#125;&lt;/script&gt; reactive主要负责复杂数据结构，而ref主要处理基本数据结构；但是很多童鞋就会误解ref只能处理基本数据，ref本身也是能处理对象和数组的： 1234567891011121314import &#123; ref &#125; from &quot;vue&quot;;const obj = ref(&#123; name: &quot;qwe&quot;, age: 1,&#125;);setTimeout(() =&gt; &#123; obj.value.name = &quot;asd&quot;;&#125;, 1000);const list = ref([1, 2, 3, 4, 6]);setTimeout(() =&gt; &#123; list.value.push(7);&#125;, 2000); 当我们处理一些大型响应式对象的property时，我们很希望使用ES6的解构来获取我们想要的值： 123456789101112let book = reactive(&#123; name: &#x27;Learn Vue&#x27;, year: 2020, title: &#x27;Chapter one&#x27;&#125;)let &#123; name,&#125; = bookname = &#x27;new Learn&#x27;// Learn Vueconsole.log(book.name); 但是很遗憾，这样会消除它的响应式；对于这种情况，我们可以将响应式对象转换为一组ref，这些ref将保留与源对象的响应式关联： 1234567891011121314let book = reactive(&#123; name: &#x27;Learn Vue&#x27;, year: 2020, title: &#x27;Chapter one&#x27;&#125;)let &#123; name,&#125; = toRefs(book)// 注意这里解构出来的name是ref对象// 需要通过value来取值赋值name.value = &#x27;new Learn&#x27;// new Learnconsole.log(book.name); 对于一些只读数据，我们希望防止它发生任何改变，可以通过readonly来创建一个只读的对象： 12345678910import &#123; reactive, readonly &#125; from &quot;vue&quot;;let book = reactive(&#123; name: &#x27;Learn Vue&#x27;, year: 2020, title: &#x27;Chapter one&#x27;&#125;)const copy = readonly(book);//Set operation on key &quot;name&quot; failed: target is readonly.copy.name = &quot;new copy&quot;; 有时我们需要的值依赖于其他值的状态，在vue2.x中我们使用computed函数来进行计算属性，在vue3中将computed功能进行了抽离，它接受一个getter函数，并为getter返回的值创建了一个不可变的响应式ref对象： 1234567const num = ref(0);const double = computed(() =&gt; num.value * 2);num.value++;// 2console.log(double.value);// Warning: computed value is readonlydouble.value = 4 或者我们也可以使用get和set函数创建一个可读写的ref对象： 12345678910111213const num = ref(0);const double = computed(&#123; get: () =&gt; num.value * 2, set: (val) =&gt; (num.value = val / 2),&#125;);num.value++;// 2console.log(double.value);double.value = 8// 4console.log(num.value); 响应式侦听 和computed相对应的就是watch，computed是多对一的关系，而watch则是一对多的关系；vue3也提供了两个函数来侦听数据源的变化：watch和watchEffect。 我们先来看下watch，它的用法和组件的watch选项用法完全相同，它需要监听某个数据源，然后执行具体的回调函数，我们首先看下它监听单个数据源的用法： 1234567891011121314151617181920212223import &#123; reactive, ref, watch &#125; from &quot;vue&quot;;const state = reactive(&#123; count: 0,&#125;);//侦听时返回值得getter函数watch( () =&gt; state.count, (count, prevCount) =&gt; &#123; // 1 0 console.log(count, prevCount); &#125;);state.count++;const count = ref(0);//直接侦听refwatch(count, (count, prevCount) =&gt; &#123; // 2 0 console.log(count, prevCount, &quot;watch&quot;);&#125;);count.value = 2; 我们也可以把多个值放在一个数组中进行侦听，最后的值也以数组形式返回： 123456789101112const state = reactive(&#123; count: 1,&#125;);const count = ref(2);watch([() =&gt; state.count, count], (newVal, oldVal) =&gt; &#123; //[3, 2] [1, 2] //[3, 4] [3, 2] console.log(newVal, oldVal);&#125;);state.count = 3;count.value = 4; 如果我们来侦听一个深度嵌套的对象属性变化时，需要设置deep:true： 123456789101112131415161718const deepObj = reactive(&#123; a: &#123; b: &#123; c: &quot;hello&quot;, &#125;, &#125;,&#125;);watch( () =&gt; deepObj, (val, old) =&gt; &#123; // new hello new hello console.log(val.a.b.c, old.a.b.c); &#125;, &#123; deep: true &#125;);deepObj.a.b.c = &quot;new hello&quot;; 最后的打印结果可以发现都是改变后的值，这是因为侦听一个响应式对象始终返回该对象的引用，因此我们需要对值进行深拷贝： 12345678910111213141516171819import _ from &quot;lodash&quot;;const deepObj = reactive(&#123; a: &#123; b: &#123; c: &quot;hello&quot;, &#125;, &#125;,&#125;);watch( () =&gt; _.cloneDeep(deepObj), (val, old) =&gt; &#123; // new hello hello console.log(val.a.b.c, old.a.b.c); &#125;, &#123; deep: true &#125;);deepObj.a.b.c = &quot;new hello&quot;; 一般侦听都会在组件销毁时自动停止，但是有时候我们想在组件销毁前手动的方式进行停止，可以调用watch返回的stop函数进行停止： 123456789101112const count = ref(0);const stop = watch(count, (count, prevCount) =&gt; &#123; // 不执行 console.log(count, prevCount);&#125;);setTimeout(()=&gt;&#123; count.value = 2;&#125;, 1000);// 停止watchstop(); 还有一个函数watchEffect也可以用来进行侦听，但是都已经有watch了，这个watchEffect和watch有什么区别呢？他们的用法主要有以下几点不同： watchEffect不需要手动传入依赖 每次初始化时watchEffect都会执行一次回调函数来自动获取依赖 watchEffect无法获取到原值，只能得到变化后的值 123456789101112131415import &#123; reactive, ref, watch, watchEffect &#125; from &quot;vue&quot;;const count = ref(0);const state = reactive(&#123; year: 2021,&#125;);watchEffect(() =&gt; &#123; console.log(count.value); console.log(state.year);&#125;);setInterval(() =&gt; &#123; count.value++; state.year++;&#125;, 1000); watchEffect会在页面加载时自动执行一次，追踪响应式依赖；在加载后定时器每隔1s执行时，watchEffect都会监听到数据的变化自动执行，每次执行都是获取到变化后的值。 组合API Composition API（组合API）也是Vue3中最重要的一个功能了，之前的2.x版本采用的是Options API（选项API），即官方定义好了写法：data、computed、methods，需要在哪里写就在哪里写，这样带来的问题就是随着功能增加，代码也越来复杂，我们看代码需要上下反复横跳： 上图中，一种颜色代表一个功能，我们可以看到Options API的功能代码比较分散；Composition API则可以将同一个功能的逻辑，组织在一个函数内部，利于维护。 我们首先来看下之前Options API的写法： 1234567export default &#123; components: &#123;&#125;, data() &#123;&#125;, computed: &#123;&#125;, watch: &#123;&#125;, mounted() &#123;&#125;,&#125; Options API就是将同一类型的东西放在同一个选项中，当我们的数据比较少的时候，这样的组织方式是比较清晰的；但是随着数据增多，我们维护的功能点会涉及到多个data和methods，但是我们无法感知哪些data和methods是需要涉及到的，经常需要来回切换查找，甚至是需要理解其他功能的逻辑，这也导致了组件难以理解和阅读。 而Composition API做的就是把同一功能的代码放到一起维护，这样我们需要维护一个功能点的时候，不用去关心其他的逻辑，只关注当前的功能；Composition API通过setup选项来组织代码： 123export default &#123; setup(props, context) &#123;&#125;&#125;; 我们看到这里它接收了两个参数props和context，props就是父组件传入的一些数据，context是一个上下文对象，是从2.x暴露出来的一些属性： attrs slots emit 注：props的数据也需要通过toRefs解构，否则响应式数据会失效。 我们通过一个Button按钮来看下setup具体的用法： 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div&gt;&#123;&#123; state.count &#125;&#125; * 2 = &#123;&#123; double &#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123; num &#125;&#125;&lt;/div&gt; &lt;div @click=&quot;add&quot;&gt;Add&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; reactive, computed, ref &#125; from &quot;vue&quot;;export default &#123; name: &quot;Button&quot;, setup() &#123; const state = reactive(&#123; count: 1, &#125;); const num = ref(2); function add() &#123; state.count++; num.value += 10; &#125; const double = computed(() =&gt; state.count * 2); return &#123; state, double, num, add, &#125;; &#125;,&#125;;&lt;/script&gt; 很多童鞋可能就有疑惑了，这跟我在data和methods中写没什么区别么，不就是把他们放到一起么？我们可以将setup中的功能进行提取分割成一个一个独立函数，每个函数还可以在不同的组件中进行逻辑复用： 123456789101112131415export default &#123; setup() &#123; const &#123; networkState &#125; = useNetworkState(); const &#123; user &#125; = userDeatil(); const &#123; list &#125; = tableData(); return &#123; networkState, user, list, &#125;; &#125;,&#125;;function useNetworkState() &#123;&#125;function userDeatil() &#123;&#125;function tableData() &#123;&#125; Fragment 所谓的Fragment，就是片段；在vue2.x中，要求每个模板必须有一个根节点，所以我们代码要这样写： 123456&lt;template&gt; &lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt; 或者在Vue2.x中还可以引入vue-fragments库，用一个虚拟的fragment代替div；在React中，解决方法是通过的一个React.Fragment标签创建一个虚拟元素；在Vue3中我们可以直接不需要根节点： 1234&lt;template&gt; &lt;span&gt;hello&lt;/span&gt; &lt;span&gt;world&lt;/span&gt;&lt;/template&gt; 这样就少了很多没有意义的div元素。 Teleport Teleport翻译过来就是传送、远距离传送的意思；顾名思义，它可以将插槽中的元素或者组件传送到页面的其他位置： 在React中可以通过createPortal函数来创建需要传送的节点；本来尤大大想起名叫Portal，但是H5原生的Portal标签也在计划中，虽然有一些安全问题，但是为了避免重名，因此改成Teleport。 Teleport一个常见的使用场景，就是在一些嵌套比较深的组件来转移模态框的位置。虽然在逻辑上模态框是属于该组件的，但是在样式和DOM结构上，嵌套层级后较深后不利于进行维护（z-index等问题）；因此我们需要将其进行剥离出来： 123456789101112131415161718192021&lt;template&gt; &lt;button @click=&quot;showDialog = true&quot;&gt;打开模态框&lt;/button&gt; &lt;teleport to=&quot;body&quot;&gt; &lt;div class=&quot;modal&quot; v-if=&quot;showDialog&quot; style=&quot;position: fixed&quot;&gt; 我是一个模态框 &lt;button @click=&quot;showDialog = false&quot;&gt;关闭&lt;/button&gt; &lt;child-component :msg=&quot;msg&quot;&gt;&lt;/child-component&gt; &lt;/div&gt; &lt;/teleport&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; showDialog: false, msg: &quot;hello&quot; &#125;; &#125;,&#125;;&lt;/script&gt; 这里的Teleport中的modal div就被传送到了body的底部；虽然在不同的地方进行渲染，但是Teleport中的元素和组件还是属于父组件的逻辑子组件，还是可以和父组件进行数据通信。Teleport接收两个参数to和disabled： to - string：必须是有效的查询选择器或 HTMLElement，可以id或者class选择器等。 disabled - boolean：如果是true表示禁用teleport的功能，其插槽内容将不会移动到任何位置，默认false不禁用。 Suspense Suspense是Vue3推出的一个内置组件，它允许我们的程序在等待异步组件时渲染一些后备的内容，可以让我们创建一个平滑的用户体验；Vue中加载异步组件其实在Vue2.x中已经有了，我们用的vue-router中加载的路由组件其实也是一个异步组件： 123456export default &#123; name: &quot;Home&quot;, components: &#123; AsyncButton: () =&gt; import(&quot;../components/AsyncButton&quot;), &#125;,&#125; 在Vue3中重新定义，异步组件需要通过defineAsyncComponent来进行显示的定义： 12345678910111213141516171819// 全局定义异步组件//src/main.jsimport &#123; defineAsyncComponent &#125; from &quot;vue&quot;;const AsyncButton = defineAsyncComponent(() =&gt; import(&quot;./components/AsyncButton.vue&quot;));app.component(&quot;AsyncButton&quot;, AsyncButton);// 组件内定义异步组件// src/views/Home.vueimport &#123; defineAsyncComponent &#125; from &quot;vue&quot;;export default &#123; components: &#123; AsyncButton: defineAsyncComponent(() =&gt; import(&quot;../components/AsyncButton&quot;) ), &#125;,&#125;; 同时对异步组件的可以进行更精细的管理： 1234567891011121314151617export default &#123; components: &#123; AsyncButton: defineAsyncComponent(&#123; delay: 100, timeout: 3000, loader: () =&gt; import(&quot;../components/AsyncButton&quot;), errorComponent: ErrorComponent, onError(error, retry, fail, attempts) &#123; if (attempts &lt;= 3) &#123; retry(); &#125; else &#123; fail(); &#125; &#125;, &#125;), &#125;,&#125;; 这样我们对异步组件加载情况就能掌控，在加载失败也能重新加载或者展示异常的状态： 我们回到Suspense，上面说到它主要是在组件加载时渲染一些后备的内容，它提供了两个slot插槽，一个default默认，一个fallback加载中的状态： 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;showButton&quot;&gt;展示异步组件&lt;/button&gt; &lt;template v-if=&quot;isShowButton&quot;&gt; &lt;Suspense&gt; &lt;template #default&gt; &lt;AsyncButton&gt;&lt;/AsyncButton&gt; &lt;/template&gt; &lt;template #fallback&gt; &lt;div&gt;组件加载中...&lt;/div&gt; &lt;/template&gt; &lt;/Suspense&gt; &lt;/template&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; setup() &#123; const isShowButton = ref(false); function showButton() &#123; isShowButton.value = true; &#125; return &#123; isShowButton, showButton, &#125;; &#125;,&#125;&lt;/script&gt; 非兼容的功能 非兼容的功能主要是一些和Vue2.x版本改动较大的语法，已经在Vue3上可能存在兼容问题了。 data、mixin和filter 在Vue2.x中，我们可以定义data为object或者function，但是我们知道在组件中如果data是object的话会出现数据互相影响，因为object是引用数据类型； 在Vue3中，data只接受function类型，通过function返回对象；同时Mixin的合并行为也发生了改变，当mixin和基类中data合并时，会执行浅拷贝合并： 123456789101112131415161718192021222324252627282930313233343536373839404142434445const Mixin = &#123; data() &#123; return &#123; user: &#123; name: &#x27;Jack&#x27;, id: 1, address: &#123; prov: 2, city: 3, &#125;, &#125; &#125; &#125;&#125;const Component = &#123; mixins: [Mixin], data() &#123; return &#123; user: &#123; id: 2, address: &#123; prov: 4, &#125;, &#125; &#125; &#125;&#125;// vue2结果：&#123; id: 2, name: &#x27;Jack&#x27;, address: &#123; prov: 4, city: 3 &#125;&#125;// vue3结果：user: &#123; id: 2, address: &#123; prov: 4, &#125;,&#125; 我们看到最后合并的结果，vue2.x会进行深拷贝，对data中的数据向下深入合并拷贝；而vue3只进行浅层拷贝，对data中数据发现已存在就不合并拷贝。 在vue2.x中，我们还可以通过过滤器filter来处理一些文本内容的展示： 123456789101112131415161718192021222324&lt;template&gt; &lt;div&gt;&#123;&#123; status | statusText &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; status: &#123; type: Number, default: 1 &#125; &#125;, filters: &#123; statusText(value)&#123; if(value === 1)&#123; return &#x27;订单未下单&#x27; &#125; else if(value === 2)&#123; return &#x27;订单待支付&#x27; &#125; else if(value === 3)&#123; return &#x27;订单已完成&#x27; &#125; &#125; &#125; &#125;&lt;/script&gt; 最常见的就是处理一些订单的文案展示等；然而在vue3中，过滤器filter已经删除，不再支持了，官方建议使用方法调用或者计算属性computed来进行代替。 v-model 在Vue2.x中，v-model相当于绑定value属性和input事件，它本质也是一个语法糖： 123&lt;child-component v-model=&quot;msg&quot;&gt;&lt;/child-component&gt;&lt;!-- 相当于 --&gt;&lt;child-component :value=&quot;msg&quot; @input=&quot;msg=$event&quot;&gt;&lt;/child-component&gt; 在某些情况下，我们需要对多个值进行双向绑定，其他的值就需要显示的使用回调函数来改变了： 1234567&lt;child-component v-model=&quot;msg&quot; :msg1=&quot;msg1&quot; @change1=&quot;msg1=$event&quot; :msg2=&quot;msg2&quot; @change2=&quot;msg2=$event&quot;&gt;&lt;/child-component&gt; 在vue2.3.0+版本引入了.sync修饰符，其本质也是语法糖，是在组件上绑定@update:propName回调，语法更简洁： 12345678910111213&lt;child-component :msg1.sync=&quot;msg1&quot; :msg2.sync=&quot;msg2&quot;&gt;&lt;/child-component&gt;&lt;!-- 相当于 --&gt;&lt;child-component :msg1=&quot;msg1&quot; @update:msg1=&quot;msg1=$event&quot; :msg2=&quot;msg2&quot; @update:msg2=&quot;msg2=$event&quot;&gt;&lt;/child-component&gt; Vue3中将v-model和.sync进行了功能的整合，抛弃了.sync，表示：多个双向绑定value值直接用多个v-model传就好了；同时也将v-model默认传的prop名称由value改成了modelValue： 123456789&lt;child-component v-model=&quot;msg&quot;&gt;&lt;/child-component&gt;&lt;!-- 相当于 --&gt;&lt;child-component :modelValue=&quot;msg&quot; @update:modelValue=&quot;msg = $event&quot;&gt;&lt;/child-component&gt; 如果我们想通过v-model传递多个值，可以将一个argument传递给v-model： 123456789101112&lt;child-component v-model.msg1=&quot;msg1&quot; v-model.msg2=&quot;msg2&quot;&gt;&lt;/child-component&gt;&lt;!-- 相当于 --&gt;&lt;child-component :msg1=&quot;msg1&quot; @update:msg1=&quot;msg1=$event&quot; :msg2=&quot;msg2&quot; @update:msg2=&quot;msg2=$event&quot;&gt;&lt;/child-component&gt; v-for和key 在Vue2.x中，我们都知道v-for每次循环都需要给每个子节点一个唯一的key，还不能绑定在template标签上， 1234&lt;template v-for=&quot;item in list&quot;&gt; &lt;div :key=&quot;item.id&quot;&gt;...&lt;/div&gt; &lt;span :key=&quot;item.id&quot;&gt;...&lt;/span&gt;&lt;/template&gt; 而在Vue3中，key值应该被放置在template标签上，这样我们就不用为每个子节点设一遍： 1234&lt;template v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt; &lt;div&gt;...&lt;/div&gt; &lt;span&gt;...&lt;/span&gt;&lt;/template&gt; v-bind合并 在vue2.x中，如果一个元素同时定义了v-bind=&quot;object&quot;和一个相同的单独的属性，那么这个单独的属性会覆盖object中的绑定： 12345&lt;div id=&quot;red&quot; v-bind=&quot;&#123; id: &#x27;blue&#x27; &#125;&quot;&gt;&lt;/div&gt;&lt;div v-bind=&quot;&#123; id: &#x27;blue&#x27; &#125;&quot; id=&quot;red&quot;&gt;&lt;/div&gt;&lt;!-- 最后结果都相同 --&gt;&lt;div id=&quot;red&quot;&gt;&lt;/div&gt; 然而在vue3中，如果一个元素同时定义了v-bind=&quot;object&quot;和一个相同的单独的属性，那么声明绑定的顺序决定了最后的结果（后者覆盖前者）： 123456789&lt;!-- template --&gt;&lt;div id=&quot;red&quot; v-bind=&quot;&#123; id: &#x27;blue&#x27; &#125;&quot;&gt;&lt;/div&gt;&lt;!-- result --&gt;&lt;div id=&quot;blue&quot;&gt;&lt;/div&gt;&lt;!-- template --&gt;&lt;div v-bind=&quot;&#123; id: &#x27;blue&#x27; &#125;&quot; id=&quot;red&quot;&gt;&lt;/div&gt;&lt;!-- result --&gt;&lt;div id=&quot;red&quot;&gt;&lt;/div&gt; v-for中ref vue2.x中，在v-for上使用ref属性，通过this.$refs会得到一个数组： 1234567891011121314&lt;template &lt;div v-for=&quot;item in list&quot; :ref=&quot;setItemRef&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; list: [1, 2] &#125;, mounted () &#123; // [div, div] console.log(this.$refs.setItemRef) &#125;&#125;&lt;/script&gt; 但是这样可能不是我们想要的结果；因此vue3不再自动创建数组，而是将ref的处理方式变为了函数，该函数默认传入该节点： 123456789101112131415161718192021222324&lt;template &lt;div v-for=&quot;item in 3&quot; :ref=&quot;setItemRef&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; reactive, onUpdated &#125; from &#x27;vue&#x27;export default &#123; setup() &#123; let itemRefs = reactive([]) const setItemRef = el =&gt; &#123; itemRefs.push(el) &#125; onUpdated(() =&gt; &#123; console.log(itemRefs) &#125;) return &#123; itemRefs, setItemRef &#125; &#125;&#125;&lt;/script&gt; v-for和v-if优先级 在vue2.x中，在一个元素上同时使用v-for和v-if，v-for有更高的优先级，因此在vue2.x中做性能优化，有一个重要的点就是v-for和v-if不能放在同一个元素上。 而在vue3中，v-if比v-for有更高的优先级。因此下面的代码，在vue2.x中能正常运行，但是在vue3中v-if生效时并没有item变量，因此会报错： 12345678910111213&lt;template&gt; &lt;div v-for=&quot;item in list&quot; v-if=&quot;item % 2 === 0&quot; :key=&quot;item&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; list: [1, 2, 3, 4, 5], &#125;; &#125;,&#125;;&lt;/script&gt; 总结 以上就是Vue3.0作为终端用的我们可能会涉及到的一些新特性和新功能，其实Vue3.0还有很多的改动，这里由于篇幅原因就不一一展开了，大家可以自行查阅官方文档，期待Vue3能带给我们更便利更友好的开发体验。","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"Vue","slug":"Vue","permalink":"http://xieyufei.com/tags/Vue/"}]},{"title":"一文彻底读懂ESLint","date":"2021-04-25T08:00:00.000Z","path":"2021/04/25/Front-Eslint.html","text":"在日常项目开发中，ESLint常常扮演者可有可无的角色，我们想让它来帮助我们检查代码，同时又害怕它带来的报错无法处理；本文带你深入的了解ESLint的配置以及原理。 ESLint是一个插件化的代码检测工具，正如它官网描述的slogan： 可组装的JavaScript和JSX检查工具 ESLint不仅可以检测JS，还支持JSX和Vue，它的高可扩展性让它能够支持更多的项目。 ESLint的前辈们 提到ESLint，我们就不得不提及他的前辈们JSLint和JSHint，以及它们的区别；首先就是JSLint，它是由Douglas Crockford开发的；JSLint的灵感来源于C语言的检查工具Lint，Lint最初被发明用来扫描C语言源文件以便找到其中的错误，后来随着语言的成熟以及编译器能够更好的找到问题，Lint工具也逐渐不再被需要了。 JavaScript最开始被发明只是用来在网页上做一些简单的工作（点击事件、表单提交等），随着JS语言的发展完善以及项目复杂程度的增加，急需一个用来检查JS语法或者其他问题的校验工具，因此JSLint就诞生了；它是由Douglas Crockford在2010年开源的第一款针对JS的语法检测工具，它和Lint做着相同的事，扫描JS的源文件来找到错误；它内部也是通过fs.readFile来读取文件然后逐行来进行检查。 我们可以在全局安装jslint，然后jslint source.js对我们的代码进行检查；JSLint刚开始确实帮助很多JS开发者节省了不少排查错误的时间，但是JSLint的问题也很明显：所有的配置项都内置不可配置，因此你要用JSLint只能遵循Douglas Crockford老爷子自己定义的代码风格和规范；再加上他本身推崇爱用不用的传统，不像开发者开放配置或者修改他觉得对的规则，因此很多人也无法忍受他的规则。 由于JSLint让很多人无法忍受，所以Anton Kovalyov基于JSLint开发了JSHint，它的初衷就是为了能让开发者自定义规则lint rules，因此提供了丰富的配置项，给开发者极大的自由；同时它也提供了一套相当完善的编辑器插件，我们常用的VIM、Sublime、Atom、Vs Code等都有插件支持，方便开发。 JSHint一开始就保持了开源软件的风格，并且由社区来驱动，因此一推出就很快发展起来，我们熟知的一些项目或者公司也使用了JSHint，比如：Facebook、Google、Jquery、Disqus等。 JSHint相比于JSLint，最大的特点就是可配置，我们可以在项目中放入一个.jshintrc的配置文件，JSLint就会加载配置文件用于代码分析，配置文件的部分内容如下： 123456789101112&#123; // 禁止有未使用的变量 &quot;unused&quot;: true, // 禁止有未定义的变量 &quot;undef&quot;: true, // 无视没有加分号行尾 &quot;asi&quot;: true, // 全局变量 &quot;globals&quot;: &#123; &quot;jQuery&quot;: true &#125;&#125; 由于JSHint是基于JSLint开发的，因此JSLint的一些问题也继承下来了，比如不易扩展以及不容易直接根据报错定位到具体的配置规则等；在2013年，Zakas大佬发现JSHint无法满足自己定制化规则的需要，因此设想开发一个基于AST的Linter，可以动态执行额外的规则，同时可以很方面的扩展规则，于是在13年6月份开源推出了全新的ESLint。 ESLint号称下一代的JS Linter工具，它的灵感来源于PHP Linter，将源码解析成AST，然后检测AST是否符合规则；ESLint最开始使用esprima解析器将源码解析成AST，然后就可以使用任意规则来检测AST是否符合预期，这也是ESLint高可扩展的原因。 刚开始ESlint的推出并没有撼动JSHint的霸主地位，由于ESlint需要将源码转为AST，而JSHint直接检测源文件字符串，因此执行速度比JSHint慢很多；真正让ESLint实现弯道超车的是ES6的出现。 2015年，ES6规范发布后，由于大部分浏览器支持程度不高，因此需要Babel将代码转换编译成ES5或者更低版本；同时由于ES6变化很大，短期内JSHint无法完全支持，这时ESLint的高扩展性的优点显现出来了，不仅可以扩展规则，连默认的解析器也能替换；Babel团队就为ESLint开发了babel-eslint替换默认的解析器esprima，让ESLint率先支持ES6。 配置 ESLint被设计成完全可配置的，我们可以用多种方式配置它的规则，或者配置要检测文件的范围。 初始化 如果想在现有的项目中引入eslint，我们可以在项目中进行初始化： 12npm i eslint --save-devnpx eslint --init 在经过一系列问答后，会在项目根目录创建一个我们熟悉的.eslintrc.js配置文件；安装后就可以通过命令行对项目中的文件需要检测了： 1234# 检测单个文件npx eslint file1.js file2.js# 检测src和scripts目录npx eslint src scripts 一般我们会把eslint命令行配置到packages.json中： 12345&quot;scripts&quot;: &#123; &quot;lint&quot;: &quot;npx eslint src scripts&quot;, &quot;lint:fix&quot;: &quot;npx eslint src scripts --fix&quot;, &quot;lint:create&quot;: &quot;npx eslint --init&quot;&#125; 这里有一个--fix后缀，是ESLint提供自动修复基础错误的功能，我们运行lint:fix后发现有一些报错信息消失了，代码也改变了；不过它只能修复一些基础的不影响代码逻辑的错误，比如代码末尾加上分号、表达式的空格等等。 ESLint默认只会检测.js后缀的文件，如果我们想对更多类型的文件进行检测，比如.vue、.jsx，可以使用--ext选项，参数用逗号分隔： 123&quot;scripts&quot;: &#123; &quot;lint&quot;: &quot;npx eslint --ext .js,.jsx,.vue src&quot;,&#125; 对于一些公共的js，或者测试脚本，不需要进行检测，我们可以通过在项目根目录创建一个.eslintignore告诉ESLint去忽略特定的目录或者文件: 12public/src/main.js 除了.eslintignore中指定的文件或目录，ESLint总是忽略/node_modules/* 和/bower_components/*中的文件；因此对于一些目前解决不了的规则报错，但是我们需要打包上线，在不影响运行的情况下，我们就可以利用.eslintignore文件将其暂时忽略。 ESLint一共有两种配置方式，第一种方式是直接把lint规则嵌入源代码中； 123/* eslint eqeqeq: &quot;error&quot; */var num = 1num == &#x27;1&#x27; eqeqeq代表eslint校验规则，error代表校验报错级别，后面会详细说明；这个eslint校验规则只会对该文件生效： 我们还可以使用其他注释，更精确地管理eslint对某个文件或某一行代码的校验： 12345678910111213/* eslint-disable */alert(&#x27;该注释放在文件顶部，eslint不会检查整个文件&#x27;)/* eslint-enable */alert(&#x27;重新启用eslint检查&#x27;)/* eslint-disable eqeqeq */alert(&#x27;只禁止某一个或多个规则&#x27;)/* eslint-disable-next-line */alert(&#x27;下一行禁止eslint检查&#x27;)alert(&#x27;当前行禁止eslint检查&#x27;) // eslint-disable-line 第二种方式是直接把lint规则放到我们的配置文件中，上面init初始化生成的.eslintrc.js就是一个配置文件，官方还提供了其他几种配置文件名称（优先级从上到下）： 123456.eslintrc.js.eslintrc.yaml.eslintrc.yml.eslintrc.json.eslintrcpackage.json 一般情况下我们使用.eslintrc.js就可以了。 配置详解 我们详细看下.eslintrc.js文件内部有哪些配置选项： 1234567891011121314module.exports = &#123; &quot;globals&quot;: &#123;&#125;, &quot;env&quot;: &#123; &quot;browser&quot;: true, &quot;es2021&quot;: true &#125;, &quot;extends&quot;: &quot;eslint:recommended&quot;, &quot;parse&quot;: &quot;babel-eslint&quot;, &quot;parserOptions&quot;: &#123; &quot;ecmaVersion&quot;: 12, &quot;sourceType&quot;: &quot;module&quot; &#125;, &quot;rules&quot;: &#123;&#125;&#125;; 首先是我们的globals，ESLint会检测未声明的变量，并发出报错，比如node环境中的process，浏览器环境下的全局变量console，以及我们通过cdn引入的jQuery定义的$等；我们可以在globals中进行变量声明： 1234567&#123; &quot;globals&quot;: &#123; // true表示该变量可读写，false表示变量是只读 &quot;$&quot;: true, &quot;console&quot;: false &#125;&#125; 但是node或者浏览器中的全局变量很多，如果我们一个个进行声明显得繁琐，因此就需要用到我们的env，这是对环境定义的一组全局变量的预设： 1234567&#123; &quot;env&quot;: &#123; &quot;browser&quot;: true, &quot;node&quot;: true, &quot;jquery&quot;: true &#125;&#125; 更多的环境参数可以看ESLint声明环境。 然后就是我们的解析器parse和parserOptions；我们上面说到ESLint可以更换解析器，&quot;parse&quot;: &quot;babel-eslint&quot;就是用来指定要使用的解析器，它有以下几个选择： esprima：ESLint最开始使用的解析器 espree：默认，ESLint自己基于esprima v1.2.2开发的一个解析器 babel-eslint：一个对Babel解析器的包装，使其能够与ESLint兼容。 @typescript-eslint/parser：将TypeScript转换成与estree兼容的形式，以便在ESLint中使用。 那么这几个解析器怎么选择呢？如果你想使用一些先进的语法（ES6789），就使用babel-eslint（需要npm安装）；如果你想使用typescript，就使用@typescript-eslint/parser。 选好了解析器，我们可以通过parserOptions给解析器传入一些其他的配置参数： 123456789101112131415&#123; &quot;parser&quot;: &quot;babel-eslint&quot;, &quot;parserOptions&quot;: &#123; // 代码模块类型，可选script(默认)，module &quot;sourceType&quot;: &quot;module&quot;, // es版本号，默认为5，可以使用年份2015（同6） &quot;ecamVersion&quot;: 6, // es 特性配置 &quot;ecmaFeatures&quot;: &#123; &quot;globalReturn&quot;: true, // 允许在全局作用域下使用 return 语句 &quot;impliedStrict&quot;: true, // 启用全局 strict mode &quot;jsx&quot;: true // 启用 JSX &#125; &#125;,&#125; 规则 ESLint可以配置大量的规则，我们可以在配置文件的rules属性自定义需要的规则： 12345678910&#123; &quot;rules&quot;:&#123; // &quot;semi&quot;: &quot;off&quot;, &quot;semi&quot;: 0, // &quot;quotes&quot;: &quot;warn&quot;, &quot;quotes&quot;: 1, // &quot;no-console&quot;: &quot;error&quot; &quot;no-console&quot;: 2 &#125;&#125; 对于检验规则，有3个报错等级： “off” 或 0：关闭规则 “warn” 或 1：开启规则，warn级别的错误 (不会导致程序退出) “error” 或 2：开启规则，error级别的错误(当被触发的时候，程序会退出) 有些规则没有属性，只需控制开启还是关闭；有些规则可以传入属性，我们通过数组的方式传入参数： 12345678910&#123; &quot;rules&quot;:&#123; // 代码缩进，使用tab缩进，switch语句的case缩进级别，1表示2个空格 &quot;indent&quot;: [&quot;error&quot;, &quot;tab&quot;, &#123; &quot;SwitchCase&quot;: 1 &#125;], // 引号，双引号 &quot;quotes&quot;: [&quot;error&quot;, &quot;double&quot;], // 在语句末尾使用分号 &quot;semi&quot;: [&quot;error&quot;, &quot;always&quot;] &#125;&#125; 对于刚接触ESLint的同学，看到这么多的规则肯定很懵逼，难道要一条一条来记么？肯定不是的；项目的ESLint配置文件并不是一次性完成的，而是在项目开发中慢慢完善起来的，因为并不是所有的规则都是我们项目所需要的。因此我们可以先进行编码，在编码的过程中使用npm run lint校验代码规范，如果报错，可以通过报错信息去详细查看是那一条规范报错： 比如这里的报错no-unused-vars我们可以看到它来自第六行，再去文档查找，发现是我们在js中有一个定义了却未使用的变量；在团队协商后可以进一步来确定项目是否需要这条规范。 扩展 如果每条规则都需要团队协商配置还是比较繁琐的，在项目开始配置时，我们可以先使用一些业内已经成熟的、大家普遍遵循的编码规范（最佳实践）；我们可以通过extends字段传入一些规范，它接收String/Array： 12345678&#123; &quot;extends&quot;: [ &quot;eslint:recommended&quot;, &quot;plugin:vue/essential&quot;, &quot;@vue/prettier&quot;, &quot;eslint-config-standard&quot; ]&#125; extends可以使用以下几种类型的扩展： eslint：开头的ESLint官方扩展，有两个：eslint:recommended（推荐规范）和eslint:all（所有规范）。 plugin：开头的扩展是插件类型扩展 eslint-config：开头的来自npm包，使用时可以省略eslint-config-，比如上面的可以直接写成standard @：开头的扩展和eslint-config一样，是在npm包上面加了一层作用域scope 需要注意的是：多个扩展中有相同的规则，以后面引入的扩展中规则为准。 eslint:recommended推荐使用的规则在规则列表的右侧用绿色√标记。 插件类型的扩展一般先通过npm安装插件，以上面的vue为例，我们先来安装： 1npm install --save-dev eslint eslint-plugin-vue 安装后一个插件中会有很多同类型扩展可供选择，比如vue就有以下几种扩展： plugin:vue/base：基础 plugin:vue/essential：必不可少的 plugin:vue/recommended：推荐的 plugin:vue/strongly-recommended：强烈推荐 针对扩展中的规则，我们也能够通过rules来对它进行覆写： 123456789&#123; &quot;extends&quot;: [ &quot;plugin:vue/recommended&quot; ], &quot;rules&quot;: &#123; // 覆写规则 &quot;vue/no-unused-vars&quot;: &quot;error&quot; &#125;&#125; 除了上面的eslint-config-standard，还有以下几个比较知名的编码规范： 不过需要注意的是，很多规范不仅需要安装扩展本身，还需要配合插件，比如eslint-config-standard，我们还需要安装下面几个插件才能有效： 12npm i eslint-config-standard -Dnpm i eslint-plugin-promise eslint-plugin-import eslint-plugin-node -D 插件 在Webpack中，插件是用来扩展功能，让其能够处理更多的文件类型以及功能，ESLint中的插件也是同样的作用；虽然ESLint提供了几百种规则可供选择，但是随着JS框架和语法的发展，这么多规则还是显得不够，因为官方的规则只能检查标准的JS语法；如果我们写的是vue或者react的jsx，那么ESLint就不能检测了。 这时就需要安装ESLint插件，用来定制一些特色的规则进行检测；eslint插件以eslint-plugin-开头，使用时可以省略；比如我们上面检测.vue文件就用到eslint-plugin-vue插件；需要注意的是，我们在配置eslint-plugin-vue这个插件时，如果仅配置&quot;plugins&quot;: [&quot;vue&quot;]，vue文件中template内容还是会解析失败。 这是因为不管是默认的espree还是babel-eslint解析器都无法解析.vue中template的内容；eslint-plugin-vue插件依赖vue-eslint-parser解析器，而vue-eslint-parser解析器只会解析template内容，不会检测script标签中的JS内容，因此我们还需要指定一下解析器： 12345678910&#123; &quot;extends&quot;: [&quot;eslint:recommended&quot;], &quot;plugins&quot;: [&quot;vue&quot;], &quot;parser&quot;: &quot;vue-eslint-parser&quot;, &quot;parserOptions&quot;: &#123; &quot;parser&quot;: &quot;babel-eslint&quot;, &quot;ecmaVersion&quot;: 12, &quot;sourceType&quot;: &quot;module&quot;, &#125;,&#125; 上面parserOptions.parser不少同学肯定看的有点迷糊，这是由于外层的解析器只能有一个，我们已经用了vue-eslint-parser就不能再写其他的；因此vue-eslint-parser的做法是在解析器选项中再传入一个解析器选项用来处理script中的JS内容。 如果想让ESLint检测vue文件，确保将.vue后缀加入--ext选项中。 而react配置则较为简单了，引入插件，选择对应的扩展规则即可： 1234567891011121314151617&#123; &quot;extends&quot;: [ &quot;eslint:recommended&quot;, &quot;plugin:react/recommended&quot; ], &quot;parserOptions&quot;: &#123; // 启用jsx语法支持 &quot;ecmaFeatures&quot;: &#123; &quot;jsx&quot;: true &#125;, &quot;ecmaVersion&quot;: 12, &quot;sourceType&quot;: &quot;module&quot; &#125;, &quot;plugins&quot;: [ &quot;react&quot; ],&#125; 配合prettier 虽然ESLint会对我们的代码格式进行一些检测（比如分号、单双引号等），但是并不能完全统一代码风格，我们还需要一个工具Prettier；Prettier是什么？Prettier是一个支持很多语言的代码格式化工具，官网用了一个“贬义”的单词来形容它opinionated，翻译过来就是固执己见的。 Prettier还有以下四个特点： An opinionated code formatter Supports many languages Integrates with most editors Has few options 那么为什么Prettier要用opinionated这个词呢？每个团队成员可能会用不同的编辑器或是不同的插件，每个插件也会有自己的格式化规范，这样就导致了我们在开发时代码风格极大的不统一，甚至造成不必要的冲突；Prettier就给我们定义好了风格，按照它的风格来（是不是很像JSLint）；但是又没有完全封闭，开放了一些必要的设置，这也是最后一点few options的含义；因此我们只需要将代码的美化交给Prettier来做就好了。 首先还是安装，我们将所需的插件进行安装，这里用到prettier的三个包： 123npm i prettier eslint-plugin-prettier eslint-config-prettier 首先就是这个eslint-plugin-prettier插件，它会调用prettier对你的代码风格进行检查，其原理是先使用prettier对你的代码进行格式化，然后与格式化之前的代码进行对比，如果过出现了不一致，这个地方就会被prettier进行标记。 被标记后Prettier并不会有任何提示，我们还需要对标记后的代码进行报错处理，在rules中进行添加配置： 123456&#123; &quot;plugins&quot;: [&quot;prettier&quot;], &quot;rules&quot;: &#123; &quot;prettier/prettier&quot;: &quot;error&quot;, &#125;&#125; 如果不希望Prettier影响项目打包，我们也可以将prettier的报错由error改为warn 借助ESLint的自动修复--fix，我们可以修复这种简单的样式问题；那如果我们想自定义一些样式怎么办呢？没关系，虽然Prettier是一个固执己见的工具，但是人家也是开放了一些配置可供我们进行自定义的，我们可以在项目中新建一个.prettierrc.json文件： 12345678910111213141516&#123; // 尾逗号 &quot;trailingComma&quot;: &quot;es5&quot;, // 缩进长度 &quot;tabWidth&quot;: 4, // 代码末尾分号 &quot;semi&quot;: false, // 单引号 &quot;singleQuote&quot;: true, // 单行代码最大长度 &quot;printWidth&quot;: 100, // 对象字面量的括号 &quot;bracketSpacing&quot;: true, // 箭头函数参数加括号 &quot;arrowParens&quot;: &quot;always&quot;,&#125; 这里简单贴一些常用的，我们可以在官网选项配置找到更多的配置规则。 这样配置后虽然能修复代码了，但是如果遇到另一个也固执己见的扩展，比如我们引入eslint-config-standard这个扩展，它也有自己的代码风格；如果通过Prettier格式化，standard不干了；如果通过standard自动修复，那么Prettier又要报错了，两边都是大爷这可咋整呢？ 机智的Prettier已经帮我们考虑到这个问题了，利用extends中最后一个覆盖前面扩展的特性，我们将eslint-config-prettier配置在extends最后，就能够关闭一些与Prettier的规则： 1234567&#123; &quot;extends&quot;: [&quot;standard&quot;, &quot;prettier&quot;], &quot;plugins&quot;: [&quot;prettier&quot;], &quot;rules&quot;: &#123; &quot;prettier/prettier&quot;: &quot;error&quot;, &#125;&#125; 另外eslint-plugin-prettier插件也附带有plugin:prettier/recommended扩展配置，可以同时启用插件和eslint-config-prettier扩展，因此我们可以只需要配置recommended就可以了： 123456&#123; &quot;extends&quot;: [&quot;standard&quot;, &quot;plugin:prettier/recommended&quot;], &quot;rules&quot;: &#123; &quot;prettier/prettier&quot;: &quot;error&quot;, &#125;&#125; Vue中为了支持Prettier，也将eslint-plugin-prettier和eslint-config-prettier整合到一起，放到了node_modules/@vue/eslint-config-prettier目录中（加了一层作用域），因此我们在Vue脚手架生成的项目经常能看到@vue/prettier这个扩展，打开它的目录发现其本质是一样的： 12345678910module.exports = &#123; plugins: [&#x27;prettier&#x27;], extends: [ require.resolve(&#x27;eslint-config-prettier&#x27;), require.resolve(&#x27;eslint-config-prettier/vue&#x27;) ], rules: &#123; &#x27;prettier/prettier&#x27;: &#x27;warn&#x27; &#125;&#125;","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"}]},{"title":"前端抢饭碗系列之Vue项目中如何做单元测试","date":"2021-04-14T04:47:49.000Z","path":"2021/04/14/Vue-Unit-Test.html","text":"关于单元测试，最常见的问题应该就是“前端单元测试有必要吗？”，通过这篇文章，你将会了解单元测试的必要性，以及在Vue项目中如何能够全面可靠的测试我们写的组件。 单元测试的必要性 一般在我们的印象里，单元测试都是测试工程师的工作，前端负责代码就行了；百度搜索Vue单元测试，联想词出来的都是“单元测试有必要吗？” “单元测试是做什么的？”虽然我们平时项目中一般都会有测试工程师来对我们的页面进行测试“兜底”，但是根据我的观察，一般测试工程师并不会覆盖所有的业务逻辑，而且有一些深层次的代码逻辑测试工程师在不了解代码的情况下也根本无法进行触发。因此在这种情况下，我们并不能够完全的依赖测试工程师对我们项目测试，前端项目的单元测试就显得非常的有必要。 而且单元测试也能够帮助我们节省很大一部分自我测试的成本，假如我们有一个订单展示的组件，根据订单状态的不同以及其他的一些业务逻辑来进行对应文案的展示；我们想在页面上查看文案展示是否正确，这时就需要繁琐的填写下单信息后才能查看；如果第二天又又加入了一些新的逻辑判断（你前一天下的单早就过期啦），这时你有三个选择，第一种选择就是再次繁琐地填写订单并支付完（又给老板提供资金支持了），第二种选择就是死皮赖脸的求着后端同事给你更改订单状态（后端同事给你一个白眼自己体会），第三种选择就是代理接口或者使用mock数据（你需要编译整个项目运行进行测试）。 这时，单元测试就提供了第四种成本更低的测试方式，写一个测试用例，来对我们的组件进行测试，判断文案是否按照我们预想的方式进行展示；这种方式既不需要依赖后端的协助，也不需要对项目进行任何改动，可谓是省时又省力。 测试框架和断言库 说到单元测试，我们首先来介绍一下流行的测试框架，主要是mocha和jest。先简单介绍下mocha，翻译成中文就是摩卡（人家是一种咖啡！不是抹茶啊），名字的由来估猜是因为开发人员喜欢喝摩卡咖啡，就像Java名字也是从咖啡由来一样，mocha的logo也是一杯摩卡咖啡： 和jest相比，两者主要的不同就是jest内置了集成度比较高的断言库expect.js，而mocha需要搭配额外的断言库，一般会选择比较流行的chai作为断言库，这里一直提到断言库，那么什么是断言库呢？我们首先来看下mocha是怎么来测试代码的，首先我们写了一个addNum函数，但是不确定是否返回我们想要的结果，因此需要对这个函数进行测试： 12345//src/index.jsfunction addNum(a, b) &#123; return a + b;&#125;module.exports = addNum; 然后就可以写我们的测试文件了，所有的测试文件都放在test目录下，一般会将测试文件和所要测试的源码文件同名，方便进行对应，运行mocha时会自动对test目录下所有js文件进行测试： 123456789//test/index.test.jsvar addNum = require(&quot;../src/index&quot;);describe(&quot;测试addNum函数&quot;, () =&gt; &#123; it(&quot;两数相加结果为两个数字的和&quot;, () =&gt; &#123; if (addNum(1, 2) !== 3) &#123; throw new Error(&quot;两数相加结果不为两个数字的和&quot;); &#125; &#125;);&#125;); 上面这段代码就是测试脚本的语法，一个测试脚本会包括一个或多个describe块，每个describe又包括一个或多个it块；这里describe称为测试套件（test suite），表示一组相关的测试，它包含了两个参数，第一个参数是这个测试套件的名称，第二个参数是实际执行的函数。 而it称为测试用例，表示一个单独的测试，是测试的最小单位，它也包含两个参数，第一个参数是测试用例的名称，第二个参数是实际执行的函数。 it块中就是我们需要测试的代码，如果运行结果不是我们所预期的就抛出异常；上面的测试用例写好后，我们就可以运行测试了， 运行结果通过了，是我们想要的结果，说明我们的函数是正确的；但是每次都通过抛出异常来判断，多少有点繁琐了，断言库就出现了；断言的目的就是将测试代码运行后和我们的预期做比较，如果和预期一致，就表明代码没有问题；如果和预期不一致，就是代码有问题了；每一个测试用例最后都会有一个断言进行判断，如果没有断言，测试就没有意义了。 上面也说了mocha一般搭配chai断言库，而chai有好几种断言风格，比较常见的有should和expect两种风格，我们分别看下这两种断言： 123456789101112var chai = require(&quot;chai&quot;), expect = chai.expect, should = chai.should();describe(&quot;测试addNum函数&quot;, () =&gt; &#123; it(&quot;1+2&quot;, () =&gt; &#123; addNum(1, 2).should.equal(3); &#125;); it(&quot;2+3&quot;, () =&gt; &#123; expect(addNum(2, 3)).to.be.equal(5); &#125;);&#125;); 这里should是后置的，在断言变量之后，而expect是前置的，作为断言的开始，两种风格纯粹看个人喜好；我们发现这里expect是从chai中获取的一个函数，而should则是直接调用，这是因为should实际上是给所有的对象都扩充了一个 getter 属性should，因此我们才能够在变量上使用.should方式来进行断言。 和chai的多种断言风格不同，jest内置了断言库expect，它的语法又有些不同： 12345678describe(&quot;测试addNum函数&quot;, () =&gt; &#123; it(&quot;1+2&quot;, () =&gt; &#123; expect(addNum(1, 2)).toBe(3); &#125;); it(&quot;2+3&quot;, () =&gt; &#123; expect(addNum(2, 3)).toBe(5); &#125;);&#125;); jest中的expect直接通过toBe的语法，在形式上相较于mocha更为简洁；这两个框架在使用上极其相似，比如在异步代码上都支持done回调和async/await关键字，在断言语法和其他用法有些差别；两者也有相同的钩子机制，连名字都相同beforeEach和afterEach；在vue cli脚手架创建项目时，也可以在两个框架中进行选择其一，我们这里主要以jest进行测试。 Jest Jest是Facebook出品的一个测试框架，相较于其他测试框架，最大的特点就是内置了常用的测试工具，比如自带断言、测试覆盖率工具，实现了开箱即用，这也和它官方的slogan相符。 Jest 是一个令人愉快的 JavaScript 测试框架，专注于简洁明快。 Jest几乎是零配置的，它会自动识别一些常用的测试文件，比如*.spec.js和 *.test.js后缀的测试脚本，所有的测试脚本都放在tests或__tests__目录下；我们可以在全局安装jest或者局部安装，然后在packages.json中指定测试脚本： 12345&#123; &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;jest&quot; &#125;&#125; 当我们运行npm run test时会自动运行测试目录下所有测试文件，完成测试；我们在jest官网可能还会看到通过test函数写的测试用例： 123test(&quot;1+2&quot;, () =&gt; &#123; expect(addNum(1, 2)).toBe(3);&#125;); 和it函数相同，test函数也代表一个测试用例，mocha只支持it，而jest支持it和test，这里为了和jest官网保持统一，下面代码统一使用test函数。 匹配器 我们经常需要对测试代码返回的值进行匹配测试，上面代码中的toBe是最简单的一个匹配器，用来测试两个数值是否相同。 12345678test(&quot;test tobe&quot;, () =&gt; &#123; expect(2 + 2).toBe(4); expect(true).toBe(true); const val = &quot;team&quot;; expect(val).toBe(&quot;team&quot;); expect(undefined).toBe(undefined); expect(null).toBe(null);&#125;); toBe函数内部使用了Object.is来进行精确匹配，它的特性类似于===；对于普通类型的数值可以进行比较，但是对于对象数组等复杂类型，就需要用到toEqual来比较了： 1234567891011121314 test(&quot;expect a object&quot;, () =&gt; &#123; var obj = &#123; a: &quot;1&quot;, &#125;; obj.b = &quot;2&quot;; expect(obj).toEqual(&#123; a: &quot;1&quot;, b: &quot;2&quot; &#125;);&#125;);test(&quot;expect array&quot;, () =&gt; &#123; var list = []; list.push(1); list.push(2); expect(list).toEqual([1, 2]);&#125;); 我们有时候还需要对undefined、null等类型或者对条件语句中的表达式的真假进行精确匹配，Jest也有五个函数帮助我们： toBeNull：只匹配null toBeUndefined：只匹配undefined toBeDefined：与toBeUndefined相反，等价于.not.toBeUndefined toBeTruthy：匹配任何 if 语句为真 toBeFalsy：匹配任何 if 语句为假 123456789101112131415161718192021222324test(&quot;null&quot;, () =&gt; &#123; const n = null; expect(n).toBeNull(); expect(n).not.toBeUndefined(); expect(n).toBeDefined(); expect(n).not.toBeTruthy(); expect(n).toBeFalsy();&#125;);test(&quot;0&quot;, () =&gt; &#123; const z = 0; expect(z).not.toBeNull(); expect(z).not.toBeUndefined(); expect(z).toBeDefined(); expect(z).not.toBeTruthy(); expect(z).toBeFalsy();&#125;);test(&quot;undefined&quot;, () =&gt; &#123; const a = undefined; expect(a).not.toBeNull(); expect(a).toBeUndefined(); expect(a).not.toBeDefined(); expect(a).not.toBeTruthy(); expect(a).toBeFalsy();&#125;); toBeTruthy和toBeFalsy用来判断在if语句中的表达式是否成立，等价于`if(n)和if(!n)``的判断。 对于数值类型的数据，我们有时候也可以通过大于或小于来进行判断： 1234567891011121314test(&quot;number&quot;, () =&gt; &#123; const val = 2 + 2; // 大于 expect(val).toBeGreaterThan(3); // 大于等于 expect(val).toBeGreaterThanOrEqual(3.5); // 小于 expect(val).toBeLessThan(5); // 小于等于 expect(val).toBeLessThanOrEqual(4.5); // 完全判断 expect(val).toBe(4); expect(val).toEqual(4);&#125;); 浮点类型的数据虽然我们也可以用toBe和toEqual来进行比较，但是如果遇到有些特殊的浮点数据计算，比如0.1+0.2就会出现问题，我们可以通过toBeCloseTo来判断： 1234test(&quot;float&quot;, () =&gt; &#123; // expect(0.1 + 0.2).toBe(0.3); 报错 expect(0.1 + 0.2).toBeCloseTo(0.3);&#125;); 对于数组、set或者字符串等可迭代类型的数据，可以通过toContain来判断内部是否有某一项： 123456789101112test(&quot;expect iterable&quot;, () =&gt; &#123; const shoppingList = [ &quot;diapers&quot;, &quot;kleenex&quot;, &quot;trash bags&quot;, &quot;paper towels&quot;, &quot;milk&quot;, ]; expect(shoppingList).toContain(&quot;milk&quot;); expect(new Set(shoppingList)).toContain(&quot;diapers&quot;); expect(&quot;abcdef&quot;).toContain(&quot;cde&quot;);&#125;); 异步代码 我们项目中经常也会涉及到异步代码，比如setTimeout、接口请求等都会涉及到异步，那么这些异步代码怎么来进行测试呢？假设我们有一个异步获取数据的函数fetchData： 12345export function fetchData(cb) &#123; setTimeout(() =&gt; &#123; cb(&quot;res data&quot;); &#125;, 2000);&#125; 在2秒后通过回调函数返回了一个字符串，我们可以在测试用例的函数中使用一个done的参数，Jest会等done回调后再完成测试： 1234567891011test(&quot;callback&quot;, (done) =&gt; &#123; function cb(data) &#123; try &#123; expect(data).toBe(&quot;res data&quot;); done(); &#125; catch (error) &#123; done(); &#125; &#125; fetchData(cb);&#125;); 我们将一个回调函数传入fetchData，在回调函数中对返回的数据进行断言，在断言结束后需要调用done；如果最后没有调用done，那么Jest不知道什么时候结束，就会报错；在我们日常代码中，都会通过promise来获取数据，将我们的fetchData进行一下改写： 1234567export function fetchData() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&quot;promise data&quot;); &#125;, 2000); &#125;);&#125; Jest支持在测试用例中直接返回一个promise，我们可以在then中进行断言： 12345test(&quot;promise callback&quot;, () =&gt; &#123; return fetchData().then((res) =&gt; &#123; expect(res).toBe(&quot;promise data&quot;); &#125;);&#125;); 除了直接将fetchData返回，我们也可以在断言中使用.resolves/.rejects 匹配符，Jest也会等待promise结束： 123test(&quot;promise callback&quot;, () =&gt; &#123; return expect(fetchData()).resolves.toBe(&quot;promise data&quot;);&#125;); 除此之外，Jest还支持async/await，不过我们需要在test的匿名函数加上async修饰符表示： 1234test(&quot;async/await callback&quot;, async () =&gt; &#123; const data = await fetchData(); expect(data).toBe(&quot;promise data&quot;);&#125;); 全局挂载与卸载 全局挂载和卸载有点类似Vue-Router的全局守卫，在每个导航触发前和触发后做一些操作；在Jest中也有，比如我们需要在每个测试用例前初始化一些数据，或者在每个测试用例之后清除数据，就可以使用beforeEach和afterEach： 12345678910111213141516let cityList = []beforeEach(() =&gt; &#123; initializeCityDatabase();&#125;);afterEach(() =&gt; &#123; clearCityDatabase();&#125;);test(&quot;city data has suzhou&quot;, () =&gt; &#123; expect(cityList).toContain(&quot;suzhou&quot;)&#125;)test(&quot;city data has shanghai&quot;, () =&gt; &#123; expect(cityList).toContain(&quot;suzhou&quot;)&#125;) 这样，每个测试用例进行测试前都会调用init，每次结束后都会调用clear；我们有可能会在某些test中更改cityList的数据，但是在beforeEach进行初始化的操作后，每个测试用例获取的cityList数据就保证都是相同的；和上面一节异步代码一样，在beforeEach和afterEach我们也可以使用异步代码来进行初始化： 12345678910let cityList = []beforeEach(() =&gt; &#123; return initializeCityDatabase().then((res)=&gt;&#123; cityList = res.data &#125;);&#125;);//或者使用async/awaitbeforeEach(async () =&gt; &#123; cityList = await initializeCityDatabase();&#125;); 和beforeEach和afterEach相对应的就是beforeAll和afterAll，区别就是beforeAll和afterAll只会执行一次；beforeEach和afterEach默认会应用到每个test，但是我们可能希望只针对某些test，我们可以通过describe将这些test放到一起，这样就只应用到describe块中的test： 12345678910beforeEach(() =&gt; &#123; // 应用到所有的test&#125;);describe(&quot;put test together&quot;, () =&gt; &#123; beforeEach(() =&gt; &#123; // 只应用当前describe块中的test &#125;); test(&quot;test1&quot;, ()=&gt; &#123;&#125;) test(&quot;test2&quot;, ()=&gt; &#123;&#125;)&#125;); 模拟函数 在项目中，一个模块的函数内常常会去调用另外一个模块的函数。在单元测试中，我们可能并不需要关心内部调用的函数的执行过程和结果，只想知道被调用模块的函数是否被正确调用，甚至会指定该函数的返回值，因此模拟函数十分有必要。 如果我们正在测试一个函数forEach，它的参数包括了一个回调函数，作用在数组上的每个元素： 12345export function forEach(items, callback) &#123; for (let index = 0; index &lt; items.length; index++) &#123; callback(items[index]); &#125;&#125; 为了测试这个forEach，我们需要构建一个模拟函数，来检查模拟函数是否按照预期被调用了： 123456789test(&quot;mock callback&quot;, () =&gt; &#123; const mockCallback = jest.fn((x) =&gt; 42 + x); forEach([0, 1, 2], mockCallback); expect(mockCallback.mock.calls.length).toBe(3); expect(mockCallback.mock.calls[0][0]).toBe(0); expect(mockCallback.mock.calls[1][0]).toBe(1); expect(mockCallback.mock.calls[2][0]).toBe(1); expect(mockCallback.mock.results[0].value).toBe(42);&#125;); 我们发现在mockCallback有一个特殊的.mock属性，它保存了模拟函数被调用的信息；我们打印出来看下： 它有四个属性： calls：调用参数 instances：this指向 invocationCallOrder：函数调用顺序 results：调用结果 在上面属性中有一个instances属性，表示了函数的this指向，我们还可以通过bind函数来更改我们模拟函数的this： 123456789test(&quot;mock callback&quot;, () =&gt; &#123; const mockCallback = jest.fn((x) =&gt; 42 + x); const obj = &#123; a: 1 &#125;; const bindMockCallback = mockCallback.bind(obj); forEach([0, 1, 2], bindMockCallback); expect(mockCallback.mock.instances[0]).toEqual(obj); expect(mockCallback.mock.instances[1]).toEqual(obj); expect(mockCallback.mock.instances[2]).toEqual(obj);&#125;); 通过bind更改函数的this之后，我们可以用instances来进行检测；模拟函数可以在运行时将返回值进行注入： 12345678910111213141516const myMock = jest.fn();// undefinedconsole.log(myMock());myMock .mockReturnValueOnce(10) .mockReturnValueOnce(&quot;x&quot;) .mockReturnValue(true);//10 x true trueconsole.log(myMock(), myMock(), myMock(), myMock());myMock.mockReturnValueOnce(null);// null true trueconsole.log(myMock(), myMock(), myMock()); 我们第一次执行myMock，由于没有注入任何返回值，然后通过mockReturnValueOnce和mockReturnValue进行返回值注入，Once只会注入一次；模拟函数在连续性函数传递返回值时使用注入非常的有用： 1234const filterFn = jest.fn();filterFn.mockReturnValueOnce(true).mockReturnValueOnce(false);const result = [2, 3].filter((num) =&gt; filterFn(num));expect(result).toEqual([2]); 我们还可以对模拟函数的调用情况进行断言： 12345678910111213const mockFunc = jest.fn();// 断言函数还没有被调用expect(mockFunc).not.toHaveBeenCalled();mockFunc(1, 2);mockFunc(2, 3);// 断言函数至少调用一次expect(mockFunc).toHaveBeenCalled();// 断言函数调用参数expect(mockFunc).toHaveBeenCalledWith(1, 2);expect(mockFunc).toHaveBeenCalledWith(2, 3);// 断言函数最后一次的调用参数expect(mockFunc).toHaveBeenLastCalledWith(2, 3); 除了能对函数进行模拟，Jest还支持拦截axios返回数据，假如我们有一个获取用户的接口： 123456789101112// /src/api/usersconst axios = require(&quot;axios&quot;);function fetchUserData() &#123; return axios .get(&quot;/user.json&quot;) .then((resp) =&gt; resp.data);&#125;module.exports = &#123; fetchUserData,&#125;; 现在我们想要测试fetchUserData函数获取数据但是并不实际请求接口，我们可以使用jest.mock来模拟axios模块： 1234567891011121314151617const users = require(&quot;../api/users&quot;);const axios = require(&quot;axios&quot;);jest.mock(&quot;axios&quot;);test(&quot;should fetch users&quot;, () =&gt; &#123; const userData = &#123; name: &quot;aaa&quot;, age: 10, &#125;; const resp = &#123; data: userData &#125;; axios.get.mockResolvedValue(resp); return users.fetchUserData().then((res) =&gt; &#123; expect(res).toEqual(userData); &#125;);&#125;); 一旦我们对模块进行了模拟，我们可以用get函数提供一个mockResolvedValue方法，以返回我们需要测试的数据；通过模拟后，实际上axios并没有去真正发送请求去获取/user.json的数据。 Vue Test Utils Vue Test Utils是Vue.js官方的单元测试实用工具库，能够对我们编写的Vue组件进行测试。 挂载组件 在Vue中我们通过import引入组件，然后在components进行注册后就能使用；在单元测试中，我们使用mount来进行挂载组件；假如我们写了一个计数器组件counter.js，用来展示count，并且有一个按钮操作count： 123456789101112131415161718192021&lt;!-- Counter.vue --&gt;&lt;template&gt; &lt;div class=&quot;counter&quot;&gt; &lt;span class=&quot;count&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/span&gt; &lt;button id=&quot;add&quot; @click=&quot;add&quot;&gt;加&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; count: 0, &#125;; &#125;, methods: &#123; add() &#123; this.count++; &#125;, &#125;,&#125;;&lt;/script&gt; 组件进行挂载后得到一个wrapper（包裹器），wrapper会暴露很多封装、遍历和查询其内部的Vue组件实例的便捷的方法。 1234import &#123; mount &#125; from &quot;@vue/test-utils&quot;;import Counter from &quot;@/components/Counter&quot;;const wrapper = mount(Counter);const vm = wrapper.vm; 我们可以通过wrapper.vm来访问组件的Vue实例，进而获取实例上的methods和data等；通过wrapper，我们可以对组件的渲染情况做断言： 123456789101112131415// test/unit/counter.spec.jsdescribe(&quot;Counter&quot;, () =&gt; &#123; const wrapper = mount(Counter); test(&quot;counter class&quot;, () =&gt; &#123; expect(wrapper.classes()).toContain(&quot;counter&quot;); expect(wrapper.classes(&quot;counter&quot;)).toBe(true); &#125;); test(&quot;counter has span&quot;, () =&gt; &#123; expect(wrapper.html()).toContain(&quot;&lt;span class=&quot;count&quot;&gt;0&lt;/span&gt;&quot;); &#125;); test(&quot;counter has btn&quot;, () =&gt; &#123; expect(wrapper.find(&quot;button#add&quot;).exists()).toBe(true); expect(wrapper.find(&quot;button#add&quot;).exists()).not.toBe(false); &#125;);&#125;); 上面几个函数我们根据名字也能猜出它们的作用： classes：获取wrapper的class，并返回一个数组 html：获取组件渲染html结构字符串 find：返回匹配子元素的wrapper exists：断言wrapper是否存在 find返回的是查找的第一个DOM节点，但有些情况我们希望能操作一组DOM，我们可以用findAll函数： 123456const wrapper = mount(Counter);// 返回一组wrapperconst divList = wrapper.findAll(&#x27;div&#x27;);divList.length// 找到第一个div，返回它的wrapperconst firstDiv = divList.at(0); 有些组件需要通过外部传入的props、插槽slots、provide/inject等其他的插件或者属性，我们在mount挂载时可以传入一个对象，设置这些额外属性： 1234567891011121314151617181920212223242526272829303132333435363738394041424344const wrapper = mount(Component, &#123; // 向组件传入data，合并到现有的data中 data() &#123; return &#123; foo: &quot;bar&quot; &#125; &#125;, // 设置组件的props propsData: &#123; msg: &quot;hello&quot; &#125;, // vue本地拷贝 localVue, // 伪造全局对象 mocks: &#123; $route &#125;, // 插槽 // 键名就是相应的 slot 名 // 键值可以是一个组件、一个组件数组、一个字符串模板或文本。 slots: &#123; default: SlotComponent, foo: &quot;&lt;div /&gt;&quot;, bar: &quot;&lt;my-component /&gt;&quot;, baz: &quot;&quot; &#125;, // 用来注册自定义组件 stubs: &#123; &quot;my-component&quot;: MyComponent, &quot;el-button&quot;: true, &#125;, // 设置组件实例的$attrs 对象。 attrs: &#123;&#125;, // 设置组件实例的$listeners对象。 listeners: &#123; click: jest.fn() &#125;, // 为组件传递用于注入的属性 provide: &#123; foo() &#123; return &quot;fooValue&quot; &#125; &#125;&#125;) stubs主要用来处理在全局注册的自定义组件，比如我们常用的组件库Element等，直接使用el-button、el-input组件，或者vue-router注册在全局的router-view组件等；当我们在单元测试中引入时就会提示我们对应的组件找不到，这时我们就可以通过这个stubs来避免报错。 我们在对某个组件进行单元测试时，希望只针对单一组件进行测试，避免子组件带来的副作用；比如我们在父组件ParentComponent中判断是否有某个div时，恰好子组件ChildComponent也渲染了该div，那么就会对我们的测试带来一定的干扰；我们可以使用shallowMount挂载函数，相遇比mount，shallowMount不会渲染子组件： 12import &#123; shallowMount &#125; from &#x27;@vue/test-utils&#x27;const wrapper = shallowMount(Component) 这样就保证了我们需要测试的组件在渲染时不会渲染其子组件，避免子组件的干扰。 操作组件 我们经常需要对子组件中的元素或者子组件的数据进行一些操作和修改，比如页面的点击、修改data数据，进行操作后再来断言数据是否正确；我们以一个简单的Form组件为例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;template&gt; &lt;div class=&quot;form&quot;&gt; &lt;div class=&quot;title&quot;&gt;&#123;&#123; title &#125;&#125;&lt;/div&gt; &lt;div&gt; &lt;span&gt;请填写姓名：&lt;/span&gt; &lt;input type=&quot;text&quot; id=&quot;name-input&quot; v-model=&quot;name&quot; /&gt; &lt;div class=&quot;name&quot;&gt;&#123;&#123; name &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;请选择性别：&lt;/span&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&quot;sex&quot; value=&quot;f&quot; id=&quot;&quot; /&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&quot;sex&quot; value=&quot;m&quot; id=&quot;&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;请选择爱好：&lt;/span&gt; footbal &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; v-model=&quot;hobby&quot; value=&quot;footbal&quot; /&gt; basketball &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; v-model=&quot;hobby&quot; value=&quot;basketball&quot; /&gt; ski &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; v-model=&quot;hobby&quot; value=&quot;ski&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;input :class=&quot;submit ? &#x27;submit&#x27; : &#x27;&#x27;&quot; type=&quot;submit&quot; value=&quot;提交&quot; @click=&quot;clickSubmit&quot; /&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;Form&quot;, props: &#123; title: &#123; type: String, default: &quot;表单名称&quot;, &#125;, &#125;, data() &#123; return &#123; name: &quot;&quot;, sex: &quot;f&quot;, hobby: [], submit: false, &#125;; &#125;, methods: &#123; clickSubmit() &#123; this.submit = !this.submit; &#125;, &#125;,&#125;;&lt;/script&gt; 我们可以向Form表单组件传入一个title，作为表单的名称，其内部也有input、radio和checkbox等一系列元素，我们就来看下怎么对这些元素进行修改；首先我们来修改props的值，在组件初始化的时候我们传入了propsData，在后续的代码中我们可以通过setProps对props值进行修改： 1234567891011121314const wrapper = mount(Form, &#123; propsData: &#123; title: &quot;form title&quot;, &#125;,&#125;);const vm = wrapper.vm;test(&quot;change prop&quot;, () =&gt; &#123; expect(wrapper.find(&quot;.title&quot;).text()).toBe(&quot;form title&quot;); wrapper.setProps(&#123; title: &quot;new form title&quot;, &#125;); // 报错了 expect(wrapper.find(&quot;.title&quot;).text()).toBe(&quot;new form title&quot;);&#125;); 我们满怀期待进行测试，但是发现最后一条断言报错了；这是因为Vue异步更新数据，我们改变prop和data后，获取dom发现数据并不会立即更新；在页面上我们一般都会通过$nextTick进行解决，在单元测试时，我们也可以使用nextTick配合获取DOM： 123456789101112131415161718192021test(&quot;change prop1&quot;, async () =&gt; &#123; expect(wrapper.find(&quot;.title&quot;).text()).toBe(&quot;new form title&quot;); wrapper.setProps(&#123; title: &quot;new form title1&quot;, &#125;); await Vue.nextTick(); // 或者使用vm的nextTick // await wrapper.vm.nextTick(); expect(wrapper.find(&quot;.title&quot;).text()).toBe(&quot;new form title1&quot;);&#125;);test(&quot;change prop2&quot;, (done) =&gt; &#123; expect(wrapper.find(&quot;.title&quot;).text()).toBe(&quot;new form title1&quot;); wrapper.setProps(&#123; title: &quot;new form title2&quot;, &#125;); Vue.nextTick(() =&gt; &#123; expect(wrapper.find(&quot;.title&quot;).text()).toBe(&quot;new form title2&quot;); done(); &#125;);&#125;); 和Jest中测试异步代码一样，我们也可以使用done回调或者async/await来进行异步测试；除了设置props，setData可以用来改变wrapper中的data： 12345678test(&quot;test set data&quot;, async () =&gt; &#123; wrapper.setData(&#123; name: &quot;new name&quot;, &#125;); expect(vm.name).toBe(&quot;new name&quot;); await Vue.nextTick(); expect(wrapper.find(&quot;.name&quot;).text()).toBe(&quot;new name&quot;);&#125;); 对于input、textarea或者select这种输入性的组件元素，我们有两种方式来改变他们的值： 1234567891011121314test(&quot;test input set value&quot;, async () =&gt; &#123; const input = wrapper.find(&quot;#name-input&quot;); await input.setValue(&quot;change input by setValue&quot;); expect(vm.name).toBe(&quot;change input by setValue&quot;); expect(input.element.value).toBe(&quot;change input by setValue&quot;);&#125;);// 等价于test(&quot;test input trigger&quot;, () =&gt; &#123; const input = wrapper.find(&quot;#name-input&quot;); input.element.value = &quot;change input by trigger&quot;; // 通过input.element.value改变值后必须触发trigger才能真正修改 input.trigger(&quot;input&quot;); expect(vm.name).toBe(&quot;change input by trigger&quot;);&#125;); 可以看出，通过input.element.value或者setValue的两种方式改变值后，由于v-model绑定关系，因此vm中的data数据也进行了改变；我们还可以通过input.element.value来获取input元素的值。 对于radio、checkbox选择性的组件元素，我们可以通过setChecked(Boolean)函数来触发值的更改，更改同时也会更新元素上v-model绑定的值： 12345678910111213141516test(&quot;test radio&quot;, () =&gt; &#123; expect(vm.sex).toBe(&quot;f&quot;); const radioList = wrapper.findAll(&#x27;input[name=&quot;sex&quot;]&#x27;); radioList.at(1).setChecked(); expect(vm.sex).toBe(&quot;m&quot;);&#125;);test(&quot;test checkbox&quot;, () =&gt; &#123; expect(vm.hobby).toEqual([]); const checkboxList = wrapper.findAll(&#x27;input[name=&quot;hobby&quot;]&#x27;); checkboxList.at(0).setChecked(); expect(vm.hobby).toEqual([&quot;footbal&quot;]); checkboxList.at(1).setChecked(); expect(vm.hobby).toEqual([&quot;footbal&quot;, &quot;basketball&quot;]); checkboxList.at(0).setChecked(false); expect(vm.hobby).toEqual([&quot;basketball&quot;]);&#125;); 对于按钮等元素，我们希望在上面触发点击操作，可以使用trigger进行触发： 1234567test(&quot;test click&quot;, async () =&gt; &#123; const submitBtn = wrapper.find(&#x27;input[type=&quot;submit&quot;]&#x27;); await submitBtn.trigger(&quot;click&quot;); expect(vm.submit).toBe(true); await submitBtn.trigger(&quot;click&quot;); expect(vm.submit).toBe(false);&#125;); 自定义事件 对于一些组件，可能会通过$emit触发一些返回数据，比如我们改写上面Form表单中的submit按钮，点击后返回一些数据： 12345678&#123; methods: &#123; clickSubmit() &#123; this.$emit(&quot;foo&quot;, &quot;foo1&quot;, &quot;foo2&quot;); this.$emit(&quot;bar&quot;, &quot;bar1&quot;); &#125;, &#125;,&#125; 除了触发组件中元素的点击事件进行$emi，我们还可以通过wrapper.vm触发，因为vm本身相当于组件的this： 1wrapper.vm.$emit(&quot;foo&quot;, &quot;foo3&quot;); 最后，所有$emit触发返回的数据都存储在wrapper.emitted()，它返回了一个对象；结构如下： 1234&#123; foo: [ [ &#x27;foo1&#x27;, &#x27;foo2&#x27; ], [ &#x27;foo3&#x27; ] ], bar: [ [ &#x27;bar1&#x27; ] ]&#125; emitted()返回对象中的属性是一个数组，数组的length代表了这个方法被触发了多少次；我们可以对对象上的属性进行断言，来判断组件的emit是否被触发： 1234567891011121314test(&quot;test emit&quot;, async () =&gt; &#123; // 组件元素触发emit await wrapper.find(&#x27;input[type=&quot;submit&quot;]&#x27;).trigger(&quot;click&quot;); wrapper.vm.$emit(&quot;foo&quot;, &quot;foo3&quot;); await vm.$nextTick(); // foo被触发过 expect(wrapper.emitted().foo).toBeTruthy(); // foo触发过两次 expect(wrapper.emitted().foo.length).toBe(2); // 断言foo第一次触发的数据 expect(wrapper.emitted().foo[0]).toEqual([&quot;foo1&quot;, &quot;foo2&quot;]); // baz没有触发 expect(wrapper.emitted().baz).toBeFalsy();&#125;); 我们也可以把emitted()函数进行改写，并不是一次性获取整个emitted对象： 12expect(wrapper.emitted(&#x27;foo&#x27;)).toBeTruthy();expect(wrapper.emitted(&#x27;foo&#x27;).length).toBe(2); 有一些组件触发emit事件可能是由其子组件触发的，我们可以通过子组件的vm进行emit： 12345678910import &#123; mount &#125; from &#x27;@vue/test-utils&#x27;import ParentComponent from &#x27;@/components/ParentComponent&#x27;import ChildComponent from &#x27;@/components/ChildComponent&#x27;describe(&#x27;ParentComponent&#x27;, () =&gt; &#123; it(&quot;emit&quot;, () =&gt; &#123; const wrapper = mount(ParentComponent) wrapper.find(ChildComponent).vm.$emit(&#x27;custom&#x27;) &#125;)&#125;) 配合Vue-Router 在有些组件中，我们有可能会用到Vue-Router的相关组件或者Api方法，比如我们有一个Header组件： 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;div @click=&quot;jump&quot;&gt;&#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt; &lt;router-link :to=&quot;&#123; path: &#x27;/detail&#x27; &#125;&quot;&gt;&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123;&#125;; &#125;, mounted() &#123;&#125;, methods: &#123; jump() &#123; this.$router.push(&#123; path: &quot;/list&quot;, &#125;); &#125;, &#125;,&#125;;&lt;/script&gt; 直接在测试脚本中引入会报错，提示找不到router-link和router-view两个组件和$route属性；这里不推荐使用Vue.use(VueRouter)，因为会污染全局的Vue；我们有两种方法解决，第一种使用createLocalVue 创建一个Vue的类，我们可以在这个类中进行添加组件、混入和安装插件而不会污染全局的Vue类： 1234567891011121314151617import &#123; shallowMount, createLocalVue &#125; from &#x27;@vue/test-utils&#x27;import VueRouter from &#x27;vue-router&#x27;import Header from &quot;@/components/Header&quot;;// 一个Vue类const localVue = createLocalVue()localVue.use(VueRouter)// 路由数组const routes = []const router = new VueRouter(&#123; routes&#125;)shallowMount(Header, &#123; localVue, router&#125;) 我们来看下这里做了哪些操作，通过createLocalVue创建了一个localVue，相当于import Vue；然后localVue.use告诉Vue来使用VueRouter，和Vue.use有着相同的作用；最后实例化创建router对象传入shallowMount进行挂载。 第二种方式是注入伪造数据，这里主要用的就是mocks和stubs，mocks用来伪造$route和$router等全局对象，是一种将属性添加到Vue.prototype上的方式；而stubs用来覆写全局或局部注册的组件： 12345678910111213141516171819202122232425import &#123; mount &#125; from &quot;@vue/test-utils&quot;;import Header from &quot;@/components/Header&quot;;describe(&quot;header&quot;, () =&gt; &#123; const $route = &#123; path: &quot;/home&quot;, params: &#123; id: &quot;111&quot;, &#125;, &#125;; const $router = &#123; push: jest.fn(), &#125;; const wrapper = mount(Header, &#123; stubs: [&quot;router-view&quot;, &quot;router-link&quot;], mocks: &#123; $route, $router, &#125;, &#125;); const vm = wrapper.vm; test(&quot;render home div&quot;, () =&gt; &#123; expect(wrapper.find(&quot;div&quot;).text()).toBe(&quot;111&quot;); &#125;);&#125;); 相比于第一种方式，第二种方式可操作性更强，可以直接伪造$route路由的数据；一般第一种方式不会单独使用，经常会搭配第二种伪造数据的方式。 配合Vuex 我们通常会在组件中会用到vuex，我们可以通过伪造store数据来模拟测试，假如我们有一个的count组件，它的数据存放在vuex中： 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div&gt; &lt;div class=&quot;number&quot;&gt;&#123;&#123; number &#125;&#125;&lt;/div&gt; &lt;div class=&quot;add&quot; @click=&quot;clickAdd&quot;&gt;add&lt;/div&gt; &lt;div class=&quot;sub&quot; @click=&quot;clickSub&quot;&gt;sub&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapState, mapGetters &#125; from &quot;vuex&quot;;export default &#123; name: &quot;Count&quot;, computed: &#123; ...mapState(&#123; number: (state) =&gt; state.number, &#125;), &#125;, methods: &#123; clickAdd() &#123; this.$store.commit(&quot;ADD_COUNT&quot;); &#125;, clickSub() &#123; this.$store.commit(&quot;SUB_COUNT&quot;); &#125;, &#125;,&#125;;&lt;/script&gt; 在vuex中我们通过mutations对number进行修改： 12345678910111213export default new Vuex.Store(&#123; state: &#123; number: 0, &#125;, mutations: &#123; ADD_COUNT(state) &#123; state.number = state.number + 1; &#125;, SUB_COUNT(state) &#123; state.number = state.number - 1; &#125;, &#125;&#125;); 那我们现在如何来伪造store数据呢？这里和Vue-Router的原理是一样的，通过createLocalVue创建一个隔离的Vue类： 123456789101112131415161718192021222324252627282930import &#123; mount, createLocalVue &#125; from &quot;@vue/test-utils&quot;;import Count from &quot;@/components/Count&quot;;import Vuex from &quot;vuex&quot;;const localVue = createLocalVue();localVue.use(Vuex);describe(&quot;count&quot;, () =&gt; &#123; const state = &#123; number: 0, &#125;; const mutations = &#123; ADD_COUNT: jest.fn(), SUB_COUNT: jest.fn(), &#125;; const store = new Vuex.Store(&#123; state, mutations &#125;); test(&quot;render&quot;, async () =&gt; &#123; const wrapper = mount(Count, &#123; store, localVue, &#125;); expect(wrapper.find(&quot;.number&quot;).text()).toBe(&quot;0&quot;); wrapper.find(&quot;.add&quot;).trigger(&quot;click&quot;); expect(mutations.ADD_COUNT).toHaveBeenCalled(); expect(mutations.SUB_COUNT).not.toHaveBeenCalled(); &#125;);&#125;); 我们看一下这里做了什么操作，前面和VueRouter一样创建一个隔离类localVue；然后通过new Vuex.Store创建了一个store并填入假数据state和mutations；这里我们并不关心mutations中函数做了哪些操作，我们只要知道元素点击触发了哪个mutations函数，通过伪造的函数我们去断言mutations是否被调用。 另一种测试store数据的方式是创建一个运行中的store，不再通过页面触发Vuex中的函数，这样的好处就是不需要伪造Vuex函数；假设我们有一个store/list.js 123456789101112131415export default &#123; state: &#123; list: [], &#125;, getters: &#123; joinList: (state) =&gt; &#123; return state.list.join(&quot;,&quot;); &#125;, &#125;, mutations: &#123; PUSH(state, payload) &#123; state.list.push(payload); &#125;, &#125;,&#125;; 12345678910111213141516171819202122232425import &#123; createLocalVue &#125; from &quot;@vue/test-utils&quot;;import Vuex from &quot;vuex&quot;;import &#123; cloneDeep &#125; from &quot;lodash&quot;;import listStore from &quot;@/store/list&quot;;describe(&quot;list&quot;, () =&gt; &#123; test(&quot;expect list&quot;, () =&gt; &#123; const localVue = createLocalVue(); localVue.use(Vuex); const store = new Vuex.Store(cloneDeep(listStore)); expect(store.state.list).toEqual([]); store.commit(&quot;PUSH&quot;, &quot;1&quot;); expect(store.state.list).toEqual([&quot;1&quot;]); &#125;); test(&quot;list getter&quot;, () =&gt; &#123; const localVue = createLocalVue(); localVue.use(Vuex); const store = new Vuex.Store(cloneDeep(listStore)); expect(store.getters.joinList).toBe(&quot;&quot;); store.commit(&quot;PUSH&quot;, &quot;1&quot;); store.commit(&quot;PUSH&quot;, &quot;3&quot;); expect(store.getters.joinList).toBe(&quot;1,3&quot;); &#125;);&#125;); 我们直接创建了一个store，通过store来进行commit和getters的操作。 总结 前端框架迭代不断，但是前端单元测试确显有人关注；一个健壮的前端项目应该有单元测试的模块，保证了我们的项目代码质量和功能的稳定；但是也并不是所有的项目都需要有单元测试的，毕竟编写测试用例也需要成本；因此如果你的项目符合下面的几个条件，就可以考虑引入单元测试： 长期稳定的项目迭代，需要保证代码的可维护性和功能稳定； 页面功能相对来说说比较复杂，逻辑较多； 对于一些复用性很高的组件，可以考虑单元测试；","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"Vue","slug":"Vue","permalink":"http://xieyufei.com/tags/Vue/"},{"name":"测试","slug":"Test","permalink":"http://xieyufei.com/tags/Test/"}]},{"title":"金三银四面试季，防抖节流要牢记","date":"2021-04-10T14:00:00.000Z","path":"2021/04/10/Debounce-Throttle.html","text":"最近是金三银四面试季，相信不少公司面试题都会涉及到防抖节流的问题，有的面试题甚至是手写实现，今天我们就来看下防抖节流的应用场景以及它内部实现的逻辑。 什么是防抖节流 用户在页面上进行窗口大小的调整、滚动页面或者在输入框搜索联想词等一系列操作时，都会频繁的触发事件处理函数；如果这时候又需要在事件处理函数里去异步获取数据或者进行DOM的操作等耗性能的操作时，容易导致页面卡顿等影响用户的体验；这时就可以通过防抖（debounce）和节流（throttle）函数来限制事件处理函数的调用频率，提升用户的体验。 最上面正常执行每一条竖线代表了每一次事件处理函数的调用，中间是经过防抖函数处理后实际的调用情况，最下面是经过节流函数处理后的调用情况；发现比最上面密集调用的情况要少了很多。 实现防抖 防抖，最开始是用在相机上，我们在拍照时（包括用手机拍），经常会发现由于手的抖动，拍摄出来的画面发生重影或者模糊的情况；而现在的相机或手机基本都会加入防抖技术，除非我们抖动特别的厉害，防抖技术的加入可以让我们拍摄更多清晰的照片。 而在我们的JS中，防抖是指触发事件后n秒后才执行函数，如果在 n 秒内又触发了事件，则会重新计算函数执行时间；这段话比较绕口，我们以scroll函数为例： 1234function scrollHandler() &#123; console.log(&#x27;handle&#x27;)&#125;window.addEventListener(&#x27;scroll&#x27;, scrollHandler) 我们在页面滚动时会不断触发scrollHandler函数，但是我们不希望每次都触发，因此我们可以通过包装防抖函数来进行限制，当延迟时间超过n秒才真正执行scrollHandler函数。 而防抖函数实现的方式也很简单，在每次触发事件时，都设置一个定时器，延迟执行，并且取消之前的定时器。 12345678910111213function debounce(fn, wait) &#123; var timeout return function () &#123; var context = this, args = arguments clearTimeout(timeout) timeout = setTimeout(function () &#123; fn.apply(context, args) &#125;, wait) &#125;&#125;window.addEventListener(&#x27;scroll&#x27;, debounce(scrollHandler, 500)) debounce主要的目的就是延迟执行传入的fn函数，我们发现它返回了一个函数，是典型的闭包结构；页面滚动将每次触发scrollHandler变成每次都会触发debounce中返回的闭包函数；由于闭包的存在，因此timeout定时器变量会一直存在，触发闭包函数时都会清除上次设置的定时器。 这里调用fn时，很多fn函数都是滚动或者点击的回调函数，会提供Event对象进行处理，因此我们需要将原来的参数传入以及this进行绑定；因此分别赋值了变量context和args，这里arguments是类数组对象，那么什么是类数组对象呢，我们在函数中console.log出来看一下： 我们发现它的属性名是按照从0开始的index，第一个参数的属性是’0’，第二个属性名是’1’，并且它还有个length属性；但是它和数组不同的是它__proto__直接指向了Object，而数组的__proto__指向了Array；因此Array原型上的一些map、find等方法arguments也是没有的。 我们回到防抖函数，上面的防抖函数是非立即执行的，也就是触发事件后不会马上执行，但是我们某些场景下需要立即执行；立即执行后当n秒内触发事件才能再次执行。 因此我们来看下立即执行版本的防抖函数时如何来实现的： 1234567891011121314function debounce(fn, wait) &#123; let timeout, result; return function () &#123; const context = this const args = arguments clearTimeout(timeout) const callNow = !timeout timeout = setTimeout(function() &#123; timeout = null &#125;, wait) if (callNow) result = fn.apply(context, args) return result &#125;&#125; 在上面代码中我们还是通过闭包返回了一个匿名函数，但是在里面增加了一个变量callNow的判断，判断上一次的定时器是否已经被清除，如果没有定时器则立即执行fn函数。 在开发过程中我们需要根据不同的场景来切换不同版本的防抖函数，因此将两个防抖函数结合起来，根据参数来进行判断： 12345678910111213141516171819202122232425/** * fn：执行函数 * wait：延迟执行时间 * immediate：是否立即执行 **/function debounce(fn, wait, immediate) &#123; var timeout, result; return function () &#123; var context = this var args = arguments clearTimeout(timeout) if (immediate) &#123; var callNow = !timeout timeout = setTimeout(function () &#123; timeout = null &#125;, wait) if (callNow) result = fn.apply(context, args) &#125; else &#123; timeout = setTimeout(function () &#123; fn.apply(context, args) &#125;, wait) &#125; return result &#125;&#125; 到这里我们的防抖函数已经接近完美了，但是最后如果我们希望能够取消这里的debounce函数，比如我们传入wait是10秒，immediate为true，刚开始是立即执行fn函数的，但是我们需要等待10秒才能重新去触发fn函数，中间做的所有操作都是无效的；我们希望能有一个按钮，点击后能够取消上一次的防抖，然后我们就能够再次触发了。 这里改动也很简单，我们需要对返回闭包函数进行处理，但是由于是匿名函数，我们给他具名，同时赋值一个cancel函数用来清除闭包外的定时器timeout即可： 12345678910111213141516171819202122232425function debounce(fn, wait, immediate) &#123; var timeout, result; var debounced = function () &#123; var context = this var args = arguments clearTimeout(timeout) if (immediate) &#123; var callNow = !timeout timeout = setTimeout(function () &#123; timeout = null &#125;, wait) if (callNow) result = fn.apply(context, args) &#125; else &#123; timeout = setTimeout(function () &#123; fn.apply(context, args) &#125;, wait) &#125; return result &#125; debounced.cancel = function() &#123; clearTimeout(timeout) timeout = null &#125; return debounced&#125; 那么如何来调用这个cancel函数呢？我们还是以scroll函数为例，通过给页面上的btn取消按钮增加点击事件进行触发： 12345678var cancelBtn = document.getElementById(&#x27;btn&#x27;)var setDebounce = debounce(function () &#123; console.log(&#x27;handle&#x27;)&#125;, 10000, true)cancelBtn.addEventListener(&#x27;click&#x27;, function () &#123; setDebounce.cancel()&#125;)window.addEventListener(&#x27;scroll&#x27;, setDebounce) 到这里我们的防抖函数就很完美了。 实现节流 节流函数是指当持续触发事件时，保证一定时间段内只调用一次事件处理函数；也就是会稀释处理函数的执行频率。我们通过时间轴来清晰的看下它的执行过程： 我们可以看出，节流函数不管在一个周期内触发了多少次scroll函数，也不管触发的时间间隔，最后只会执行周期内的最后一次（或者第一次）；节流函数应用场景一般在窗口resize时进行布局的调整或者移动端监听touchmove事件时移动DOM元素等；节流函数同样也有时间戳和定时器两个版本，我们先来看定时器版的节流函数实现方式： 12345678910111213function throttle(fn, wait) &#123; let timeout; return function () &#123; let context = this let args = arguments if (!timeout) &#123; timeout = setTimeout(function() &#123; timeout = null fn.apply(context, args) &#125;, wait) &#125; &#125;&#125; 和防抖函数每次清除timeout不同，这里对timeout进行非空判断，只有它为空的时候才能设置定时器，这样保证了在一段时间内同时只有一个定时器，在时间到之后会释放定时器并且执行fn函数，重新设置定时器。 我们再来看下时间戳版本的节流函数： 12345678910111213function throttle(fn, wait) &#123; var context, args var previous = 0 return function () &#123; var now = +new Date() context = this args = arguments if (now - previous &gt; wait) &#123; fn.apply(context, args) previous = now &#125; &#125;&#125; 时间戳版本的函数是在闭包函数的外部存储了一个previous变量，是上次执行的一个时间戳；每次触发内部闭包函数时与上次的时间戳进行对比判断，如果间隔时间大于我们设置的等待时间则执行fn函数，同时更新时间戳；同时由于我们初始化previous是0，而now当前的时间戳减去0肯定是会大于wait时间的，因此时间戳版本的节流函数fn一开始就会被触发。 通过上面我们很容易就能发现，两个版本的节流函数最大的不同就是fn函数执行的时间点，定时器版本由于setTimeout延时的特性，在时间段结束的时候触发fn函数，而时间戳版本是在时间段开始的时候触发。 同样的，我们可以将两种节流函数结合到一个函数，我们可以加上cancel取消方法： 123456789101112131415161718192021222324252627282930313233/** * fn：执行函数 * wait：延迟执行时间 * immediate：是否立即执行 **/function throttle(fn, wait, immediate) &#123; let timeout let previous = 0 var throttled = function () &#123; let context = this let args = arguments if (immediate) &#123; let now = Date.now() if (now - previous &gt; wait) &#123; fn.apply(context, args) previous = now &#125; &#125; else &#123; if (!timeout) &#123; timeout = setTimeout(() =&gt; &#123; timeout = null fn.apply(context, args) &#125;, wait) &#125; &#125; &#125; throttled.cancel = function() &#123; clearTimeout(timeout) previous = 0 timeout = null &#125; return throttled&#125;","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"面试","slug":"Interview","permalink":"http://xieyufei.com/tags/Interview/"}]},{"title":"JS设计模式之观察者模式","date":"2021-03-10T12:48:47.000Z","path":"2021/03/10/DesignPattern-Observer.html","text":"在翻阅设计模式的文章中，很多文章都是将观察者模式等同于发布订阅模式，虽然两者在本质一样，但在设计思想上还是存在一些差异的；今天我们来看一下两者有什么异同，以及在Vue源码中是如何利用发布订阅模式来实现数据响应式的。 观察者模式 我们先来看一下什么是观察者模式的定义： 观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新。观察者模式属于行为型模式。 这里又多了一个术语，行为型模式，它是对在不同的对象之间划分责任和算法的抽象化，行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用；行为型模式一共有以下11种，今天我们要说的观察者模式就是其中的一种： 模板方法模式（Template Method） 策略模式（Strategy） 命令模式（Command） 中介者模式（Mediator） 观察者模式（Observer） 迭代器模式（Iteratior） 访问者模式（Visiter） 责任链模式（Chain of Responsibility） 备忘录模式（Memento） 状态模式（State） 解释器模式（Interpreter） 我们回到观察者模式的定义，它定义一种一对多的关系；这里的一我们称为目标对象（Subject），它有增加/删除/通知等方法，而多则称为观察者对象（Observer），它可以接收目标对象（Subject）的状态改变并进行处理；目标对象可以添加一系列的观察者对象，当目标对象的状态发生改变时，就会通知所有的观察者对象。 下面我们通过代码来更具体的看一下目标对象和观察者对象是如何进行联系的： 123456789101112131415161718192021222324252627282930313233343536// 定义一个目标对象class Subject &#123; constructor() &#123; this.Observers = []; &#125; add(observer) &#123; //添加 this.Observers.push(observer); &#125; remove(observer) &#123; //移除 this.Observers.filter((item) =&gt; item === observer); &#125; notify() &#123; //通知所有观察者 this.Observers.forEach((item) =&gt; &#123; item.update(); &#125;); &#125;&#125;//定义观察者对象class Observer &#123; constructor(name) &#123; this.name = name; &#125; update() &#123; console.log(`my name is:$&#123;this.name&#125;`); &#125;&#125;let sub = new Subject();let obs1 = new Observer(&quot;observer11&quot;);let obs2 = new Observer(&quot;observer22&quot;);sub.add(obs1);sub.add(obs2);sub.notify(); 我们在这里定义了目标对象和观察者对象两个类，在目标对象中维护了一个观察者的数组，新增时将观察者向数组中push；然后通过notify通知所有的观察者；而观察者只有一个update函数，用来接收观察者更新后的一个回调；在有些版本的代码中会将观察者直接定义为一个函数，而非一个类，但是其本质都是一样的，都是调用观察者的更新接口进行通知。 这种模式的应用在日常中也很常见，比如我们给div绑定click监听事件，其本质就是观察者模式的一种应用： 1234567var btn = document.getElementById(&#x27;btn&#x27;)btn.addEventListener(&#x27;click&#x27;, function(ev)&#123; console.log(1)&#125;)btn.addEventListener(&#x27;click&#x27;, function(ev)&#123; console.log(2)&#125;) 这里的btn可以看作是我们的目标对象（被观察对象），当它被点击时，也就是它的状态发生了变化，那么它就会通知内部添加的观察者对象，也就是我们通过addEventListener函数添加的两个匿名函数。 我们发现，观察者模式好处是能够降低耦合，目标对象和观察者对象逻辑互不干扰，两者都专注于自身的功能，只提供和调用了更新接口；而缺点也很明显，在目标对象中维护的所有观察者都能接收到通知，无法进行过滤筛选。 发布订阅模式 我们去搜索24种基本的设计模式，会发现其中并没有发布订阅模式；刚开始发布订阅模式只是观察者模式的一个别称，但是经过时间的沉淀，他改进了观察者模式的缺点，渐渐地开始独立于观察者模式；我们也来看一下它的一个定义： 发布订阅模式是基于一个事件（主题）通道，希望接收通知的对象Subscriber通过自定义事件订阅主题，被激活事件的对象Publisher通过发布主题事件的方式通知各个订阅该主题的Subscriber对象。 我们看到定义里面也涉及到了两种对象：接收通知的对象（Subscriber）和被激活事件的对象（Publisher）；被激活事件对象（Publisher）我们可以类比为观察者模式中的目标对象，来发布事件通知，而接收通知对象（Subscriber）可以类比为观察者对象，订阅各种通知。 发布订阅模式和观察者模式的不同在于，增加了第三方即事件中心；目标对象状态的改变并直接通知观察者，而是通过第三方的事件中心来派发通知。 为了加深理解，我们以生活中的情形为例；比如我们订阅报纸杂志等，一般不会直接跑到报社去订阅，而是通过一个平台，比如街边的报亭或者邮局也可以订阅；而报纸杂志也会有多种，比如晨报晚报日报等等；我们订阅报纸后报社出版后会通过平台来给我们投递，通过邮局邮寄或者自取等等，那么这里就涉及到了报社、订阅者和第三方平台三个对象，我们通过代码来模拟三者的动作： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 报社class Publisher &#123; constructor(name, channel) &#123; this.name = name; this.channel = channel; &#125; // 注册报纸 addTopic(topicName) &#123; this.channel.addTopic(topicName); &#125; // 推送报纸 publish(topicName) &#123; this.channel.publish(topicName); &#125;&#125;// 订阅者class Subscriber &#123; constructor(name, channel) &#123; this.name = name; this.channel = channel; &#125; //订阅报纸 subscribe(topicName) &#123; this.channel.subscribeTopic(topicName, this); &#125; //取消订阅 unSubscribe(topicName) &#123; this.channel.unSubscribeTopic(topicName, this); &#125; //接收推送 update(topic) &#123; console.log(`$&#123;topic&#125;已经送到$&#123;this.name&#125;家了`); &#125;&#125;// 第三方平台class Channel &#123; constructor() &#123; this.topics = &#123;&#125;; &#125; //报社在平台注册报纸 addTopic(topicName) &#123; this.topics[topicName] = []; &#125; //报社取消注册 removeTopic(topicName) &#123; delete this.topics[topicName]; &#125; //订阅者订阅报纸 subscribeTopic(topicName, sub) &#123; if (this.topics[topicName]) &#123; this.topics[topicName].push(sub); &#125; &#125; //订阅者取消订阅 unSubscribeTopic(topicName, sub) &#123; this.topics[topicName].forEach((item, index) =&gt; &#123; if (item === sub) &#123; this.topics[topicName].splice(index, 1); &#125; &#125;); &#125; //平台通知某个报纸下所有订阅者 publish(topicName) &#123; this.topics[topicName].forEach((item) =&gt; &#123; item.update(topicName); &#125;); &#125;&#125; 这里的报社我们可以理解为发布者（Publisher）的角色，订报纸的读者理解为订阅者（Subscriber），第三方平台就是事件中心；报社在平台上注册某一类型的报纸，然后读者就可以在平台订阅这种报纸；三个类准备好了，我们来看下他们彼此如何进行联系： 1234567891011121314151617181920212223242526272829var channel = new Channel();var pub1 = new Publisher(&quot;报社1&quot;, channel);var pub2 = new Publisher(&quot;报社2&quot;, channel);pub1.addTopic(&quot;晨报1&quot;);pub1.addTopic(&quot;晚报1&quot;);pub2.addTopic(&quot;晨报2&quot;);var sub1 = new Subscriber(&quot;小明&quot;, channel);var sub2 = new Subscriber(&quot;小红&quot;, channel);var sub3 = new Subscriber(&quot;小张&quot;, channel);sub1.subscribe(&quot;晨报1&quot;);sub2.subscribe(&quot;晨报1&quot;);sub2.subscribe(&quot;晨报2&quot;);sub3.subscribe(&quot;晚报1&quot;);sub3.subscribe(&quot;晨报2&quot;);sub3.unSubscribe(&quot;晨报2&quot;);pub1.publish(&quot;晨报1&quot;);pub1.publish(&quot;晚报1&quot;);pub2.publish(&quot;晨报2&quot;);//晨报1已经送到小明家了//晨报1已经送到小红家了//晚报1已经送到小张家了//晨报2已经送到小红家了 由于平台是沟通的桥梁，因此我们先定义了一个调度中心channel，然后分别定义了两个报社pub1、pub2，以及三个读者sub1、sub2和sub3；两家报社在平台注册了晨报1、晚报1和晨报2三种类型的报纸，三个读者各自订阅各家的报纸，也能取消订阅。 我们可以发现在发布者中并没有直接维护订阅者列表，而是注册了一个事件主题，这里的报纸类型相当于一个事件主题；订阅者订阅主题，发布者推送某个主题时，订阅该主题的所有读者都会被通知到；这样就避免了观察者模式无法进行过滤筛选的缺陷。 主要区别 我们通过一张图来形象的描述两种模式的区别。 观察者模式把观察者对象维护在目标对象中的，需要发布消息时直接发消息给观察者。在观察者模式中，目标对象本身是知道观察者存在的。 而发布/订阅模式中，发布者并不维护订阅者，也不知道订阅者的存在，所以也不会直接通知订阅者，而是通知调度中心，由调度中心通知订阅者。 Vue中的发布订阅模式 我们在深入学习Object.defineProperty和Proxy中介绍过，Vue2.0响应式是通过Object.defineProperty()来处理的，将每个组件data中的数据进行get/set劫持（也就是Reactive化），那么劫持后是如何来通知页面进行更新操作呢？这里就用到了发布订阅模式，我们首先来看下官网是如何介绍的： 每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。 相信看过源码的同学对Watcher和Dep的代码看的是云里雾里，不了解这两个类的作用；我们剔除不相关的代码，对主要代码逐段分析。 1234567891011121314151617181920212223242526//defineReactive部分源码//src\\core\\observer\\index.jsexport function defineReactive ( obj: Object, key: string, val: any, customSetter?: Function) &#123; // 每个data的属性都会有一个dep对象，用来进行收集依赖 const dep = new Dep() Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter () &#123; if (Dep.target) &#123; dep.depend() &#125; return value &#125;, set: function reactiveSetter (newVal) &#123; val = newVal dep.notify() &#125; &#125;)&#125; 我们在初始化data时或者用$set给data新增属性都会给每个属性循环遍历调用defineReactive进行数据劫持；我们看到在每个属性中构造了一个dep对象，并且在属性触发getter和setter时都会调用，它其实是依赖收集和触发更新的一个第三方，相当于发布订阅模式中事件中心的一个角色；而且由于getter/setter函数内对它闭包引用，因此我们在this.num和this.num=1都是调用它下面的函数，因此我们来看下它的实现原理： 1234567891011121314151617181920212223242526272829303132//src\\core\\observer\\dep.jsclass Dep &#123; static target: ?Watcher; id: number; subs: Array&lt;Watcher&gt;; constructor () &#123; this.id = uid++ this.subs = [] &#125; //新增观察者 addSub (sub: Watcher) &#123; this.subs.push(sub) &#125; //移除观察者 removeSub (sub: Watcher) &#123; remove(this.subs, sub) &#125; // 依赖收集 depend () &#123; if (Dep.target) &#123; Dep.target.addDep(this) &#125; &#125; // 通知所有的观察者 notify () &#123; const subs = this.subs.slice() for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125; &#125;&#125;Dep.target = null Dep的全程是Dependency，翻译过来也是依赖、依赖关系的意思，从意思上能看出来是用来做依赖收集的；我们看到Dep下面有一个subs数组，它是一组Watcher的列表，存放的就是我们收集的依赖列表；然后通过addSub和removeSub新增和删除某个依赖，当数据更新时通过notify通知列表中所有的依赖对象；可以发现这些函数和我们的事件中心的代码很相似，不过它不是基于事件主题，而是直接通过一个列表。 Dep源码看完了，下面就来看我们收集的依赖Watcher，也就是订阅者，都做了哪些事情： 1234567891011121314151617//src\\core\\observer\\watcher.jsclass Watcher &#123; constructor ( vm: Component, expOrFn: string | Function, cb: Function, options?: Object ) &#123; this.vm = vm &#125; addDep (dep: Dep) &#123; dep.addSub(this) &#125; //执行数据更新 update () &#123; &#125;&#125; 我们看到Watcher和我们的订阅者代码也很相似，在update中对视图进行更新操作；由于data数据可以传入不同的子组件，而在data中数据更新时，每个子组件中的页面都需要重新更新，因此每一个Vue组件都会在mount阶段都会创建一个Watcher，然后保存在_watcher上： 1234567891011121314//src\\core\\instance\\lifecycle.jsfunction mountComponent ( vm: Component, el: ?Element, hydrating?: boolean): Component &#123; callHook(vm, &#x27;beforeMount&#x27;) let updateComponent = () =&gt; &#123; vm._update(vm._render(), hydrating) &#125; vm._watcher = new Watcher(vm, updateComponent, noop) callHook(vm, &#x27;mounted&#x27;) return vm&#125; 因此Dep和Watcher两者关系如下图： 我们回到Dep的源码中，发现有一个静态属性Dep.target是Watcher，进行依赖收集的时候也是通过Dep.target，那么它是做什么用的呢？让我们继续回到Watcher的构造器： 123456789101112131415161718192021222324252627282930//src\\core\\observer\\dep.jsDep.target = nullconst targetStack = []export function pushTarget (_target: Watcher) &#123; if (Dep.target) targetStack.push(Dep.target) Dep.target = _target&#125;export function popTarget () &#123; Dep.target = targetStack.pop()&#125;//src\\core\\observer\\watcher.jsclass Watcher &#123; constructor ( vm: Component, expOrFn: string | Function, cb: Function, options?: Object ) &#123; this.getter = expOrFn this.get() &#125; get () &#123; pushTarget(this) value = this.getter.call(vm, vm) popTarget() return value &#125;&#125; 在Dep代码中同时维护了一个targetStack，也就是我们常说的堆栈，它遵从着先进后出的原则，我们只能通过pushTarget（压栈）和popTarget（出栈）来对它进行操作，那么它是什么时候需要进行压栈和出栈的操作呢？ 在Watcher的源码中我们发现的原因，由于Water实例是在组件mounted时被构建的，在构建时需要把实例暂存到Dep.target上以便Dep进行依赖收集；如果Dep.target上有其他组件的watcher实例，需要先把其他的watcher实例暂存到targetStack中，然后调用expOrFn函数渲染组件；这里的expOrFn渲染组件时会将data中定义的数据取值，取值的过程就会自动调用Reactive化后的getter函数，因此就把Dep.target上的watcher实例收集到了每个数据的Dep中，收集完成后再把上一个watcher出栈。 总结，经过两者关系的分析，我们发现Vue是一个典型的发布订阅模式，data中的数据就是我们需要观察的目标对象，Dep相当于事件中心，而Watcher则是订阅者。","tags":[{"name":"源码","slug":"SourceCode","permalink":"http://xieyufei.com/tags/SourceCode/"},{"name":"Vue","slug":"Vue","permalink":"http://xieyufei.com/tags/Vue/"},{"name":"设计模式","slug":"DesignPattern","permalink":"http://xieyufei.com/tags/DesignPattern/"}]},{"title":"跟着Element源码学组件化","date":"2021-02-23T04:15:07.000Z","path":"2021/02/23/Front-Element.html","text":"ElementUI作为当前最流行的Vue组件库，以其丰富多样的组件和可配置化程度高吸引着众多的开发者；今天我们就深入它的源码，看一下它内部众多组件究竟是如何来实现的，以便我们在今后的开发中写出通用化程度更高的组件，同时也加深对其组件用法的理解。 老规矩，还是先来看一下官网的slogan： Element，一套为开发者、设计师和产品经理准备的基于Vue 2.0的桌面端组件库 可以看出，Element的使用范围涵盖了大部分的研发人员；产品经理可以用来参考逻辑交互，设计师可以借鉴图标和组件设计，开发者可以使用它来布局页面。 项目结构 我们从github将整个项目clone下来后，来看一下有哪些目录文件： 12345678910111213|-- .github # 存放贡献指南以及issue、PR模板|-- build # 存放打包工具的配置文件|-- examples # 存放组件示例|-- packages # 存放组件源码，也是我们分析的主要目录|-- src # 存放入口文件以及各种工具文件 |-- directives # 滚轮优化和避免重复点击 |-- locale # 国际化功能 |-- mixins # 混入实例 |-- transition # 过度效果 |-- utils # 工具文件|-- test # 存放单元测试文件|-- types # 存放typescript声明文件|-- components.json # 完整组件列表 因此packages和src目录是我们需要关注的两个重要的目录；大致了解了目录结构后，下一个需要关注的就是package.json文件，这个文件包括了一些项目描述、项目依赖以及脚本命令等；有时候我们第一眼找不到项目的入口文件，就可以从这里来找。 首先是&quot;main&quot;:&quot;lib/element-ui.common.js&quot;，main字段定义了npm包的入口文件，我们在项目中require(&quot;element-ui&quot;)，其实就是引用了element-ui.common.js文件；然后我们来看一下有哪些脚本命令，这里引用了重要的几个命令： 123456789&#123; &quot;scripts&quot;: &#123; &quot;build:file&quot;: &quot;node build/bin/iconInit.js &amp; node build/bin/i18n.js&quot;, &quot;build:theme&quot;: &quot;gulp build --gulpfile packages/theme-chalk/gulpfile.js&quot;, &quot;build:utils&quot;: &quot;cross-env BABEL_ENV=utils babel src --out-dir lib --ignore src/index.js&quot;, &quot;build:umd&quot;: &quot;node build/bin/build-locale.js&quot;, &quot;dist&quot;: &quot;webpack --config build/webpack.conf.js &amp;&amp; webpack --config build/webpack.common.js &amp;&amp; webpack --config build/webpack.component.js&quot; &#125;&#125; 可以看出来前面的几个build命令是用来构建一些工具、样式的，主要是dist命令，通过webpack进行打包，还进行了三次打包，我们分别来看下这三次打包分别是打包什么文件的；首先我们来看下前两个配置文件webpack.conf.js和webpack.common.js，这里只截取配置文件的部分代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//build/webpack.conf.jsmodule.exports = &#123; mode: &#x27;production&#x27;, entry: &#123; app: [&#x27;./src/index.js&#x27;] &#125;, output: &#123; path: path.resolve(process.cwd(), &#x27;./lib&#x27;), publicPath: &#x27;/dist/&#x27;, filename: &#x27;index.js&#x27;, chunkFilename: &#x27;[id].js&#x27;, libraryTarget: &#x27;umd&#x27;, libraryExport: &#x27;default&#x27;, library: &#x27;ELEMENT&#x27;, umdNamedDefine: true, globalObject: &#x27;typeof self !== \\&#x27;undefined\\&#x27; ? self : this&#x27; &#125;, optimization: &#123; minimizer: [ new TerserPlugin(&#123; terserOptions: &#123; output: &#123; comments: false &#125; &#125; &#125;) ] &#125;,&#125;//build/webpack.common.jsmodule.exports = &#123; mode: &#x27;production&#x27;, entry: &#123; app: [&#x27;./src/index.js&#x27;] &#125;, output: &#123; path: path.resolve(process.cwd(), &#x27;./lib&#x27;), publicPath: &#x27;/dist/&#x27;, filename: &#x27;element-ui.common.js&#x27;, chunkFilename: &#x27;[id].js&#x27;, libraryExport: &#x27;default&#x27;, library: &#x27;ELEMENT&#x27;, libraryTarget: &#x27;commonjs2&#x27; &#125;, optimization: &#123; minimize: false &#125;,&#125; 发现两个文件的入口都是src/index.js，不同的是webpack.conf.js打包的是umd规范，而且通过minimizer进行了压缩；而webpack.common.js打包的是commonjs规范，并且没有进行压缩；通过两种规范来打包的主要原因也是因为Element安装方式的不同，umd规范主要针对CDN引入的方式，在页面上引入js和css： 1234&lt;!-- 引入样式 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;&gt;&lt;!-- 引入组件库 --&gt;&lt;script src=&quot;https://unpkg.com/element-ui/lib/index.js&quot;&gt;&lt;/script&gt; 而webpack.common.js打包出来的element-ui.common.js则是针对npm的引入方式： 12import ElementUI from &#x27;element-ui&#x27;;import &#x27;element-ui/lib/theme-chalk/index.css&#x27;; 那么最后一个build/webpack.component.js也不难猜到了，是为了在npm引入时，只引入需要的部分组件，而不对整体进行打包： 123456789101112131415const Components = require(&#x27;../components.json&#x27;);module.exports = &#123; mode: &#x27;production&#x27;, entry: Components, output: &#123; path: path.resolve(process.cwd(), &#x27;./lib&#x27;), publicPath: &#x27;/dist/&#x27;, filename: &#x27;[name].js&#x27;, chunkFilename: &#x27;[id].js&#x27;, libraryTarget: &#x27;commonjs2&#x27; &#125;, optimization: &#123; minimize: false &#125;,&#125; 这里components.json就是每个组件所在的入口文件。 入口文件 我们在上面一节通过查看webpack的配置文件找到了入口文件/src/index.js，那么我们就来看一下Element在入口是如何来注册这么多组件的。 123456789101112131415161718192021222324252627282930313233343536373839404142//截取了部分组件import Button from &#x27;../packages/button/index.js&#x27;;import Input from &#x27;../packages/input/index.js&#x27;;import MessageBox from &#x27;../packages/message-box/index.js&#x27;;import Loading from &#x27;../packages/loading/index.js&#x27;;import InfiniteScroll from &#x27;../packages/infinite-scroll/index.js&#x27;;import Notification from &#x27;../packages/notification/index.js&#x27;;import Message from &#x27;../packages/message/index.js&#x27;;const components = [ Button, Input]const install = function(Vue, opts = &#123;&#125;) &#123; components.forEach(component =&gt; &#123; Vue.component(component.name, component); &#125;); Vue.use(InfiniteScroll); Vue.use(Loading.directive); Vue.prototype.$ELEMENT = &#123; size: opts.size || &#x27;&#x27;, zIndex: opts.zIndex || 2000 &#125;; Vue.prototype.$loading = Loading.service; Vue.prototype.$msgbox = MessageBox; Vue.prototype.$alert = MessageBox.alert; Vue.prototype.$confirm = MessageBox.confirm; Vue.prototype.$prompt = MessageBox.prompt; Vue.prototype.$notify = Notification; Vue.prototype.$message = Message;&#125;;//浏览器环境自动调用注册组件if (typeof window !== &#x27;undefined&#x27; &amp;&amp; window.Vue) &#123; install(window.Vue);&#125;export default &#123; install, Button, Input, MessageBox, Notification&#125; 这里Element暴露出去一个install函数，这是因为Element本身就是一个插件，我们在调用Vue.use(ElementUI)注册时，本质上就是调用这个install函数；那么Vue.use是如何注册插件的呢？ Vue.use接收一个对象，这个对象必须具有install方法，Vue.use函数内部会调用参数的install方法。 如果插件没有被注册过，那么注册成功之后会给插件添加一个installed的属性值为true。Vue.use方法内部会检测插件的installed属性，从而避免重复注册插件。 插件的install方法将接收两个参数，第一个是参数是Vue，第二个参数是配置项options。 在install方法内部可以添加全局方法或者属性、全局指令、mixin混入、添加实例方法、使用Vue.component()注册组件等。 在Element的install函数中，我们发现从传入的options参数中取出size和zIndex，存到Vue.prototype.$ELEMENT全局配置中，这样在组件中我们就可以获取size和zIndex，根据size进行不同组件尺寸的展示。 在Element文档全局配置中，也指出了可以在引入Element时覆写全局配置： 12import Element from &#x27;element-ui&#x27;;Vue.use(Element, &#123; size: &#x27;small&#x27;, zIndex: 3000 &#125;); 组件 在上面install函数中，我们发现Element注册插件有三种方式，第一种是像Button和Input，在数组循环遍历，通过Vue.component中注册成全局组件，就可以在页面直接引用；第二种是InfiniteScroll和Loading，在全局注册指令，通过v-infinite-scroll和v-loading等指令式来调用；第三种是MessageBox、Notification和Message，在全局Vue.prototype添加了方法，可以通过函数进行调用。 全局组件Container和Header 首先我们从几个简单的布局容器组件开始，我们简单看一下demo回顾一下这几个组件的使用方法： 12345678&lt;el-container&gt; &lt;el-aside width=&quot;200px&quot;&gt;Aside&lt;/el-aside&gt; &lt;el-container&gt; &lt;el-header&gt;Header&lt;/el-header&gt; &lt;el-main&gt;Main&lt;/el-main&gt; &lt;el-footer&gt;Footer&lt;/el-footer&gt; &lt;/el-container&gt;&lt;/el-container&gt; 我们先来看下el-header的源码，实现逻辑也很简单，通过slot插槽将元素进行渲染；（el-footer和el-aside也是同样的，这里不再展示了）： 123456789101112131415161718//packages/header/src/main.vue&lt;template&gt; &lt;header class=&quot;el-header&quot; :style=&quot;&#123; height &#125;&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/header&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &#x27;ElHeader&#x27;, componentName: &#x27;ElHeader&#x27;, props: &#123; height: &#123; type: String, default: &#x27;60px&#x27; &#125; &#125; &#125;;&lt;/script&gt; 这里传参的props和文档中给出也是一致的，el-header、el-footer和el-aside三个组件都是类似，都传width或者height等一些宽高的字符串数值。 我们重点来看下el-container的代码，接收一个参数direction，可选值horizontal/vertical，不过它的默认值比较特殊，文档中是这么说的： 子元素中有el-header或el-footer时为vertical，否则为horizontal 了解了它的传参逻辑，我们来看下源码是如何来实现的： 123456789101112131415161718192021222324252627282930//packages/container/src/main.vue&lt;template&gt; &lt;section class=&quot;el-container&quot; :class=&quot;&#123; &#x27;is-vertical&#x27;: isVertical &#125;&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/section&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;ElContainer&quot;, componentName: &quot;ElContainer&quot;, props: &#123; direction: String, &#125;, computed: &#123; isVertical() &#123; if (this.direction === &quot;vertical&quot;) &#123; return true; &#125; else if (this.direction === &quot;horizontal&quot;) &#123; return false; &#125; return this.$slots &amp;&amp; this.$slots.default ? this.$slots.default.some((vnode) =&gt; &#123; const tag = vnode.componentOptions &amp;&amp; vnode.componentOptions.tag; return tag === &quot;el-header&quot; || tag === &quot;el-footer&quot;; &#125;) : false; &#125;, &#125;,&#125;;&lt;/script&gt; 代码中比较难理解的是isVertical中的逻辑判断，我们一段一段来看；this.$slots是用来获取组件中所有的插槽组件，和this.$refs有点像，都是对象，用来存放多个插槽对象；而this.$slots.default是获取默认的那个插槽，它是一个数组，存放是插槽中的节点；然后some函数中的判断就很好理解了，用来判断数组中的vnode节点的是否有el-header或者el-footer两个标签，有的话就返回true，就会渲染is-vertical类名。 Row和Col 我们再来看两个布局组件Row和Col，用于创建栅格布局，我们还是简单的看一下这两个组件的用法： 1234567891011121314&lt;el-row :gutter=&quot;20&quot;&gt; &lt;el-col :span=&quot;6&quot;&gt; &lt;div class=&quot;grid-content&quot;&gt;&lt;/div&gt; &lt;/el-col&gt; &lt;el-col :span=&quot;6&quot;&gt; &lt;div class=&quot;grid-content&quot;&gt;&lt;/div&gt; &lt;/el-col&gt; &lt;el-col :span=&quot;6&quot;&gt; &lt;div class=&quot;grid-conten&quot;&gt;&lt;/div&gt; &lt;/el-col&gt; &lt;el-col :span=&quot;6&quot;&gt; &lt;div class=&quot;grid-content&quot;&gt;&lt;/div&gt; &lt;/el-col&gt;&lt;/el-row&gt; 看用法这两个组件也是在页面通过插槽的方式渲染页面，不过当我们来看源码会发现它的插槽和上面组件的插槽用法还不一样： 1234567891011121314151617181920212223242526272829303132333435363738394041//packages/row/src/row.jsexport default &#123; name: &#x27;ElRow&#x27;, props: &#123; tag: &#123; type: String, default: &#x27;div&#x27; &#125;, gutter: Number, type: String, justify: &#123; type: String, default: &#x27;start&#x27; &#125;, align: &#123; type: String, default: &#x27;top&#x27; &#125; &#125;, computed: &#123; style() &#123; const ret = &#123;&#125;; if (this.gutter) &#123; ret.marginLeft = `-$&#123;this.gutter / 2&#125;px`; ret.marginRight = ret.marginLeft; &#125; return ret; &#125; &#125;, render(h) &#123; return h(this.tag, &#123; class: [ &#x27;el-row&#x27;, this.justify !== &#x27;start&#x27; ? `is-justify-$&#123;this.justify&#125;` : &#x27;&#x27;, this.align !== &#x27;top&#x27; ? `is-align-$&#123;this.align&#125;` : &#x27;&#x27;, &#123; &#x27;el-row--flex&#x27;: this.type === &#x27;flex&#x27; &#125; ], style: this.style &#125;, this.$slots.default); &#125;&#125;; 我们发现el-row插件没有模板template渲染，而是通过render渲染函数来渲染页面的；但是这里为什么需要用到渲染函数呢？这里和el-row的参数有关，在传参列表中我们可以看到参数中有一个tag自定义元素标签，也就是定义最外层的标签类型；如果通过模板渲染的话肯定需要多个if判断，比较繁琐，但是通过渲染函数，就直接渲染标签了；渲染函数有关使用方法可以查看官网文档。 Col组件和Row类似，都是通过render函数进行渲染，不过Col组件获取父级组件Row的参数方式值的我们来学习一下，这里贴上部分代码： 12345678910111213141516171819202122232425262728//packages/col/src/col.jsexport default &#123; name: &quot;ElCol&quot;, computed: &#123; gutter() &#123; let parent = this.$parent; while (parent &amp;&amp; parent.$options.componentName !== &quot;ElRow&quot;) &#123; parent = parent.$parent; &#125; return parent ? parent.gutter : 0; &#125;, &#125;, render(h) &#123; let classList = []; let style = &#123;&#125;; if (this.gutter) &#123; style.paddingLeft = this.gutter / 2 + &quot;px&quot;; style.paddingRight = style.paddingLeft; &#125; return h(this.tag, &#123; class: [&quot;el-col&quot;, classList], style, &#125;, this.$slots.default ); &#125;,&#125;; 由于Row组件传入的gutter表示栅格间隔，因此Rol组件也需设置一定的padding，但是怎么能从父组件获取参数呢？Col通过一个while循环，不断向上获取父组件并且判断组件名称。 Form和Form-Item 看完布局组件，我们来看一下表单组件，表单最顶层的是Form和Form-Item组件，我们可以通过向Form传入参数rules来校验表单中的Input输入框或者其他组件的值，首先来看下Form的源码，由于篇幅问题这里只贴出部分源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//packages/form/src/form.vue&lt;template&gt; &lt;form class=&quot;el-form&quot; :class=&quot;[ labelPosition ? &#x27;el-form--label-&#x27; + labelPosition : &#x27;&#x27;, &#123; &#x27;el-form--inline&#x27;: inline &#125; ]&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/form&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &#x27;ElForm&#x27;, provide() &#123; return &#123; elForm: this &#125;; &#125;, watch: &#123; rules() &#123; // remove then add event listeners on form-item after form rules change this.fields.forEach(field =&gt; &#123; field.removeValidateEvents(); field.addValidateEvents(); &#125;); if (this.validateOnRuleChange) &#123; this.validate(() =&gt; &#123;&#125;); &#125; &#125; &#125;, data() &#123; return &#123; fields: [], potentialLabelWidthArr: [] // use this array to calculate auto width &#125;; &#125;, created() &#123; this.$on(&#x27;el.form.addField&#x27;, (field) =&gt; &#123; if (field) &#123; this.fields.push(field); &#125; &#125;); /* istanbul ignore next */ this.$on(&#x27;el.form.removeField&#x27;, (field) =&gt; &#123; if (field.prop) &#123; this.fields.splice(this.fields.indexOf(field), 1); &#125; &#125;); &#125;, methods: &#123; validate(callback) &#123; let promise; if (typeof callback !== &#x27;function&#x27; &amp;&amp; window.Promise) &#123; promise = new window.Promise((resolve, reject) =&gt; &#123; callback = function(valid) &#123; valid ? resolve(valid) : reject(valid); &#125;; &#125;); &#125; let valid = true; let count = 0; let invalidFields = &#123;&#125;; this.fields.forEach(field =&gt; &#123; field.validate(&#x27;&#x27;, (message, field) =&gt; &#123; if (message) &#123; valid = false; &#125; invalidFields = objectAssign(&#123;&#125;, invalidFields, field); if (typeof callback === &#x27;function&#x27; &amp;&amp; ++count === this.fields.length) &#123; callback(valid, invalidFields); &#125; &#125;); &#125;); if (promise) &#123; return promise; &#125; &#125;, &#125; &#125;;&lt;/script&gt; 我们看到Form的页面结构非常简单，只有一个form标签，而且props也只用到了labelPosition和inline两个，其他的属性会在Form-Item中用到；Form中还用到了一个provide函数，在Vue中组件通信方式中，我们介绍过provide/inject，主要是用来跨多层组件通信的，在后面组件的介绍中，我们会取出来用到。 重点我们看下常用的表单校验函数validate是如何来实现的；在created中，我们看到在注册了两个事件：addField和removeField，这是用来在所有的子组件Form-Item初始化时调用，进行一个收集存储，存到fields数组中，那么这里为什么不用$children呢？因为页面结构的不确定，Form下一级子组件不一定就是Form-Item，如果进行循环的话比较费时费力，而且对子组件管理操作也比较频繁，因此通过事件的方式；收集所有的Form-Item后，我们就可以对每个表单元素遍历并且校验。 接着就是Form-Item，来看下它的源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154//packages/form/src/form-item.vue&lt;template&gt; &lt;div class=&quot;el-form-item&quot; :class=&quot;[&#123; &#x27;el-form-item--feedback&#x27;: elForm &amp;&amp; elForm.statusIcon, &#x27;is-error&#x27;: validateState === &#x27;error&#x27;, &#x27;is-validating&#x27;: validateState === &#x27;validating&#x27;, &#x27;is-success&#x27;: validateState === &#x27;success&#x27;, &#x27;is-required&#x27;: isRequired || required, &#x27;is-no-asterisk&#x27;: elForm &amp;&amp; elForm.hideRequiredAsterisk &#125;, sizeClass ? &#x27;el-form-item--&#x27; + sizeClass : &#x27;&#x27; ]&quot;&gt; &lt;label-wrap :is-auto-width=&quot;labelStyle &amp;&amp; labelStyle.width === &#x27;auto&#x27;&quot; :update-all=&quot;form.labelWidth === &#x27;auto&#x27;&quot;&gt; &lt;label :for=&quot;labelFor&quot; class=&quot;el-form-item__label&quot; :style=&quot;labelStyle&quot; v-if=&quot;label || $slots.label&quot;&gt; &lt;slot name=&quot;label&quot;&gt;&#123;&#123;label + form.labelSuffix&#125;&#125;&lt;/slot&gt; &lt;/label&gt; &lt;/label-wrap&gt; &lt;div class=&quot;el-form-item__content&quot; :style=&quot;contentStyle&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;transition name=&quot;el-zoom-in-top&quot;&gt; &lt;slot v-if=&quot;validateState === &#x27;error&#x27; &amp;&amp; showMessage &amp;&amp; form.showMessage&quot; name=&quot;error&quot; :error=&quot;validateMessage&quot;&gt; &lt;div class=&quot;el-form-item__error&quot; :class=&quot;&#123; &#x27;el-form-item__error--inline&#x27;: typeof inlineMessage === &#x27;boolean&#x27; ? inlineMessage : (elForm &amp;&amp; elForm.inlineMessage || false) &#125;&quot; &gt; &#123;&#123;validateMessage&#125;&#125; &lt;/div&gt; &lt;/slot&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import AsyncValidator from &#x27;async-validator&#x27;; import emitter from &#x27;element-ui/src/mixins/emitter&#x27;; import objectAssign from &#x27;element-ui/src/utils/merge&#x27;; import &#123; noop, getPropByPath &#125; from &#x27;element-ui/src/utils/util&#x27;; export default &#123; name: &#x27;ElFormItem&#x27;, componentName: &#x27;ElFormItem&#x27;, mixins: [emitter], provide() &#123; return &#123; elFormItem: this &#125;; &#125;, inject: [&#x27;elForm&#x27;], computed: &#123; fieldValue() &#123; const model = this.form.model; if (!model || !this.prop) &#123; return; &#125; let path = this.prop; if (path.indexOf(&#x27;:&#x27;) !== -1) &#123; path = path.replace(/:/, &#x27;.&#x27;); &#125; return getPropByPath(model, path, true).v; &#125;, _formSize() &#123; return this.elForm.size; &#125;, elFormItemSize() &#123; return this.size || this._formSize; &#125;, sizeClass() &#123; return this.elFormItemSize || (this.$ELEMENT || &#123;&#125;).size; &#125; &#125;, data() &#123; return &#123; validateState: &#x27;&#x27;, validateMessage: &#x27;&#x27;, validateDisabled: false, validator: &#123;&#125;, isNested: false, computedLabelWidth: &#x27;&#x27; &#125;; &#125;, methods: &#123; validate(trigger, callback = noop) &#123; this.validateDisabled = false; const rules = this.getFilteredRule(trigger); if ((!rules || rules.length === 0) &amp;&amp; this.required === undefined) &#123; callback(); return true; &#125; this.validateState = &#x27;validating&#x27;; const descriptor = &#123;&#125;; if (rules &amp;&amp; rules.length &gt; 0) &#123; rules.forEach(rule =&gt; &#123; delete rule.trigger; &#125;); &#125; descriptor[this.prop] = rules; const validator = new AsyncValidator(descriptor); const model = &#123;&#125;; model[this.prop] = this.fieldValue; validator.validate(model, &#123; firstFields: true &#125;, (errors, invalidFields) =&gt; &#123; this.validateState = !errors ? &#x27;success&#x27; : &#x27;error&#x27;; this.validateMessage = errors ? errors[0].message : &#x27;&#x27;; callback(this.validateMessage, invalidFields); this.elForm &amp;&amp; this.elForm.$emit(&#x27;validate&#x27;, this.prop, !errors, this.validateMessage || null); &#125;); &#125;, getRules() &#123; let formRules = this.form.rules; const selfRules = this.rules; const requiredRule = this.required !== undefined ? &#123; required: !!this.required &#125; : []; const prop = getPropByPath(formRules, this.prop || &#x27;&#x27;); formRules = formRules ? (prop.o[this.prop || &#x27;&#x27;] || prop.v) : []; return [].concat(selfRules || formRules || []).concat(requiredRule); &#125;, onFieldBlur() &#123; this.validate(&#x27;blur&#x27;); &#125;, onFieldChange() &#123; if (this.validateDisabled) &#123; this.validateDisabled = false; return; &#125; this.validate(&#x27;change&#x27;); &#125;, addValidateEvents() &#123; const rules = this.getRules(); if (rules.length || this.required !== undefined) &#123; this.$on(&#x27;el.form.blur&#x27;, this.onFieldBlur); this.$on(&#x27;el.form.change&#x27;, this.onFieldChange); &#125; &#125;, &#125;, mounted() &#123; if (this.prop) &#123; this.dispatch(&#x27;ElForm&#x27;, &#x27;el.form.addField&#x27;, [this]); this.addValidateEvents(); &#125; &#125;, beforeDestroy() &#123; this.dispatch(&#x27;ElForm&#x27;, &#x27;el.form.removeField&#x27;, [this]); &#125; &#125;;&lt;/script&gt; 我们看到这里还是用了provide/inject来处理跨组件的数据通信，将Form引入，用到了Form的几个props值来渲染类名，同时将本身inject向下传递。在sizeClass中我们看到获取size也是向上渐进获取的一个过程，首先是Form-Item本身的size，然后是Form的size，最后才是我们挂载在全局$ELEMENT的size，我们去查看其他组件例如Input、Button、Radio，都是通过这种方式来渲染size。 在Form-Item生命周期函数中我们也看到了，通过触发了Form的addField和removeField来进行表单的收集，不过通过一个dispatch函数，这个函数既不是vue官网中的，在methods中也没有进行定义，那么它是如何来触发的呢？我们仔细看代码，会发现一个mixins:[emitter]数组，原来Form-Item是通过mixins将一些公共的函数提取出来，那么我们来看一下emitter里面是做了哪些操作： 123456789101112131415161718192021222324252627282930function broadcast(componentName, eventName, params) &#123; this.$children.forEach(child =&gt; &#123; var name = child.$options.componentName; if (name === componentName) &#123; child.$emit.apply(child, [eventName].concat(params)); &#125; else &#123; broadcast.apply(child, [componentName, eventName].concat([params])); &#125; &#125;);&#125;export default &#123; methods: &#123; dispatch(componentName, eventName, params) &#123; var parent = this.$parent || this.$root; var name = parent.$options.componentName; while (parent &amp;&amp; (!name || name !== componentName)) &#123; parent = parent.$parent; if (parent) &#123; name = parent.$options.componentName; &#125; &#125; if (parent) &#123; parent.$emit.apply(parent, [eventName].concat(params)); &#125; &#125;, broadcast(componentName, eventName, params) &#123; broadcast.call(this, componentName, eventName, params); &#125; &#125;&#125;; 我们看到dispatch是用来向父组件派发事件，也是通过while向上遍历循环，而broadcast是向子组件广播事件的。 Button和Button-Group Button是我们常用的组件，我们来看下它的源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//packages/button/src/button.vue&lt;template&gt; &lt;button class=&quot;el-button&quot; @click=&quot;handleClick&quot; :disabled=&quot;buttonDisabled || loading&quot; :autofocus=&quot;autofocus&quot; :type=&quot;nativeType&quot; :class=&quot;[ type ? &#x27;el-button--&#x27; + type : &#x27;&#x27;, buttonSize ? &#x27;el-button--&#x27; + buttonSize : &#x27;&#x27;, &#123; &#x27;is-disabled&#x27;: buttonDisabled, &#x27;is-loading&#x27;: loading, &#x27;is-plain&#x27;: plain, &#x27;is-round&#x27;: round, &#x27;is-circle&#x27;: circle &#125; ]&quot; &gt; &lt;i class=&quot;el-icon-loading&quot; v-if=&quot;loading&quot;&gt;&lt;/i&gt; &lt;i :class=&quot;icon&quot; v-if=&quot;icon &amp;&amp; !loading&quot;&gt;&lt;/i&gt; &lt;span v-if=&quot;$slots.default&quot;&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/span&gt; &lt;/button&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &#x27;ElButton&#x27;, inject: &#123; elForm: &#123; default: &#x27;&#x27; &#125;, elFormItem: &#123; default: &#x27;&#x27; &#125; &#125;, props: &#123; type: &#123; type: String, default: &#x27;default&#x27; &#125;, size: String, icon: &#123; type: String, default: &#x27;&#x27; &#125;, nativeType: &#123; type: String, default: &#x27;button&#x27; &#125;, loading: Boolean, disabled: Boolean, plain: Boolean, autofocus: Boolean, round: Boolean, circle: Boolean &#125;, computed: &#123; _elFormItemSize() &#123; return (this.elFormItem || &#123;&#125;).elFormItemSize; &#125;, buttonSize() &#123; return this.size || this._elFormItemSize || (this.$ELEMENT || &#123;&#125;).size; &#125;, buttonDisabled() &#123; return this.disabled || (this.elForm || &#123;&#125;).disabled; &#125; &#125;, methods: &#123; handleClick(evt) &#123; this.$emit(&#x27;click&#x27;, evt); &#125; &#125; &#125;;&lt;/script&gt; 我们看到Button逻辑相较于上面的组件很简单，通过computed计算了buttonSize和buttonDisabled进行类名渲染，同时依赖了注入的elForm和elFormItem中的数据；在点击时触发了click事件；我们还可以通过Button-Group将多个按钮进行嵌套，来看下它的源码： 1234567891011//packages/button/src/button-group.vue&lt;template&gt; &lt;div class=&quot;el-button-group&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &#x27;ElButtonGroup&#x27; &#125;;&lt;/script&gt; 它的代码更简单，只用了一个slot嵌套了所有的Button。 指令式组件 指令式组件通过Vue.directive(name, opt)来注册，name就是我们要注册的指令名称，而opt是一个对象，包含了5个钩子函数，我们可以根据需要只写其中的几个函数： 123456789101112Vue.directive(&quot;demo&quot;, &#123; //只调用一次，指令第一次绑定到元素时调用 bind:function(el,binding,vnode)&#123; &#125;, //被绑定元素插入父节点时调用 inserted:function(el,binding,vnode)&#123; &#125;, //所在组件的 VNode 更新时调用 update:function(el,binding,vnode)&#123; &#125;, //指令所在组件的 VNode 及其子 VNode 全部更新后调用 componentUpdated:function(el,binding,vnode)&#123; &#125;, //只调用一次，指令与元素解绑时调用。 unbind:function(el,binding,vnode)&#123; &#125;,&#125;) 每个钩子函数都有三个回调参数，el表示了指令所绑定的元素，可以用来直接DOM操作；而binding就是我们的绑定信息了，它是一个对象，包含以下属性： name：指令名，不包括v-前缀。 value：指令的绑定值，比如v-demo=”num”，邦定值为num值，2。 expression：字符串形式的指令表达式，比如v-demo=”num”，表达式为num。 modifiers：一个包含修饰符的对象，比如v-demo.foo.bar修饰符对象为 { foo: true, bar: true } rawName：完整的指令修饰 InfiniteScroll InfiniteScroll无限滚动组件的用法也很简单，在我们想要滚动加载的列表上加上v-infinite-scroll，赋值自定义加载的函数，在列表滚动到底部时就会自动触发函数，我们来看一个官方的Demo： 12345678910111213141516171819&lt;template&gt; &lt;ul class=&quot;infinite-list&quot; v-infinite-scroll=&quot;load&quot; style=&quot;overflow:auto&quot;&gt; &lt;li v-for=&quot;i in count&quot; :key=&quot;i&quot; class=&quot;infinite-list-item&quot;&gt;&#123;&#123; i &#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; count: 0, &#125; &#125;, methods: &#123; load() &#123; this.count += 2; &#125;, &#125;&#125;&lt;/script&gt; 在ul滚动到最底部时，触发load函数，加载更多的数据；因此这个指令的实现原理也很简单，就是监听容器滚动，滚动到底部时进行函数调用，我们来看下具体是怎么来实现的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import throttle from &#x27;throttle-debounce/debounce&#x27;;import &#123; getScrollContainer&#125; from &#x27;element-ui/src/utils/dom&#x27;;const attributes = &#123; delay: &#123; type: Number, default: 200 &#125;, distance: &#123; type: Number, default: 0 &#125;, disabled: &#123; type: Boolean, default: false &#125;, immediate: &#123; type: Boolean, default: true &#125;&#125;;const getScrollOptions = (el, vm) =&gt; &#123; if (!isHtmlElement(el)) return &#123;&#125;; return entries(attributes).reduce((map, [key, option]) =&gt; &#123; const &#123; type, default: defaultValue &#125; = option; let value = el.getAttribute(`infinite-scroll-$&#123;key&#125;`); value = isUndefined(vm[value]) ? value : vm[value]; switch (type) &#123; case Number: value = Number(value); value = Number.isNaN(value) ? defaultValue : value; break; case Boolean: value = isDefined(value) ? value === &#x27;false&#x27; ? false : Boolean(value) : defaultValue; break; default: value = type(value); &#125; map[key] = value; return map; &#125;, &#123;&#125;);&#125;;const handleScroll = function(cb) &#123; const &#123; el, vm, container, observer &#125; = this[scope]; const &#123; distance, disabled &#125; = getScrollOptions(el, vm); if (disabled) return; const containerInfo = container.getBoundingClientRect(); if (!containerInfo.width &amp;&amp; !containerInfo.height) return; let shouldTrigger = false; if (container === el) &#123; const scrollBottom = container.scrollTop + getClientHeight(container); shouldTrigger = container.scrollHeight - scrollBottom &lt;= distance; &#125; else &#123; const heightBelowTop = getOffsetHeight(el) + getElementTop(el) - getElementTop(container); const offsetHeight = getOffsetHeight(container); const borderBottom = Number.parseFloat(getStyleComputedProperty(container, &#x27;borderBottomWidth&#x27;)); shouldTrigger = heightBelowTop - offsetHeight + borderBottom &lt;= distance; &#125; if (shouldTrigger &amp;&amp; isFunction(cb)) &#123; cb.call(vm); &#125; else if (observer) &#123; observer.disconnect(); this[scope].observer = null; &#125;&#125;;export default &#123; name: &#x27;InfiniteScroll&#x27;, inserted(el, binding, vnode) &#123; const cb = binding.value; const container = getScrollContainer(el, true); const &#123; delay, immediate &#125; = getScrollOptions(el, vm); const onScroll = throttle(delay, handleScroll.bind(el, cb)); if (container) &#123; container.addEventListener(&#x27;scroll&#x27;, onScroll); if (immediate) &#123; const observer = el[scope].observer = new MutationObserver(onScroll); observer.observe(container, &#123; childList: true, subtree: true &#125;); onScroll(); &#125; &#125; &#125;, unbind(el) &#123; const &#123; container, onScroll &#125; = el[scope]; if (container) &#123; container.removeEventListener(&#x27;scroll&#x27;, onScroll); &#125; &#125;&#125;; 在inserted函数中逻辑也很简单，首先cb就是我们自定义的回调函数，用来触发；通过getScrollContainer判断我们的el是否是滚动容器，然后将handleScroll处理滚动逻辑的函数用节流函数throttle进行封装成onScroll，绑定到容器的滚动事件上去。 我们在文档中还看到有四个参数，都是以infinite-scroll-开头的，用来控制触发加载函数的时间；在源码中我们看到它是通过getScrollOptions函数来进行获取，定义了一个对象用来存储这四个参数的名称、类型和默认值，用Object.keys变成数组后再通过reduce函数处理变成map对象返回。 函数调用组件 函数组件调用后会将组件插入到body或者其他节点中去，就不能够通过Vue.component注册到全局组件；而是通过Vue.extend创建一个子类构造器，参数是包含组件选项的对象，构造器实例化后通过$mount挂载到页面元素上去。 12345678910var MyMessage = Vue.extend(&#123; template: &#x27;&lt;div&gt;number:&#123;&#123;number&#125;&#125;&lt;/div&gt;&#x27;, data() &#123; return &#123; number: 1 &#125; &#125;&#125;)let instance = new MyMessage()instance.$mount(&#x27;#components&#x27;) 或者实例化后通过$mount获取到DOM结构，然后挂载到body上： 123let instance = new MyMessage()instance.$mount()document.body.appendChild(instance.$el) Message Message组件在入口文件中就挂载到全局变量$message上，然后通过this.$message()来进行调用，还能通过this.$message.error()的方式来调用，因此我们猜测Message肯定是一个函数，在这个函数上面还挂载了success、error等函数来复用Message函数本身；我们来看下Message源码（部分）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//packages/message/src/main.jsimport Main from &#x27;./main.vue&#x27;;import &#123; isVNode &#125; from &#x27;element-ui/src/utils/vdom&#x27;;let MessageConstructor = Vue.extend(Main);let instance;let instances = [];let seed = 1;const Message = function(options) &#123; options = options || &#123;&#125;; if (typeof options === &#x27;string&#x27;) &#123; options = &#123; message: options &#125;; &#125; let id = &#x27;message_&#x27; + seed++; instance = new MessageConstructor(&#123; data: options &#125;); instance.id = id; if (isVNode(instance.message)) &#123; instance.$slots.default = [instance.message]; instance.message = null; &#125; instance.$mount(); document.body.appendChild(instance.$el); let verticalOffset = options.offset || 20; instances.forEach(item =&gt; &#123; verticalOffset += item.$el.offsetHeight + 16; &#125;); instance.verticalOffset = verticalOffset; instance.visible = true; instances.push(instance); return instance;&#125;;[&#x27;success&#x27;, &#x27;warning&#x27;, &#x27;info&#x27;, &#x27;error&#x27;].forEach(type =&gt; &#123; Message[type] = options =&gt; &#123; if (typeof options === &#x27;string&#x27;) &#123; options = &#123; message: options &#125;; &#125; options.type = type; return Message(options); &#125;;&#125;);export default Message; 我们发现在Message的构造函数中首先对options进行一个处理，因为可以传入字符串或者对象两种调用方式，因此首先把字符串的options统一成对象形式；然后通过Vue.extend创建的构造函数实例化一个instance，将所有的参数options传到instance中进行渲染，最后把instance.$el插入到页面上去渲染；这里为了对所有的实例进行管理，比如根据所有实例个数，渲染最后一个实例的高度还有关闭实例对象等操作，因此维护了一个数组instances来进行管理，还给每个实例一个自增id方便进行查找。 然后我们来看下Vue.extend传入的参数main.vue的源码（部分）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//packages/message/src/main.vue&lt;template&gt; &lt;transition name=&quot;el-message-fade&quot; @after-leave=&quot;handleAfterLeave&quot;&gt; &lt;div :class=&quot;[ &#x27;el-message&#x27;, type &amp;&amp; !iconClass ? `el-message--$&#123; type &#125;` : &#x27;&#x27;, center ? &#x27;is-center&#x27; : &#x27;&#x27;, showClose ? &#x27;is-closable&#x27; : &#x27;&#x27;, customClass ]&quot; :style=&quot;positionStyle&quot; v-show=&quot;visible&quot; @mouseenter=&quot;clearTimer&quot; @mouseleave=&quot;startTimer&quot; role=&quot;alert&quot;&gt; &lt;i :class=&quot;iconClass&quot; v-if=&quot;iconClass&quot;&gt;&lt;/i&gt; &lt;i :class=&quot;typeClass&quot; v-else&gt;&lt;/i&gt; &lt;slot&gt; &lt;p v-if=&quot;!dangerouslyUseHTMLString&quot; class=&quot;el-message__content&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;p v-else v-html=&quot;message&quot; class=&quot;el-message__content&quot;&gt;&lt;/p&gt; &lt;/slot&gt; &lt;i v-if=&quot;showClose&quot; class=&quot;el-message__closeBtn el-icon-close&quot; @click=&quot;close&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;/transition&gt;&lt;/template&gt;&lt;script type=&quot;text/babel&quot;&gt; export default &#123; data() &#123; return &#123; visible: false, message: &#x27;&#x27;, duration: 3000, type: &#x27;info&#x27;, iconClass: &#x27;&#x27;, customClass: &#x27;&#x27;, onClose: null, showClose: false, closed: false, verticalOffset: 20, timer: null, dangerouslyUseHTMLString: false, center: false &#125;; &#125;, methods: &#123; handleAfterLeave() &#123; this.$destroy(true); this.$el.parentNode.removeChild(this.$el); &#125;, &#125;, &#125;;&lt;/script&gt; 我们看到这里data参数和文档中给出的参数是一样的，在上面构造函数中正是通过options传入进来进行覆盖；这里关闭组件是通过watch监听closed是否为true，然后再给visible赋值false；那么页面上明明渲染的是visible，为什么这里不直接给visible赋值呢？个人猜测是为了在关闭的同时触发回调函数onClose；在组件动画结束后也调用了parentNode.removeChild将组件从body中移除， 总结 我们从webpack配置文件入手，找到了入口文件进行组件的注册配置和导出，对众多的组件进行了分类，归为三大类；由于文章篇幅有限，这里只展示了每一类组件中部分组件的源码，像很多常用的组件，比如Input、Radio和Checkbox等很多组件都是大同小异，大家可以继续深入学习其源码；在看源码的同时建议可以查看官方文档中的参数以及参数说明，这样能够更好地理解源码中的思想逻辑，不至于看的一头雾水。","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"源码","slug":"SourceCode","permalink":"http://xieyufei.com/tags/SourceCode/"},{"name":"Vue","slug":"Vue","permalink":"http://xieyufei.com/tags/Vue/"},{"name":"组件化","slug":"Componentization","permalink":"http://xieyufei.com/tags/Componentization/"}]},{"title":"深入对比Webpack、Parcel、Rollup打包工具的不同","date":"2021-01-28T04:00:00.000Z","path":"2021/01/28/Package-Tool-Compare.html","text":"我们在之前用了两篇文章来介绍了Webpack的配置和优化，那么为什么这篇文章还要来对比Parcel和Rollup呢？配置过Webpack的童鞋可能会发现了，虽然它具有很高的可配置性和扩展性，以及丰富的插件系统，但是这些无一不给我们的上手带来限制，有很高的上手门槛。相信大多童鞋在配置时遇到都会遇到莫名其妙的报错和各种查资料的烦恼，那么今天就来看一下Parcel和Rollup能给我们的打包带来哪些便利。 Parcel Parcel官网的定义就是极速零配置Web应用打包工具，它利用多核处理提供了极快的速度，并且不需要任何配置。 它有以下优点： 极速打包：Parcel使用worker进程去启用多核编译。同时有文件系统缓存，即使在重启构建后也能快速再编译。 将你所有的资源打包：Parcel 具备开箱即用的对 JS, CSS, HTML, 文件 及更多的支持，而且不需要插件。 自动转换：如若有需要，Babel, PostCSS, 和PostHTML甚至 node_modules 包会被用于自动转换代码. 零配置代码分拆：使用动态import()语法, Parcel 将你的输出文件束(bundles)分拆，因此你只需要在初次加载时加载你所需要的代码。 热模块替换：Parcel 无需配置，在开发环境的时候会自动在浏览器内随着你的代码更改而去更新模块。 友好的错误日志：当遇到错误时，Parcel 会输出 语法高亮的代码片段，帮助你定位问题。 我们从以下几个方面分别来看下Parcel如何进行配置。 入口文件 Parcel可以使用任何类型的文件作为入口，但是最好还是使用Html或者JS文件。我们新建一个项目，创建html和js文件： 123456&lt;!-- index.html --&gt;&lt;html&gt; &lt;body&gt; &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 12//index.jsconsole.log(&#x27;hello parcel&#x27;) 文件创建好后我们就可以启动Parcel了，它默认内置了一个用于开发环境的服务器，如果将入口设置为js文件，我们可以在浏览器里查看到js文件内容，但这样看不到任何页面效果，因此我们将入口设置为html文件： 1parcel index.html 现在可以在浏览器打开http://localhost:1234/，也可以添加-p &lt;prot number&gt;覆盖默认的1234端口号；这个开发服务器也支持模块热更新，我们改变js或者html内容，浏览器就会自动更新。同时，Parcel也支持多页面入口，假设我们的项目结构如下： 1234567- pages - home index.html index.js - list index.html index.js 我们可以繁琐的手动指定需要加载入口的文件名称，比如： 1parcel ./pages/home/index.html ./pages/list/index.html 也可以通过glob文件匹配模式来匹配所有的html文件： 1parcel ./pages/**/*.html 这样，我们就可以通过http://localhost:1234/home/index.html来访问到页面了。 我们发现在入口文件这方面，Parcel相较于Webpack要灵活不少，在Webpack中我们需要通过entry字段来指定入口，而且入口只能是JS文件，要以html为入口还需要使用第三方插件如html-webpack-plugin；而Parcel在入口文件则宽松很多，可以用html文件作为入口，Parcel会自动加载html文件中引用的脚本或者样式进行打包；我们甚至还可以将一张图片或者vue文件直接作为入口文件。 模块转换 通常打包工具只知道如何处理JS文件，在处理其他资源时，比如less/sass、图片、vue文件等，都需要通过通过转换器进行转换，比如webpack的loader就是充当了转换器的角色；而Parcel支持许多开箱即用的转换器，比如在项目根目录配置.babelrc和.postcssrc，Parcel就会自动在所有的JS和css上进行转换。 再比如我们一般在项目中使用sass或者less，然后在js中import来引入样式，如果在webpack中也是需要通过配置loader才能解析；而我们在Parcel可以不通过任何配置直接import进来，Parcel会自动给我们安装sass的依赖包： 代码分割 虽然项目代码的增多，打包出来的文件也会随之增大；通过代码分割我们可以将首屏不加载的页面或者模块拆分到独立的包中，然后进行按需加载。 在Webpack中实现代码分割主要是通过配置splitChunks和模块内的内联函数动态引入来实现代码分割，而Parcel支持零配置代码分割，并且开箱即用。我们可以将代码拆分成单独的包，这些包可以按需加载；主要是通过动态import()函数来实现，这个函数与普通的import语句类似，但返回一个Promise对象： 123456789101112//about.jsexport function render() &#123; console.log(&quot;about run&quot;);&#125;//index.jslet body = document.getElementsByTagName(&#x27;body&#x27;)[0]body.addEventListener(&quot;click&quot;, ()=&gt;&#123; import(&quot;./about.js&quot;).then((page) =&gt; &#123; page.render(); console.log(&quot;index import&quot;); &#125;);&#125;); 这样，Parcel在打包时会将about.js单独进行打包，然后点击body时才按需加载。 模块热更新 模块热更新（HMR）我们在Webpack中也介绍过，是通过在运行时自动更新浏览器中的模块而无需刷新整个页面，从而改善了开发体验；其实现的原理主要是在服务器和浏览器之间维护了一个websocket连接，服务器自动推送每次代码改变。 在webpack中主要是通过官方的webpack-dev-server服务器来实现的，而在Parcel中HMR服务器是内置的，开箱即用，在启动开发环境服务器时自动启用，无需配置。 Tree Shaking Parcel不支持Tree Shaking 小结 我们体验完整个Parcel，发现确实一行配置代码都没有写，和官网的slogan极速零配置确实符合；在Webpack最难配置的模块转换方面，Parcel做到了自动识别处理导入的模块，这是让我们眼前一亮的地方；而且内部启用了多进程工作，在打包相同体量的项目时，Parcel会比Webpack快很多；不过Webpack的很多功能Parcel也并不具备，比如常用的Tree Shaking、提取公共代码等，因此我们在使用它时需要考虑到这些功能是否是我们项目所必须的。 Rollup 我们有时候在开发一些自己项目中用的JS类库时，比如弹框组件、校验组件、工具组件等，如果使用Webpack，在打包时会产生很多冗余代码，导致一个简单的类库打包出来体积也比较庞大；而Rollup就是专门针对类库进行打包，它的优点是小巧而专注，因此现在很多我们熟知的库都都使用它进行打包，比如：Vue、React和three.js等。 Rollup 是一个JavaScript模块打包器，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序。 入口文件 Rollup既然是打包类库文件，那么它的入口也就只能是JS文件了（通过第三方插件可以支持Html，这里不作展开），因此我们新建一个main.js作为入口文件，打包出来的文件我们命名为bundle.js，我们可以简单的通过命令行进行打包： 1234# 针对浏览器环境打包rollup main.js --file bundle.js --format iife# 针对Nodejs环境打包rollup main.js --file bundle.js --format cjs 但是和Webpack一样，推荐使用配置文件进行打包： 12345# 默认使用rollup.config.js配置文件rollup --config# 使用自定义my.config.js配置文件$ rollup --config my.config.js 我们来看下rollup.config.js配置文件需要包含哪些选项： 1234567891011121314151617181920212223242526272829303132333435export default &#123; // 核心选项 input, // 必须 external, plugins, // 额外选项 onwarn, // 高危选项 acorn, context, moduleContext, legacy // 必须 (如果要输出多个，可以是一个数组) output: &#123; // 核心选项 file, // 必须 format, // 必须 name, globals, // 额外选项 paths, banner, footer, intro, outro, sourcemap, sourcemapFile, interop, // 高危选项 exports, amd, indent strict &#125;,&#125;; 我们发现这里input、output.file和output.format都是必传的，因此，一个基础配置文件如下： 12345678// rollup.config.jsexport default &#123; input: &quot;main.js&quot;, output: &#123; file: &quot;bundle.js&quot;, format: &quot;cjs&quot;, &#125;,&#125;; 这里的format字段大家看了可能不太理解，尤其是里面的cjs代表什么意思；由于JS有多种模块化方式，Rollup可以针对不同的模块规范打包出不同的文件，它有以下五种选项； amd： 异步模块定义，用于像RequireJS这样的模块加载器 cjs：CommonJS，适用于 Node 和 Browserify/Webpack es：ES模块文件 iife：自执行模块，适用于浏览器环境script标签 umd：通用模块定义，以amd，cjs 和 iife 为一体 和Webpack一样，Rollup也支持配置多个文件入口，我们新建foo.js和bar.js两个入口文件： 12345678910export default &#123; input: &#123; foo: &quot;./foo.js&quot;, bar: &quot;./bar.js&quot;, &#125;, output: &#123; dir: &quot;dist&quot;, format: &quot;cjs&quot;, &#125;,&#125;; 这样打包出来的两个文件就放入dist中。 插件 插件拓展了Rollup处理其他类型文件的能力，它的功能有点类似于Webpack的loader和plugin的组合；不过配置比webpack中要简单很多，不用逐个声明哪个文件用哪个插件处理，只需要在plugins中声明，在引入对应文件类型时就会自动加载；我们来看几个常用的插件。 首先是rollup-plugin-json，让Rollup可以从JSON文件中读取数据： 123456789import json from &quot;rollup-plugin-json&quot;;export default &#123; input: &quot;main.js&quot;, output: &#123; file: &quot;bundle.js&quot;, format: &quot;iife&quot;, &#125;, plugins: [json()],&#125;; Rollup默认只能加载ES6模块的js，但是我们项目中通常也会用到CommonJS的模块，这样Rollup解析就会出现问题，比如： 1234567891011121314//add.jslet count = 1;let add = () =&gt; &#123; return count + 1;&#125;;module.exports = &#123; count, add,&#125;;//main.js//报错import add from &quot;./add&quot;;console.log(&quot;foo&quot;, add.count); 由于ES6模块导入默认会去找default，因此这里打包会报错；这时就需要用到rollup-plugin-commonjs插件来进行转换： 12345678910import commonjs from &quot;rollup-plugin-commonjs&quot;;export default &#123; input: &quot;./main.js&quot;, output: &#123; file: &quot;bundle.js&quot;, format: &quot;iife&quot;, &#125;, plugins: [commonjs()],&#125;; 而且目前npm中大多数依赖包都是以CommonJS模块形式出现，都需用通过这个插件来进行模块化解析；除此之外，我们引用node_modules中的第三方模块，还需要用到rollup-plugin-node-resolve进行解析，这两个插件通常组合使用： 1234567891011import resolve from &quot;rollup-plugin-node-resolve&quot;;import commonjs from &quot;rollup-plugin-commonjs&quot;;export default &#123; input: &quot;./main.js&quot;, output: &#123; file: &quot;bundle.js&quot;, format: &quot;iife&quot;, &#125;, plugins: [commonjs(), resolve()],&#125;; 除此之外还有很多有用的插件，这里就不一一赘述使用方法，列出来有需要的童鞋可以根据情况进行使用： rollup-plugin-vue：解析vue文件 rollup-plugin-postcss：解析、转换、提取css文件 rollup-plugin-alias：提供modules名称的alias和reslove功能 rollup-plugin-babel：babel转换 rollup-plugin-eslint：eslint代码检测 rollup-plugin-uglify：js代码压缩 rollup-plugin-replace：类似Webpack的DefinePlugin, 可在源码中通过process.env.NODE_ENV用于构建区分环境. 模块热更新 Rollup本身不支持启动开发服务器，我们可以通过rollup-plugin-serve第三方插件来启动一个静态资源服务器： 123456789import serve from &quot;rollup-plugin-serve&quot;;export default &#123; input: &quot;./main.js&quot;, output: &#123; file: &quot;dist/bundle.js&quot;, format: &quot;iife&quot;, &#125;, plugins: [serve(&quot;dist&quot;)],&#125;; 不过由于其本质就是一个静态资源的服务器，因此不支持模块热更新 Tree Shaking 由于Rollup本身支持ES6模块化规范，因此不需要额外配置即可进行Tree Shaking 代码分割 Rollup代码分割和Parcel一样，也是通过按需导入的方式；但是我们输出的格式format不能使用iife，因为iife自执行函数会把所有模块放到一个文件中，可以通过amd或者cjs等其他规范。 12345678export default &#123; input: &quot;./main.js&quot;, output: &#123; //输出文件夹 dir: &quot;dist&quot;, format: &quot;amd&quot;, &#125;,&#125;; 这样我们通过import()动态导入的代码就会单独分割到独立的js中，在调用时按需引入；不过对于这种amd模块的文件，不能直接在浏览器中引用，必须通过实现AMD标准的库加载，比如Require.js。 小结 通过对Rollup的使用介绍，我们发现它有以下优点： 配置简单，打包速度快 自动移除未引用的代码（内置tree shaking） 但是他也有以下不可忽视的缺点： 开发服务器不能实现模块热更新，调试繁琐 浏览器环境的代码分割依赖amd 加载第三方模块比较复杂 总结 经过以上对三个打包工具多方面的使用对比，相信大家都有了一个初步的印象；我们来简单总结一下三个打包工具的使用环境，如果我们需要构建一个简单的小型应用并让它快速运行起来，可以使用Parcel；如果需要构建一个类库只需要导入很少第三方库，可以使用Rollup；如果需要构建一个复杂的应用，需要集成很多第三方库，并且需要代码分拆、HMR等功能，推荐使用Webpack。","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"打包工具","slug":"PackTool","permalink":"http://xieyufei.com/tags/PackTool/"}]},{"title":"深入学习CommonJS和ES6模块化规范","date":"2021-01-08T04:00:00.000Z","path":"2021/01/08/CommonJS-ES6.html","text":"前端模块化是前端工程化的第一步也是重要的一步；不管你是使用React，还是Vue，亦或是Nodejs，都离不开模块化。模块化的规范有很多，而现在用的最多的就是CommonJS和ES6规范，因此我们来深入了解这两个规范以及两者之间的区别。 CommonJS CommonJS规范是一种同步加载模块的方式，也就是说，只有当模块加载完成后，才能执行后面的操作。由于Nodejs主要用于服务器端编程，而模块文件一般都已经存在于本地硬盘，加载起来比较快，因此同步加载模块的CommonJS规范就比较适用。 概述 CommonJS规范规定，每一个JS文件就是一个模块，有自己的作用域；在一个模块中定义的变量、函数等都是私有变量，对其他文件不可见。 12345// number.jslet num = 1function add(x) &#123; return num + x&#125; 在上面的number.js中，变量num和函数add就是当前文件私有的，其他文件不能访问。同时CommonJS规定了，每个模块内部都有一个module变量，代表当前模块；这个变量是一个对象，它的exports属性（即module.exports）提供对外导出模块的接口。 1234567// number.jslet num = 1function add(x) &#123; return num + x&#125;module.exports.num = nummodule.exports.add = add 这样我们定义的私有变量就能提供对外访问；加载某一个模块，就是加载这个模块的module.exports属性。 module 上面说到，module变量代表当前模块，我们来打印看一下它里面有哪些信息： 123456789101112131415161718192021222324252627282930//temp.jsrequire(&#x27;./a.js&#x27;)console.log(module)Module &#123; id: &#x27;.&#x27;, path: &#x27;D:\\\\demo&#x27;, exports: &#123;&#125;, parent: null, filename: &#x27;D:\\\\demo\\\\temp.js&#x27;, loaded: false, children: [&#123; Module &#123; id: &#x27;D:\\\\demo\\\\a.js&#x27;, path: &#x27;D:\\\\demo&#x27;, exports: &#123;&#125;, parent: [Circular], filename: &#x27;D:\\\\demo\\\\a.js&#x27;, loaded: true, children: [], paths: [Array] &#125; &#125;], paths: [ &#x27;D:\\\\demo\\\\node_modules&#x27;, &#x27;D:\\\\projects\\\\mynodejs\\\\node_modules&#x27;, &#x27;D:\\\\projects\\\\node_modules&#x27;, &#x27;D:\\\\node_modules&#x27; ]&#125; 我们发现它有以下属性： id：模块的识别符，通常是带有绝对路径的模块文件名 filename：模块的文件名，带有绝对路径。 loaded：返回一个布尔值，表示模块是否已经完成加载。 parent：返回一个对象，表示调用该模块的模块。 children：回一个数组，表示该模块要用到的其他模块。 exports：模块对外输出的对象。 path：模块的目录名称。 paths：模块的搜索路径。 如果我们通过命令行调用某个模块，比如node temp.js，那么这个模块就是顶级模块，它的module.parent就是null；如果是在其他模块中被调用，比如require(&#39;temp.js&#39;)，那么它的module.parent就是调用它的模块。 但是在最新的Nodejs 14.6版本中module.parent被弃用了，官方推荐使用require.main或者module.children代替，我们来看一下弃用的原因： module.parent值为通过required引用的这个模块的值。如果为当前运行进程的入口，值为null。如果这个模块被非commonJS格式引入，如REPL，或者import导入，值为undefined exports 为了导出模块方便，我们还可以通过exports变量，它指向module.exports，因此这就相当于在每个模块隐性的添加了这样一行代码： 1var exports = module.exports; 在对外输出模块时，可以向exports对象添加属性。 1234567// number.jslet num = 1function add(x) &#123; return num + x&#125;exports.num = numexports.add = add 需要注意的是，不能直接将exports变量指向一个值，因为这样等于切断了exports和module.exports之间的联系 123456// a.jsexports = &#x27;a&#x27;// main.jsvar a = require(&#x27;./a&#x27;)console.log(a)// &#123;&#125; 虽然我们通过exports导出了字符串，但是由于切断了exports = module.exports之间的联系，而module.exports实际上还是指向了空对象，最终导出的结果也是空对象。 require require的基本功能是读取并执行JS文件，并返回模块导出的module.exports对象： 123const number = require(&quot;./number.js&quot;)console.log(number.num)number.add() 如果模块导出的是一个函数，就不能定义在exports对象上： 1234567// number.jsmodule.exports = function () &#123; console.log(&quot;number&quot;)&#125;// main.jsrequire(&quot;./number.js&quot;)() require除了能够作为函数调用加载模块以外，它本身作为一个对象还有以下属性： resolve：需要解析的模块路径。 main：Module对象，表示当进程启动时加载的入口脚本。 extensions：如何处理文件扩展名。 cache：被引入的模块将被缓存在这个对象中。 模块缓存 当我们在一个项目中多次require同一个模块时，CommonJS并不会多次执行该模块文件；而是在第一次加载时，将模块缓存；以后再加载该模块时，就直接从缓存中读取该模块： 1234567891011121314151617//number.jsconsole.log(&#x27;run number.js&#x27;)module.exports = &#123; num: 1&#125;//main.jslet number1 = require(&quot;./number&quot;);let number2 = require(&quot;./number&quot;);number2.num = 2let number3 = require(&quot;./number&quot;);console.log(number3)// run number.js// &#123; num: 2 &#125; 我们多次require加载number模块，但是内部只有一次打印输出；第二次加载时还改变了内部变量的值，第三次加载时内部变量的值还是上一次的赋值，这就证明了后面的require读取的是缓存。 在上面require中，我们介绍了它下面所有的属性，发现有一个cache属性，就是用来缓存模块的，我们先打印看一下： 1234&#123; &#x27;D:\\\\demo\\\\main.js&#x27;: Module &#123;&#125;, &#x27;D:\\\\demo\\\\number.js&#x27;: Module &#123;&#125;&#125; cache按照路径的形式将模块进行缓存，我们可以通过delete require.cache[modulePath]将缓存的模块删除；我们把上面的代码改写一下： 123456789101112131415161718192021//number.jsconsole.log(&#x27;run number.js&#x27;)module.exports = &#123; num: 1&#125;//main.jslet number1 = require(&quot;./number&quot;);let number2 = require(&quot;./number&quot;);number2.num = 2//删除缓存delete require.cache[&#x27;D:\\\\demo\\\\number.js&#x27;]let number3 = require(&quot;./number&quot;);console.log(number3)// run number.js// run number.js// &#123; num: 1 &#125; 很明显的发现，number模块运行了两遍，第二次加载模块我们又把模块的缓存给清除了，因此第三次读取的num值也是最新的；我们也可以通过Object.keys循环来删除所有模块的缓存： 123Object.keys(require.cache).forEach(function(key) &#123; delete require.cache[key];&#125;) 加载机制 CommonJS的加载机制是，模块输出的是一个值的复制拷贝；对于基本数据类型的输出，属于复制，对于复杂数据类型，属于浅拷贝，我们来看一个例子： 1234567891011121314151617181920// number.jslet num = 1function add() &#123; num++&#125;module.exports.num = nummodule.exports.add = add// main.jsvar number = require(&#x27;./number&#x27;)//1console.log(number.num)number.add()//1console.log(number.num)number.num = 3//3console.log(number.num) 由于CommonJS是值的复制，一旦模块输出了值，模块内部的变化就影响不到这个值；因此main.js中的number变量本身和number.js没有任何指向关系了，虽然我们调用模块内部的add函数来改变值，但也影响不到这个值了；反而我们在输出后可以对这个值进行任意的编辑。 针对require这个特性，我们也可以理解为它将模块放到自执行函数中执行： 12345678910111213141516var number = (function()&#123; let num = 1 function add() &#123; num++ &#125; return &#123; num, add, &#125;&#125;)()//1console.log(number.num)number.add()//1console.log(number.num) 而对于复杂数据类型，由于CommonJS进行了浅拷贝，因此如果两个脚本同时引用了同一个模块，对该模块的修改会影响另一个模块： 12345678910111213141516171819202122// obj.jsvar obj = &#123; color: &#123; list: [&#x27;red&#x27;, &#x27;yellow&#x27;,&#x27;blue&#x27;] &#125;&#125;module.exports = obj//a.jsvar obj = require(&#x27;./obj&#x27;)obj.color.list.push(&#x27;green&#x27;)//&#123; color: &#123; list: [ &#x27;red&#x27;, &#x27;yellow&#x27;, &#x27;blue&#x27;, &#x27;green&#x27; ] &#125; &#125;console.log(obj)//b.jsvar obj = require(&#x27;./obj&#x27;)//&#123; color: &#123; list: [ &#x27;red&#x27;, &#x27;yellow&#x27;, &#x27;blue&#x27;, &#x27;green&#x27; ] &#125; &#125;console.log(obj)//main.jsrequire(&#x27;./a&#x27;)require(&#x27;./b&#x27;) 上面代码中我们通过a.js、b.js两个脚本同时引用一个模块进行修改和读取；需要注意的是由于缓存，因此b.js加载时其实已经是从缓存中读取的模块。 我们上面说过require加载时，会执行模块中的代码，然后将模块的module.exports属性作为返回值进行返回；我们发现这个加载过程发生在代码的运行阶段，而在模块被执行前，没有办法确定模块的依赖关系，这种加载加载方式称为运行时加载；由于CommonJS运行时加载模块，我们甚至能够通过判断语句，动态的选择去加载某个模块： 1234567891011let num = 10;if (num &gt; 2) &#123; var a = require(&quot;./a&quot;);&#125; else &#123; var b = require(&quot;./b&quot;);&#125;var moduleName = &#x27;number.js&#x27;var number = require(`./$&#123;moduleName&#125;`) 但也正是由于这种动态加载，导致没有办法在编译时做静态优化。 循环加载 由于缓存机制的存在，CommonJS的模块之间可以进行循环加载，而不用担心引起死循环： 1234567891011121314151617181920//a.jsexports.a = 1;var b = require(&quot;./b&quot;);console.log(b, &quot;a.js&quot;);exports.a = 2;//b.jsexports.b = 11;var a = require(&quot;./a&quot;);console.log(a, &quot;b.js&quot;);exports.b = 22;//main.jsconst a = require(&quot;./a&quot;);const b = require(&quot;./b&quot;);console.log(a, &quot;main a&quot;);console.log(b, &quot;main b&quot;); 在上面代码中，逻辑看似很复杂，a.js加载了b.js，而b.js加载了a.js；但是我们逐一来进行分析，就会发现其实很简单。 加载main.js，发现加载了a模块；读取并存入缓存 执行a模块，导出了{a:1}；发现加载了b模块去，读取并存入缓存 执行b模块，导出了{b:11}；又加载了a模块，读取缓存，此时a模块只导出了{a:1} b模块执行完毕，导出了{b:22} 回到a模块，执行完毕，导出{a:2} 回到main.js，又加载了b模块，读取缓存 因此最后打印的结果： 1234&#123; a: 1 &#125; b.js &#123; b: 22 &#125; a.js &#123; a: 2 &#125; main a &#123; b: 22 &#125; main b 尤其需要注意的是第一个b模块中的console，由于此时a模块虽然已经加载在缓存中，但是并没有执行完成，a模块只导出了第一个&#123;a:1&#125;。 我们发现循环加载，属于加载时执行；一旦某个模块被循环加载，就只输出已经执行的部分，还未执行的部分不会输出。 ES6 与CommonJS规范动态加载不同，ES6模块化的设计思想是尽量的静态化，使得在编译时就能够确定模块之间的依赖关系。我们在Webpack配置全解析（优化篇）就聊到，利用ES6模块静态化加载方案，就可以实现Tree Shaking来优化代码。 export 和CommonJS相同，ES6规范也定义了一个JS文件就是一个独立模块，模块内部的变量都是私有化的，其他模块无法访问；不过ES6通过export关键词来导出变量、函数或者类： 12345export let num = 1export function add(x) &#123; return num + x&#125;export class Person &#123;&#125; 或者我们也可以直接导出一个对象，这两种方式是等价的： 1234567let num = 1function add(x) &#123; return num + x&#125; class Person &#123;&#125;export &#123; num, add, Person &#125; 在导出对象时，我们还可以使用as关键词重命名导出的变量： 1234567891011let num = 1function add(x) &#123; return num + x&#125; export &#123; num as number, num as counter, add as addCount, add as addFunction&#125; 通过as重名了，我们将变量进行了多次的导出。需要注意的是，export规定，导出的是对外的接口，必须与模块内部的变量建立一一对应的关系。下面两种是错误的写法： 123456// 报错，是个值，没有提供接口export 1;// 报错，需要放在大括号中var m = 1;export m; import 使用export导出模块对外接口后，其他模块文件可以通过import命令加载这个接口： 123456import &#123; number, counter, addCount, addFunction&#125; from &quot;./number.js&quot; 上面代码从number.js模块中加载了变量，import命令接受一对大括号，里面指定了从模块导入变量名，导入的变量名必须与被导入模块对外接口的变量名称相同。 和export命令一样，我们可以使用as关键字，将导入的变量名进行重命名： 1234import &#123; number as num,&#125; from &quot;./number.js&quot;console.log(num) 除了加载模块中指定变量接口，我们还可以使用整体加载，通过（*）指定一个对象，所有的输出值都加载在这个对象上： 1import * as number from &quot;./number.js&quot; import命令具有提升效果，会提升到整个模块的头部，首先执行： 1234console.log(num)import &#123; number as num,&#125; from &quot;./number.js&quot; 上面代码不会报错，因为import会优先执行；和CommonJS规范的require不同的是，import是静态执行，因此import不能位于块级作用域内，也不能使用表达式和变量，这些都是只有在运行时才能得到结果的语法结构： 12345678910111213//报错let moduleName = &#x27;./num&#x27;import &#123; num, add &#125; from moduleName;//报错//SyntaxError: &#x27;import&#x27; and &#x27;export&#x27; may only appear at the top level let num = 10;if (num &gt; 2) &#123; import a from &quot;./a&quot;;&#125; else &#123; import b from &quot;./b&quot;;&#125; export default 在上面代码中import导入export对外接口时，都需要知道对外接口的准确名称，才能拿到对应的值，这样比较麻烦，有时我们只有一个接口需要导出；为此ES6规范提供了export default来默认导出： 1234567//add.jsexport default function (x, y) &#123; return x + y;&#125;;//main.jsimport add from &#x27;./add&#x27;console.log(add(2, 4)) 由于export default是默认导出，因此，这个命令在一个模块中只能使用一次，而export导出接口是可以多次导出的： 123456789//报错//SyntaxError: Only one default export allowed per module.//add.jsexport default function (x, y) &#123; return x + y;&#125;;export default function (x, y) &#123; return x + y + 1;&#125;; export default其实是语法糖，本质上是将后面的值赋值给default变量，所以可以将一个值写在export default之后；但是正是由于它是输出了一个default变量，因此它后面不能再跟变量声明语句： 123456789//正确export default 10//正确let num = 10export default num//报错export default let num = 10 既然export default本质上是导出了一个default变量的语法糖，因此我们也可以通过export来进行改写： 123//num.jslet num = 10;export &#123; num as default &#125;; 上面两个代码是等效的；而我们在import导入时，也是把default变量重命名为我们想要的名字，因此下面两个导入代码也是等效的： 123import num from &#x27;./num&#x27;//等效import &#123; default as num &#125; from &#x27;./num&#x27; 在一个模块中，export可以有多个，export default只能有一个，但是他们两者可以同时存在： 1234567891011//num.jsexport let num1 = 1export let num2 = 2let defaultNum = 3export default defaultNum//main.jsimport defaultNum, &#123; num1, num2&#125; from &#x27;./num&#x27; 加载机制 在CommonJS中我们说了，模块的输出是值的复制拷贝；而ES6输出的则是对外接口，我们将上面CommonJS中的代码进行改写来理解两者的区别： 1234567891011121314151617//number.jslet num = 1function add() &#123; num++&#125;export &#123; num, add &#125;//main.jsimport &#123; num, add &#125; from &#x27;./number.js&#x27;//1console.log(num)add()//2console.log(num) 我们发现和CommonJS中运行出来结果完全不一样，调用模块中的函数影响了模块中的变量值；正是由于ES6模块只是输出了一个对外的接口，我们可以把这个接口理解为一个引用，实际的值还是在模块中；而且这个引用还是一个只读引用，不论是基本数据类型还是复杂数据类型： 123456789101112//obj.jslet num = 1let list = [1,2]export &#123; num, list &#125;//main.jsimport &#123; num, list &#125; from &#x27;./obj.js&#x27;//Error: &quot;num&quot; is read-only.num = 3//Error: &quot;list&quot; is read-only.list = [3, 4] import也会对导入的模块进行缓存，重复import导入同一个模块，只会执行一次，这里就不进行代码演示。 循环引用 ES6模块之间也存在着循环引用，我们还是将CommonJS中的代码来进行改造看一下： 123456789101112131415//a.jsexport let a1 = 1;import &#123; b1, b2 &#125; from &quot;./b&quot;;console.log(b1, b2, &quot;a.js&quot;);export let a2 = 11;//b.jsexport let b1 = 2;import &#123; a1, a2 &#125; from &quot;./a&quot;;console.log(a1, a2, &quot;b.js&quot;);export let b2 = 22;//main.jsimport &#123; a1, a2 &#125; from &quot;./a&quot;;import &#123; b1, b2 &#125; from &quot;./b&quot;; 刚开始我们肯定会想当然的以为b.js中打印的是1和undefined，因为a.js只加载了第一个export；但是打印结果后，b.js中两个都是undefined，这是因为import有提升效果。 区别总结 通过上面我们对CommonJS规范和ES6规范的比较，我们总结一下两者的区别： CommonJS模块是运行时加载，ES6模块是编译时输出接口 CommonJS模块输出的是一个值的复制，ES6模块输出的是值的引用 CommonJS加载的是整个模块，即将所有的方法全部加载进来，ES6可以单独加载其中的某个方法 CommonJS中this指向当前模块，ES6中this指向undefined CommonJS默认非严格模式，ES6的模块自动采用严格模式","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"面试","slug":"Interview","permalink":"http://xieyufei.com/tags/Interview/"},{"name":"模块化","slug":"Modularization","permalink":"http://xieyufei.com/tags/Modularization/"}]},{"title":"深入学习Object.defineProperty和Proxy","date":"2020-12-16T08:00:00.000Z","path":"2020/12/16/DefineProperty-Proxy.html","text":"在最新发布的Vue3.0中，尤大大果断放弃了Object.defineProperty，加入了Proxy来实现数据劫持，那么这两个函数有什么区别呢？本文深入的剖析一下两者的用法以及优缺点，相信看文本文你也会理解为什么Vue会选择Proxy。 初识defineProperty 首先来看一下MDN对Object.defineProperty()的一个定义： Object.defineProperty()方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。 它的语法是传入三个参数： Object.defineProperty(obj, prop, descriptor) 三个参数的作用分别是： obj：要定义属性的对象。 prop：要定义或修改的属性的名称或 Symbol 。 descriptor：要定义或修改的属性描述符。 我们先来看下这个函数的简单用法；既然它能够在对象上定义新的属性，那我们通过它来给对象添加新的属性： 12345var user = &#123;&#125;Object.defineProperty(user, &#x27;name&#x27;, &#123; value: &#x27;xyf&#x27;&#125;)console.log(user) 这里描述符中的value值即是需要在对象上定义或者修改的属性值（如果对象上本身有该属性，则会进行修改操作）；除了字符串，还可以是JS的其他数据类型（数值，函数等）。 属性描述符是个对象，那么就有很多操作的地方了，它除了value这个属性，还有以下： 属性名 作用 默认值 configurable 只有该属性的configurable为true，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。 false enumerable 只有该属性的enumerable为true，该属性才会出现在对象的枚举属性中。 false writable 只有该属性的enumerable为true，才能被赋值运算符改变。 false value 该属性对应的值 undefined get 属性的getter函数，当访问该属性时，会调用此函数。 undefined set 当属性值被修改时，会调用此函数。该方法接受一个参数，会传入赋值时的 this 对象。 undefined configurable 我们一一来看每个属性的用法；首先configurable用来描述属性是否可配置（改变和删除），主要有两个作用： 属性第一次设置后是否可以被修改 属性是否可以被删除 在非严格模式下，属性配置configurable:false后进行删除操作会发现属性仍然存在。 12345678910var user = &#123;&#125;Object.defineProperty(user, &#x27;name&#x27;, &#123; value: &#x27;xyf&#x27;, configurable: false, writable: true, enumerable: true,&#125;)delete user.name 而在严格模式下会抛出错误： 123456789101112&quot;use strict&quot;;var user = &#123;&#125;Object.defineProperty(user, &#x27;name&#x27;, &#123; value: &#x27;xyf&#x27;, configurable: false, writable: true, enumerable: true,&#125;)//TypeError: Cannot delete property &#x27;name&#x27; of #&lt;Object&gt;delete user.name configurable:false配置后也不能重新修改： 12345678910111213var user = &#123;&#125;Object.defineProperty(user, &#x27;name&#x27;, &#123; value: &#x27;xyf&#x27;, configurable: false, writable: true, enumerable: true,&#125;)//TypeError: Cannot redefine property: nameObject.defineProperty(user, &#x27;name&#x27;, &#123; value: &#x27;new&#x27;,&#125;) enumerable enumerable用来描述属性是否能出现在for in或者Object.keys()的遍历中： 123456789101112131415161718192021var user = &#123; name: &quot;xyf&quot;, age: 0,&#125;;Object.defineProperty(user, &quot;gender&quot;, &#123; value: &quot;m&quot;, enumerable: true, configurable: false, writable: false,&#125;);Object.defineProperty(user, &quot;birth&quot;, &#123; value: &quot;2020&quot;, enumerable: false, configurable: false, writable: false,&#125;);for (let key in user) &#123; console.log(key, &quot;key&quot;);&#125;console.log(Object.keys(user)); 很明显，enumerable为true的gender就会被遍历到，而birth则不会。 writable writable用来描述属性的值是否可以被重写，值为false时属性只能读取： 1234567891011var user = &#123;&#125;;Object.defineProperty(user, &quot;name&quot;, &#123; value: &quot;xyf&quot;, writable: false, enumerable: false, configurable: false,&#125;);user.name = &quot;new&quot;;console.log(user); 在非严格模式下给name属性再次赋值会静默失败，不会抛出错误；而在严格模式下会抛出异常： 123456789101112&quot;use strict&quot;;var user = &#123;&#125;;Object.defineProperty(user, &quot;name&quot;, &#123; value: &quot;xyf&quot;, writable: false, enumerable: false, configurable: false,&#125;);//TypeError: Cannot assign to read only property &#x27;name&#x27; of object &#x27;#&lt;Object&gt;&#x27;user.name = &quot;new&quot;; get/set 当需要设置或者获取对象的属性时，可以通过getter/setter方法： 1234567891011121314151617var user = &#123;&#125;;var initName = &#x27;&#x27;Object.defineProperty(user, &quot;name&quot;, &#123; get: function()&#123; console.log(&#x27;get name&#x27;) return initName &#125;, set: function(val)&#123; console.log(&#x27;set name&#x27;) initName = val &#125;&#125;);// get nameconsole.log(user.name)// set nameuser.name = &#x27;new&#x27; 当获取name时和赋值name时，都会分别调用一次get和set函数；看到这里，很多同学可能会有疑问，为什么这里要用一个initName，而不是在get和set函数中直接return user.name和user.name = val呢？ 如果我们直接在get函数中return user.name的话，这里的user.name同时也会调用一次get函数，这样的话会陷入一个死循环；set函数也是同样的道理，因此我们通过一个第三方的变量initName来防止死循环。 但是如果我们需要代理更多的属性，不可能给每一个属性定义一个第三方的变量，可以通过闭包来解决 注：get和set函数不是必须成对出现，可以只出现一个；两个函数如果不设置，则默认值为undefined。 小结 在上面表格中可以看到，上述的三种描述符configurable、enumerable和writable的默认值都是false，因此我们一旦使用Object.defineProperty给对象添加属性，如果不设置属性的特性，那么这些值都是false： 123456789101112var user = &#123;&#125;;Object.defineProperty(user, &quot;name&quot;, &#123; value: &quot;xyf&quot;,&#125;);// 等价于Object.defineProperty(user, &quot;name&quot;, &#123; value: &quot;xyf&quot;, configurable: false, enumerable: false, writable: false,&#125;); 而我们通过点运算符给属性赋值时，则默认给三种描述符都赋值true： 123456789101112var user = &#123;&#125;;user.name = &quot;xyf&quot;// 等价于Object.defineProperty(user, &quot;name&quot;, &#123; value: &quot;xyf&quot;, configurable: true, enumerable: true, writable: true,&#125;); 属性描述符分类 属性描述符主要有两种形式：数据描述符和存取描述符；数据描述符特有的两个属性：value和writable；存取描述符特有的两个属性：get和set；两种形式的属性描述符不能混合使用，否则会报错，下面是一个错误的示范： 123456789101112131415161718var user = &#123;&#125;;var initName = &#x27;&#x27;//TypeError: Invalid property descriptor. //Cannot both specify accessors and a value or writable attribute, #&lt;Object&gt;Object.defineProperty(user, &quot;name&quot;, &#123; value: &#x27;new&#x27;, writable: true, get: function()&#123; console.log(&#x27;get name&#x27;) return initName &#125;, set: function(val)&#123; console.log(&#x27;set name&#x27;) initName = val &#125;&#125;); 我们简单想一下就能理解为什么两种描述不能混合使用；value用来定义属性的值，而get和set同样也是定义和修改属性的值，两种描述符在功能上有明显的相似性。 虽然数据描述符和存取描述符不能混着用，但是他们均能分别和configrable、enumerable一起搭配使用，下面表格表示了两种描述符可以同时拥有的健值： configurable enumerable value writable get set 数据描述符 Yes Yes Yes Yes No No 存取描述符 Yes Yes No No Yes Yes 缺陷 通过上面的代码我们可以发现，虽然Object.defineProperty能够劫持对象的属性，但是需要对对象的每一个属性进行遍历劫持；如果对象上有新增的属性，则需要对新增的属性再次进行劫持；如果属性是对象，还需要深度遍历。这也是为什么Vue给对象新增属性需要通过$set的原因，其原理也是通过Object.defineProperty对新增的属性再次进行劫持。 Object.defineProperty除了能够劫持对象的属性，还可以劫持数组；虽然数组没有属性，但是我们可以把数组的索引看成是属性： 12345678910111213141516171819var list = [1,2,3]list.map((elem, index) =&gt; &#123; Object.defineProperty(list, index, &#123; get: function () &#123; console.log(&quot;get index:&quot; + index); return elem; &#125;, set: function (val) &#123; console.log(&quot;set index:&quot; + index); elem = val; &#125; &#125;);&#125;);// set index:2list[2] = 6// get index:1console.log(list[1]) 虽然我们监听到了数组中元素的变化，但是和监听对象属性面临着同样的问题，就是新增的元素并不会触发监听事件： 123456789101112131415161718var list = [1, 2, 3];list.map((elem, index) =&gt; &#123; Object.defineProperty(list, index, &#123; get: function () &#123; console.log(&quot;get index:&quot; + index); return elem; &#125;, set: function (val) &#123; console.log(&quot;set index:&quot; + index); elem = val; &#125; &#125;);&#125;);// 没有输出list.push(4)list[3] = 5 为此，Vue的解决方案是劫持Array.property原型链上的7个函数，我们通过下面的函数简单进行劫持： 12345678910111213141516171819202122232425262728const arratMethods = [ &quot;push&quot;, &quot;pop&quot;, &quot;shift&quot;, &quot;unshift&quot;, &quot;splice&quot;, &quot;sort&quot;, &quot;reverse&quot;,];const arrayProto = Object.create(Array.prototype);arratMethods.forEach((method) =&gt; &#123; const origin = Array.prototype[method]; arrayProto[method] = function () &#123; console.log(&quot;run method&quot;, method); return origin.apply(this, arguments); &#125;;&#125;);const list = [];list.__proto__ = arrayProto;//run method pushlist.push(2);//run method shiftlist.shift(3); 我们在一文读懂JS中类、原型和继承中讲过： 实例对象能够获取原型对象上的属性和方法 我们在数组上进行操作的push、shift等函数都是调用的原型对象上的函数，因此我们将改写后的原型对象重新给绑定到实例对象上的__proto__，这样就能进行劫持。 除此之外，直接修改数组的length属性也会导致Object.defineProperty的监听失败： 1234567891011121314151617181920var list = [];list.length = 10;list.map((elem, index) =&gt; &#123; Object.defineProperty(list, index, &#123; get: function () &#123; console.log(&quot;get index:&quot; + index); return elem; &#125;, set: function (val) &#123; console.log(&quot;set index:&quot; + index); elem = val; &#125;, &#125;);&#125;);list[5] = 4;// undefinedconsole.log(list[6]); 通过给length修改为10，数组中有10个undefied，虽然我们给每个元素都劫持了，但是没有触发get/set函数。 我们总结一下Object.defineProperty在劫持对象和数组时的缺陷： 无法检测到对象属性的添加或删除 无法检测数组元素的变化，需要进行数组方法的重写 无法检测数组的长度的修改 Proxy 相较于Object.defineProperty劫持某个属性，Proxy则更彻底，不在局限某个属性，而是直接对整个对象进行代理，我们看一下ES6文档对Proxy的描述： Proxy可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。 首先还是来看一下Proxy的语法： 1var proxy = new Proxy(target, handler); Proxy本身是一个构造函数，通过new Proxy生成拦截的实例对象，让外界进行访问；构造函数中的target就是我们需要代理的目标对象，可以是对象或者数组；handler和Object.defineProperty中的descriptor描述符有些类似，也是一个对象，用来定制代理规则。 123456789101112131415161718192021222324252627var target = &#123;&#125;var proxyObj = new Proxy( target, &#123; get: function (target, propKey, receiver) &#123; console.log(`getting $&#123;propKey&#125;!`); return Reflect.get(target, propKey, receiver); &#125;, set: function (target, propKey, value, receiver) &#123; console.log(`setting $&#123;propKey&#125;!`); return Reflect.set(target, propKey, value, receiver); &#125;, deleteProperty: function (target, propKey) &#123; console.log(`delete $&#123;propKey&#125;!`); delete target[propKey]; return true; &#125; &#125;);//setting count!proxyObj.count = 1;//getting count!//1console.log(proxyObj.count)//delete count!delete proxyObj.count 可以看到Proxy直接代理了target整个对象，并且返回了一个新的对象，通过监听代理对象上属性的变化来获取目标对象属性的变化；而且我们发现Proxy不仅能够监听到属性的增加，还能监听属性的删除，比Object.defineProperty的功能更为强大。 除了对象，我们来看一下Proxy面对数组时的表现如何： 123456789101112131415161718192021var list = [1,2]var proxyObj = new Proxy(list, &#123; get: function (target, propKey, receiver) &#123; console.log(`getting $&#123;propKey&#125;!`); return Reflect.get(target, propKey, receiver); &#125;, set: function (target, propKey, value, receiver) &#123; console.log(`setting $&#123;propKey&#125;:$&#123;value&#125;!`); return Reflect.set(target, propKey, value, receiver); &#125;,&#125;)//setting 1:3!proxyObj[1] = 3//getting push!//getting length!//setting 2:4!//setting length:3!proxyObj.push(4)//setting length:5!proxyObj.length = 5 不管是数组下标或者数组长度的变化，还是通过函数调用，Proxy都能很好的监听到变化；而且除了我们常用的get、set，Proxy更是支持13种拦截操作。 可以看到Proxy相较于Object.defineProperty在语法和功能上都有着明显的优势；而且Object.defineProperty存在的缺陷，Proxy也都很好地解决了。","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"}]},{"title":"一文彻底读懂Babel","date":"2020-11-18T04:00:00.000Z","path":"2020/11/18/Babel-Practice.html","text":"在我们平时写代码的过程中可能没有感觉Babel的存在，但其实只要我们写JS代码，Babel已经无处不在、无时不刻的在影响着我们的代码；在Webpack基础篇中，我们简单的介绍Babel的安装，也知道了它能够将高版本的ES6转为低版本的ES5代码，这篇文章我们就对Babel的配置以及使用做一个深入的学习和总结。 Babel是什么 Babel官网对Babel的定义就是： Babel 是一个 JavaScript 编译器。 用通俗的话解释就是它主要用于将高版本的JavaScript代码转为向后兼容的JS代码，从而能让我们的代码运行在更低版本的浏览器或者其他的环境中。 比如我们在代码中使用了ES6箭头函数： 1var fn = (num) =&gt; num + 2; 但我们如果用IE11浏览器（鬼知道用户会用什么浏览器来看）运行的话会出现报错；但是经过Babel编译之后的代码就可以运行在IE11以及更低版本的浏览器中了： 123var fn = function fn(num) &#123; return num + 2;&#125; Babel就是做了这样的编译转换工作，来让我们不用考虑浏览器的兼容性问题，只要专心于代码的编写工作。 Babel历史 Babel的前身是从6to5这个库发展而来，6to5的作者是Facebook的澳大利亚工程师Sebastian McKenzie在2014年发布的；从它的名字我们也能看出来，主要的功能就是将ES6转成ES5，我们如今也还能在npm官网看到这个包，不过作者提示已经迁移到Babel了： 在2015年1月份，6to5和Esnext的团队决定一起开发6to5，并且改名为Babel，解析引擎改名为Babylon Babel和Babylon含义 Babylon的翻译是巴比伦，意指巴比伦文明 Babel的翻译是巴别塔，又名通天塔；当时地上的人们都说同一种语言，当人们离开东方之后，他们来到了示拿之地。在那里，人们想方设法烧砖好让他们能够造出一座城和一座高耸入云的塔来传播自己的名声，以免他们分散到世界各地。上帝来到人间后看到了这座城和这座塔，说一群只说一种语言的人以后便没有他们做不成的事了；于是上帝将他们的语言打乱，这样他们就不能听懂对方说什么了，还把他们分散到了世界各地，这座塔也停止了修建，这座塔就被称为“巴别塔”。 Babel版本及区别 2015-02-15，6to5重命名为babel 2015-03-31，babel 5.0发布 2015-10-30，babel 6.0发布 2018-08-27，babel 7.0发布 babel5及之前是一个包含CLI工具+编译器+转换器的集合工具包；babel6之后进行了拆分，集合包被分成多个包： babel-cli，其中包含babel命令行界面 babel-core，包括了Node有关的API和require钩子 babel-polyfill，可以建立一个完整的ES2015环境 babel6默认情况下不携带任何转换器，需要自行安装所需的插件和转换器，通过babel-xxx来安装对应的工具包。 而Babel7用了npm的private scope，把所有的包都挂载@babel下，通过@babel/xxx来安装，不用在node_modules下看到一堆的babel-xxx包。 本文主要以Babel7作为开发工具。 @babel/core和@babel/cli @babel/core我们在很多地方都看到，它是Babel进行转码的核心依赖包，我们常用的babel-cli和babel-node都依赖于它，我们通过例子来看一下它是如何来进行解析（相关代码在demo0）： 1234567891011121314151617181920var babelCore = require(&quot;@babel/core&quot;);var sourceCode = `let fn = (num) =&gt; num + 2`;var options = &#123; //是否生成解析的代码 code: true, //是否生成抽象语法树 ast: true, //是否生成sourceMap sourceMaps: true, plugins: [], presets: [],&#125;;babelCore.transform(sourceCode, options, function (err, result) &#123; console.log(sourceCode); console.log(result.code); console.log(result.map); console.log(result.ast);&#125;); 可以发现原来的es6箭头函数在结果中几乎原封不动的返回出来了；Babel的运行方式总共可以分为三个阶段：解析（parsing）、转换（transforming）和生成（generating）；负责解析阶段的插件是@babel/parser，其作用就是将源码解析成AST；而负责生成阶段的插件是@babel/generator，其作用就是将转好好的AST重新生成代码。 而@babel/core本身不具备转换处理的功能，它把转换的功能拆分到一个个插件（plugins）中；因此当我们不添加任何插件的时候，输入输出代码是相同的。 在@babel/core转换时还有几个副产物：code、mast和map，我们可以通过options配置，根据需要对这几个副产物进行选择性的输出。除了transform这个转换方法，还有transformSync、transformAsync和transformFileSync等同步异步API，可以在babel官网找到。 @babel/cli是Babel自带了一个内置的CLI命令行工具，我们就可以通过命令行来编译文件；它有两种调用方式，可以通过全局安装或者本地安装调用，选用一种即可，推荐在项目本地安装。 123456//全局安装调用npm install --g @babel/clibabel index.js -o output.js//本地安装调用npm install --save-dev @babel/clinpx babel index.js -o output.js @babel/cli还可以使用以下命令参数： 命令参数 缩写 作用 示例 –out-file -o 输出文件名称 babel a.js -o b.js –watch -w 实时监控输出 babel a.js -o b.js -w –source-maps -s 输出map文件 babel a.js -o b.js -s –source-maps inline -s inline 行内source map babel a.js -o b.js -s inline –out-dir -d 编译文件夹 babel src -d dist –ignore 无 忽略某些文件 babel src -d dist –ignore src/**/*.spec.js –copy-files 无 复制不需要编译的文件 babel src -d dist –copy-files –plugins 无 指明使用插件 babel a.js -o b.js –plugins @babel/plugin-transform-arrow-functions –presets 无 指明使用预设 babel src -d dist –presets @babel/preset-env @babel/cli命令行的具体用法在demo1 配置文件 我们虽然可以在命令行中配置各种插件（plugins）或者预设（presets，也就是一组插件），但是这样并不利于后期的查看或者维护，而且大多时候babel都是结合webpack或者gulp等打包工具开发，不会直接通过命令行的方式；因此Babel推荐通过配置文件的方式来进行管理。 Babel的配置文件主要有.babelrc、.babelrc.js、babel.config.js和package.json，他们的配置选项都是相同的，作用也是一样，主要区别在于格式语法的不同，因此我们在项目中只需要选择其中一种即可。 对于.babelrc，它的配置主要是JSON格式的，像这样： 1234&#123; &quot;presets&quot;: [...], &quot;plugins&quot;: [...]&#125; 而.babelrc.js和babel.config.js同样都是JS语法，通过module.exports输出配置： 123456789101112module.exports = function (api) &#123; api.cache(true); const presets = [ ... ]; const plugins = [ ... ]; if (process.env[&quot;ENV&quot;] === &quot;prod&quot;) &#123; plugins.push(...); &#125; return &#123; presets, plugins &#125;;&#125; 我们还可以根据环境来进行动态的配置。而在package.json中，需要增加babel的属性： 12345678&#123; &quot;name&quot;: &quot;demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;babel&quot;: &#123; &quot;presets&quot;: [ ... ], &quot;plugins&quot;: [ ... ], &#125;&#125; 我们可以在配置文件中加入一些插件或者预设，来扩展@babel/core的转换功能；只需要将对应的插件或预设名字加入数组即可；比如我们常用的ES6箭头函数，就是通过@babel/plugin-transform-arrow-functions这个插件来转换： 1234//.babelrc&#123; &quot;plugins&quot;: [&quot;@babel/plugin-transform-arrow-functions&quot;]&#125; 但有时候我们需要对插件和预设设置参数，就不能直接使用字符串的形式了；而应再包裹一层数组，数组的第一项是名称，第二项是设置的参数对象： 123456789//.babelrc&#123; &quot;plugins&quot;: [ [ &quot;@babel/plugin-transform-arrow-functions&quot;, &#123; &quot;spec&quot;: true &#125; ] ]&#125; 这样我们的箭头函数就能正常转换了，相关代码在demo2 Babel插件和预设 Babel的插件大致可以分为语法插件和转换插件： 语法插件：作用于解析阶段，使得babel能够解析更多的语法，官方的语法插件以babel-plugin-syntax开头。 转换插件：在转换这一步把源码转换并输出，官方的转换插件以babel-plugin-transform（正式）或 babel-plugin-proposal（提案）开头。 转换插件将启用相应的语法插件，因此不必同时指定这两种插件。 语法插件虽名为插件，但其本身并不具有功能性。语法插件所对应的语法功能其实都已在@babel/parser里实现，插件的作用只是将对应语法的解析功能打开。所以本文提及的 Babel 插件将专指转换插件。 Babel官网提供了近一百个插件，但是如果我们的代码中一个一个的配置插件就需要对每一个插件有所了解，这样必然会耗费大量的时间精力；为此，Babel提供了预设（presets）的概念，意思就是预先设置好的一系列插件包；这就相当于肯德基中的套餐，将众多产品进行搭配组合，适合不同的人群需要；总有一款适合我们的套餐。 比如@babel/preset-es2015就是用来将部分ES6语法转换成ES5语法，@babel/preset-stage-x可以将处于某一阶段的js语法编译为正式版本的js代码，而@babel/preset-stage-x也已经被Babel废弃了，有兴趣的童鞋可以看这篇官方的文章 我们实际会用到的预设有以下： @babel/preset-env @babel/preset-flow @babel/preset-react @babel/preset-typescript 根据名字我们可以大致猜出每个预设的使用场景，我们重点了解一下@babel/preset-env，它的作用是根据环境来转换代码。 执行顺序 插件和预设都是通过数组的形式在配置文件中配置，如果插件和预设都要处理同一个代码片段，那么会根据以下执行规则来判定： 插件比预设先执行 插件执行顺序是插件数组从前向后执行 预设执行顺序是预设数组从后向前执行 @babel/preset-env 我们来看一下官网对它的描述： @babel/preset-env是一个智能预设，可让您使用最新的JavaScript，而无需微观管理目标环境所需的语法转换（以及可选的浏览器polyfill）。这都使您的生活更轻松，JavaScript包更小！ 我们在项目中不会关心Babel用了哪些插件，支持哪些ES6语法；我们更多关心的是支持哪些浏览器版本这个层面，比如我们在项目中使用了箭头函数、Class、Const和模板字符串： 1234567891011let fun = () =&gt; console.log(&quot;hello babel.js&quot;);class Person &#123; constructor(name) &#123; this.name = name; &#125; say() &#123; console.log(`my name is：$&#123;this.name&#125;`); &#125;&#125;const tom = new Person(&quot;tom&quot;);tom.say(); 但是假如我们的项目需要支持IE10，因此我们需要修改.babelrc： 123&#123; &quot;presets&quot;: [&quot;@babel/preset-env&quot;]&#125; 或者对它进行缩写： 123&#123; &quot;presets&quot;: [&quot;@babel/env&quot;]&#125; 通过Babel编译后输出： 1234567891011121314151617181920212223242526272829function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError(&quot;Cannot call a class as a function&quot;); &#125; &#125;function _defineProperties(target, props) &#123; for (var i = 0; i &lt; props.length; i++) &#123; var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (&quot;value&quot; in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); &#125; &#125;function _createClass(Constructor, protoProps, staticProps) &#123; if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; &#125;var fun = function fun() &#123; return console.log(&#x27;hello babel.js&#x27;);&#125;;var Person = /*#__PURE__*/function () &#123; function Person(name) &#123; _classCallCheck(this, Person); this.name = name; &#125; _createClass(Person, [&#123; key: &quot;say&quot;, value: function say() &#123; console.log(&quot;my name is\\uFF1A&quot;.concat(this.name)); &#125; &#125;]); return Person;&#125;();var tom = new Person(&#x27;tom&#x27;);tom.say(); 可以发现虽然我们没有配置任何转换插件，但是上面写的的箭头函数、Class、Const和模板字符串语法都已经被转换了；默认情况下，@babel/env等于@babel/preset-es2015、@babel/preset-es2016和@babel/preset-es2017三个套餐的叠加。 那如果我们只需要支持最新的Chrome了，可以继续修改.babelrc： 12345678910&#123; &quot;presets&quot;: [ [ &quot;@babel/env&quot;, &#123; &quot;targets&quot;: &quot;last 2 Chrome versions&quot; &#125; ] ]&#125; targets中的含义是最新的两个Chrome版本，Babel再次编译输出： 1234567891011121314151617&quot;use strict&quot;;let fun = () =&gt; console.log(&quot;hello babel.js&quot;);class Person &#123; constructor(name) &#123; this.name = name; &#125; say() &#123; console.log(`my name is：$&#123;this.name&#125;`); &#125;&#125;const tom = new Person(&quot;tom&quot;);tom.say(); 而最新版本的Chrome已经支持箭头函数、Class、Const和模板字符串，所以在编译时不会在进行转换，相关代码在demo3。 上面的target字段不少同学肯定看着很眼熟，这个工具能够根据项目中指定的目标浏览器自动来进行配置，这里我们就不展开深入讨论了；它也可以单独在项目中配置一个.browserslistrc文件： 1last 2 Chrome versions 这样和targets字段的使用效果是一样的；正常情况下，推荐使用browserslist的配置而很少单独配置@babel/preset-env的targets；@babel/preset-env有一些常用的配置项让我们来看一下： targets 虽然targets不推荐使用，但是我们还是来了解一下它的用法，它是用来描述我们在项目中想要支持的目标浏览器环境，它可以是Browserslist格式的查询： 123&#123; &quot;targets&quot;: &quot;&gt; 0.25%, not dead&quot;&#125; 或者可以是一个对象，用来描述支持的最低版本的浏览器： 123456&#123; &quot;targets&quot;: &#123; &quot;chrome&quot;: &quot;58&quot;, &quot;ie&quot;: &quot;11&quot; &#125;&#125; 其他的浏览器版本还可以是：opera、edge、firefox、safari、ios、android、node、electron等 spec 这个属性主要是给其他插件传递参数（比如@babel/plugin-transform-arrow-functions），默认是false，设为true后，我们的箭头函数会有以下改变： 将箭头函数生成的函数用.bind(this)包裹一下，以便在函数内部继续使用this，而不是重命名this。 加一个检查防止函数被实例化 给箭头函数加一个名字 loose 这个属性也主要是给其他插件传递参数（比如@babel/plugin-transform-classes），默认是false，类的方法直接定义在构造函数上；而设置为true后，类的方法被定义到了原型上面，这样在类的继承时可能会引起问题。 include 转换时总是会启用插件的数组，格式是Array&lt;string|RegExp&gt;，它可以是一下两种值： Babel插件 内置的core-js，比如es.map，es.set等 比如我们在last 2 Chrome versions目标浏览器环境下，不会转换箭头函数和Class，但是我们可以将转换箭头函数的插件配置到include中，这样不管我们的目标浏览器怎么更换，箭头函数语法总是会转换： 1234567891011&#123; &quot;presets&quot;: [ [ &quot;@babel/env&quot;, &#123; &quot;targets&quot;: &quot;last 2 Chrome versions&quot;, &quot;include&quot;: [&quot;@babel/plugin-transform-arrow-functions&quot;] &#125; ] ]&#125; useBuiltIns和corejs useBuiltIns这个属性决定是否引入polyfill，可以配置三个值：false（不引入）、usage（按需引入）和entry（项目入口处引入）；corejs表示引入哪个版本的core-js，可以选择2（默认）或者3，只有当useBuiltIns不为false时才会生效。 @babel/polyfill 虽然@babel/preset-env可以转换大多高版本的JS语法，但是一些ES6原型链上的函数（比如数组实例上的的filter、fill、find等函数）以及新增的内置对象（比如Promise、Proxy等对象），是低版本浏览器本身内核就不支持，因此@babel/preset-env面对他们时也无能为力。 比如我们常用的filter函数，在IE浏览器上就会出现兼容性问题，因此我们通过polyfill（垫片）的方式来解决，下面是filter函数简单的兼容代码： 12345678910111213141516171819if (!Array.prototype.filter) &#123; Array.prototype.filter = function (fun /*, thisp*/ ) &#123; var len = this.length; if (typeof fun != &quot;function&quot;) &#123; throw new TypeError(); &#125; var res = new Array(); var thisp = arguments[1]; for (var i = 0; i &lt; len; i++) &#123; if (i in this) &#123; var val = this[i]; if (fun.call(thisp, val, i, this)) &#123; res.push(val); &#125; &#125; &#125; return res; &#125;;&#125; 但是ES有那么多函数和内置对象，我们不可能一个一个都手写来解决，这就到了@babel/polyfill用武之处了；首先我们需要在项目中安装它： 1npm install --save @babel/polyfill 安装完成后在需要转换的文件入口加入引用代码： 1import &#x27;@babel/polyfill&#x27; 或者我们也可以在Webpack入口处进行引入： 123module.exports = &#123; entry: [&quot;@babel/polyfill&quot;, &quot;./src/index.js&quot;],&#125;; 然后通过webpack来打包，这样就能看到在我们的代码中加入了很多的兼容代码，相关代码在demo4： 发现我们数组的fill、filter和findIndex等方法都打包进去了，但是看到这么多密密麻麻的兼容代码，眼尖的童鞋肯定会发现以下两个问题： 打包出来生成的文件非常的大；有一些语法特性可能是我们没用到的，但是Webpack不管三七二十一全都引用进去了，导致打包出来的文件非常庞大。 污染全局变量；polyfill给很多类的原型链上添加函数，如果我们开发的是一个类库给其他开发者使用，这种情况会非常不可控。 因此从Babel7.4开始@babel/polyfill就不推荐使用了，而是直接引入core-js与regenerator-runtime两个包；而@babel/polyfill本身也是这两个包的集合；在上面webpack打包出来的dist文件我们也可以看到，引用的也是这两个包。那core-js到底是什么呢？ 它是JavaScript标准库的polyfill 它尽可能的进行模块化，让你能选择你需要的功能 它和babel高度集成，可以对core-js的引入进行最大程度的优化 目前我们使用的默认都是core-js@2，但它已经封锁了分支，在此之后的特性都只会添加到core-js@3，因此也是推荐使用最新的core-js@3。 @babel/preset-env与core-js 在上面@babel/preset-env配置中有useBuiltIns和corejs两个属性，是用来控制所需的core-js版本；我们以Object.assign、filter和Promise为例，相关代码在demo5： 123456789Object.assign(&#123;&#125;, &#123;&#125;);[(1, 5, 10, 15)].filter(function (value) &#123; return value &gt; 9;&#125;);let promise = new Promise((resolve, reject) =&gt; &#123; resolve(1);&#125;); 然后修改配置文件，如果我们将useBuiltIns配置为非false而没有指定corejs的版本，Babel会提示我们需要配置corejs的版本： 秉承着用新不用旧的原则，毅然选择core-js@3： 1234567891011&#123; &quot;presets&quot;: [ [ &quot;@babel/preset-env&quot;, &#123; &quot;useBuiltIns&quot;: &quot;usage&quot;, &quot;corejs&quot;: 3 &#125; ] ]&#125; 可以看到我们的打包的文件自动引入了core-js中的模块： 1234567891011121314151617&quot;use strict&quot;;require(&quot;core-js/modules/es.array.filter&quot;);require(&quot;core-js/modules/es.object.assign&quot;);require(&quot;core-js/modules/es.object.to-string&quot;);require(&quot;core-js/modules/es.promise&quot;);Object.assign(&#123;&#125;, &#123;&#125;);[(1, 5, 10, 15)].filter(function (value) &#123; return value &gt; 9;&#125;);var promise = new Promise(function (resolve, reject) &#123; resolve(1);&#125;); 而且我们发现它只引入了部分模块；这就比较厉害了，它不仅会考虑到代码中用到的新特性，还会参考目标浏览器的环境来进行按需引入；而useBuiltIns设置为entry的情况则会将core-js中的模块在入口处全部引入，这里就不再演示。 @babel/runtime 我们在上面通过@babel/preset-env转换Class类时发现输出文件的头部多了_classCallCheck、_defineProperties和_createClass三个函数声明，这就是注入的函数，称为辅助函数；@babel/preset-env在转换时注入了函数声明，以便语法转换后使用。 但是我们开发项目时，文件少则几十个，多个上百个，如果每个文件都注入了函数声明，再通过打包工具打包后输出文件又会非常庞大，影响性能。 因此，Babel提供的解决思路是把这些辅助函数都放到一个npm包里面，在每次需要使用的时候就从这个包里把函数require出来；这样即使有几千个文件，也都是对函数进行引用，而不是复制代码；最后通过webpack等工具打包时，只会将npm包中引用到的函数打包一次，这样就复用了代码，减少打包文件的大小。 @babel/runtime就是这些辅助函数的集合包，我们查看@babel/runtime下面的helpers，可以发现导出了很多函数，以及我们上面提及到的_classCallCheck函数： 首先当然是需要安装@babel/runtime这个包，除此之外还需要安装@babel/plugin-transform-runtime，这个插件的作用是移除辅助函数，将其替换为@babel/runtime/helpers中函数的引用。 12npm install --save @babel/runtimenpm install --save-dev @babel/plugin-transform-runtime 然后修改我们的配置文件，相关代码在demo6： 1234&#123; &quot;presets&quot;: [&quot;@babel/env&quot;], &quot;plugins&quot;: [&quot;@babel/transform-runtime&quot;]&#125; 再次打包发现我们的辅助函数已经变成下面的引用方式了： 12345var _interopRequireDefault = require(&quot;@babel/runtime/helpers/interopRequireDefault&quot;);var _classCallCheck2 = _interopRequireDefault(require(&quot;@babel/runtime/helpers/classCallCheck&quot;));var _createClass2 = _interopRequireDefault(require(&quot;@babel/runtime/helpers/createClass&quot;)); @babel/plugin-transform-runtime 上面我们说到@babel/polyfill会建立一个完整的ES2015环境，因此造成了全局变量的污染；虽然使用core-js不会引入全部模块，但是也会污染部分全局变量。 而@babel/plugin-transform-runtime除了能够转换上面的辅助函数，还能对代码中的新特性API进行一个转换，还是以我们的filter函数和Promise对象为例，相关代码在demo7： 123456[1, 5, 10, 15].filter((value) =&gt; &#123; return value &gt; 9;&#125;);let promise = new Promise((resolve, reject) =&gt; &#123; resolve(1);&#125;); 然后修改我们的配置文件.babelrc： 1234567891011&#123; &quot;presets&quot;: [&quot;@babel/env&quot;], &quot;plugins&quot;: [ [ &quot;@babel/transform-runtime&quot;, &#123; &quot;corejs&quot;: 3 &#125; ] ]&#125; 再次查看打包出来的文件发现filter和Promise已经转换成了引用的方式： 12345678910111213141516&quot;use strict&quot;;var _interopRequireDefault = require(&quot;@babel/runtime-corejs3/helpers/interopRequireDefault&quot;);var _promise = _interopRequireDefault(require(&quot;@babel/runtime-corejs3/core-js-stable/promise&quot;));var _filter = _interopRequireDefault(require(&quot;@babel/runtime-corejs3/core-js-stable/instance/filter&quot;));var _context;(0, _filter[&quot;default&quot;])(_context = [1, 5, 10, 15]).call(_context, function (value) &#123; return value &gt; 9;&#125;);var promise = new _promise[&quot;default&quot;](function (resolve, reject) &#123; resolve(1);&#125;); 我们发现打包出来的模块是从@babel/runtime-corejs3这个包里面引用的；经过查看，发现它下面包含了三个文件夹：core-js、helpers和regenerator，因此我们可以发现： @babel/runtime-corejs2 ≈ @babel/runtime+core-js+regenerator ≈ @babel/runtime+@babel/polyfill @babel/polyfill和@babel/runtime的区别 经过下面这么多例子，总结一下@babel/polyfill和@babel/runtime的区别：前者改造目标浏览器，让你的浏览器拥有本来不支持的特性；后者改造你的代码，让你的代码能在所有目标浏览器上运行，但不改造浏览器。 一个显而易见的区别就是打开IE11浏览器，如果引入了@babel/polyfill，在控制台我们可以执行Object.assign({}, {})；而如果引入了@babel/runtime，会提示你报错，因为Object上没有assign函数。","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"面试","slug":"Interview","permalink":"http://xieyufei.com/tags/Interview/"},{"name":"打包工具","slug":"PackTool","permalink":"http://xieyufei.com/tags/PackTool/"}]},{"title":"Webpack手写loader和plugin","date":"2020-10-12T04:00:00.000Z","path":"2020/10/12/Webpack-Handwrite.html","text":"我们在Webpack基础篇介绍了多种loader和plugin以及每种的用途；那么他们两者在webpack内部是如何进行工作的呢？让我们手写一个loader和plugin来看看它内部的原理，以便加深对webpack的理解。 手写loader 我们在在Webpack配置基础篇介绍过，loader是链式传递的，对文件资源从上一个loader传递到下一个，而loader的处理也遵循着从下到上的顺序，我们简单了解一下loader的开发原则： 单一原则: 每个Loader只做一件事，简单易用，便于维护； 链式调用: Webpack 会按顺序链式调用每个Loader； 统一原则: 遵循Webpack制定的设计规则和结构，输入与输出均为字符串，各个Loader完全独立，即插即用； 无状态原则：在转换不同模块时，不应该在loader中保留状态； 因此我们就来尝试写一个less-loader和style-loader，将less文件处理后通过style标签的方式渲染到页面上去。 同步loader loader默认导出一个函数，接受匹配到的文件资源字符串和SourceMap，我们可以修改文件内容字符串后再返回给下一个loader进行处理，因此最简单的一个loader如下： 123module.exports = function(source, map)&#123; return source&#125; 导出的loader函数不能使用箭头函数，很多loader内部的属性和方法都需要通过this进行调用，比如this.cacheable()来进行缓存、this.sourceMap判断是否需要生成sourceMap等。 我们在项目中创建一个loader文件夹，用来存放我们自己写的loader，然后新建我们自己的style-loader： 12345678910//loader/style-loader.jsfunction loader(source, map) &#123; let style = ` let style = document.createElement(&#x27;style&#x27;); style.innerHTML = $&#123;JSON.stringify(source)&#125;; document.head.appendChild(style) `; return style;&#125;module.exports = loader; 这里的source就可以看做是处理后的css文件字符串，我们把它通过style标签的形式插入到head中；同时我们也发现最后返回的是一个JS代码的字符串，webpack最后会将返回的字符串打包进模块中。 异步loader 上面的style-loader都是同步操作，我们在处理source时，有时候会进行异步操作，一种方法是通过async/await，阻塞操作执行；另一种方法可以通过loader本身提供的回调函数callback。 12345678910//loader/less-loaderconst less = require(&quot;less&quot;);function loader(source) &#123; const callback = this.async(); less.render(source, function (err, res) &#123; let &#123; css &#125; = res; callback(null, css); &#125;);&#125;module.exports = loader; callback的详细传参方法如下： 12345678910callback(&#123; //当无法转换原内容时，给 Webpack 返回一个 Error error: Error | Null, //转换后的内容 content: String | Buffer, //转换后的内容得出原内容的Source Map（可选） sourceMap?: SourceMap, //原内容生成 AST语法树（可选） abstractSyntaxTree?: AST &#125;) 有些时候，除了将原内容转换返回之外，还需要返回原内容对应的Source Map，比如我们转换less和scss代码，以及babel-loader转换ES6代码，为了方便调试，需要将Source Map也一起随着内容返回。 12345678910//loader/less-loaderconst less = require(&quot;less&quot;);function loader(source) &#123; const callback = this.async(); less.render(source,&#123;sourceMap: &#123;&#125;&#125;, function (err, res) &#123; let &#123; css, map &#125; = res; callback(null, css, map); &#125;);&#125;module.exports = loader; 这样我们在下一个loader就能接收到less-loader返回的sourceMap了，但是需要注意的是： Source Map生成很耗时，通常在开发环境下才会生成Source Map，其它环境下不用生成。Webpack为loader提供了this.sourceMap这个属性来告诉loader当前构建环境用户是否需要生成Source Map。 加载本地loader loader文件准备好了之后，我们需要将它们加载到webpack配置中去；在基础篇中，我们加载第三方的loader只需要安装后在loader属性中写loader名称即可，现在加载本地loader需要把loader的路径配置上。 123456789101112131415module.exports = &#123; module: &#123; rules: [&#123; test: /\\.less/, use: [ &#123; loader: &#x27;./loader/style-loader.js&#x27;, &#125;, &#123; loader: path.resolve(__dirname, &quot;loader&quot;, &quot;less-loader&quot;), &#125;, ], &#125;] &#125;&#125; 我们可以在loader中配置本地loader的相对路径或者绝对路径，但是这样写起来比较繁琐，我们可以利用webpack提供的resolveLoader属性，来告诉webpack应该去哪里解析本地loader。 123456789101112131415161718module.exports = &#123; module: &#123; rules: [&#123; test: /\\.less/, use: [ &#123; loader: &#x27;style-loader&#x27;, &#125;, &#123; loader: &#x27;less-loader&#x27;, &#125;, ], &#125;] &#125;, resolveLoader:&#123; modules: [path.resolve(__dirname, &#x27;loader&#x27;), &#x27;node_modules&#x27;] &#125;&#125; 这样webpack会先去loader文件夹下找loader，没有找到才去node_modules；因此我们写的loader尽量不要和第三方loader重名，否则会导致第三方loader被覆盖加载。 处理参数 我们在配置loader时，经常会给loader传递参数进行配置，一般是通过options属性来传递的，也有像url-loader通过字符串来传参： 1234&#123; test: /\\.(jpg|png|gif|bmp|jpeg)$/, use: &#x27;url-loader?limt=1024&amp;name=[hash:8].[ext]&#x27;&#125; webpack也提供了query属性来获取传参；但是query属性很不稳定，如果像上面的通过字符串来传参，query就返回字符串格式，通过options方式就会返回对象格式，这样不利于我们处理。因此我们借助一个官方的包loader-utils帮助处理，它还提供了很多有用的工具。 123456789101112131415const &#123; getOptions, parseQuery, stringifyRequest,&#125; = require(&quot;loader-utils&quot;);module.exports = function (source, map) &#123; //获取options参数 const options = getOptions(this); //解析字符串为对象 parseQuery(&quot;?param1=foo&quot;) //将绝对路由转换成相对路径 //以便能在require或者import中使用以避免绝对路径 stringifyRequest(this, &quot;test/lib/index.js&quot;)&#125; 常用的就是getOptions将处理后的参数返回出来，它内部的实现逻辑也非常的简单，也是根据query属性进行处理，如果是字符串的话调用parseQuery方法进行解析，源码如下： 1234567891011121314//loader-utils/lib/getOptions.js&#x27;use strict&#x27;;const parseQuery = require(&#x27;./parseQuery&#x27;);function getOptions(loaderContext) &#123; const query = loaderContext.query; if (typeof query === &#x27;string&#x27; &amp;&amp; query !== &#x27;&#x27;) &#123; return parseQuery(loaderContext.query); &#125; if (!query || typeof query !== &#x27;object&#x27;) &#123; return &#123;&#125;; &#125; return query;&#125;module.exports = getOptions; 获取到参数后，我们还需要对获取到的options参数进行完整性校验，避免有些参数漏传，如果一个个判断校验比较繁琐，这就用到另一个官方包schema-utils： 123456789const &#123; getOptions &#125; = require(&quot;loader-utils&quot;);const &#123; validate &#125; = require(&quot;schema-utils&quot;);const schema = require(&quot;./schema.json&quot;);module.exports = function (source, map) &#123; const options = getOptions(this); const configuration = &#123; name: &quot;Loader Name&quot;&#125;; validate(schema, options, configuration); //省略其他代码&#125; validate函数并没有返回值，打印返回值发现是`undefined，因为如果参数不通过的话直接会抛出ValidationError异常，直接进程中断；这里引入了一个schema.json，就是我们对options``中参数进行校验的一个json格式的对应表： 123456789101112&#123; &quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: &#123; &quot;source&quot;: &#123; &quot;type&quot;: &quot;boolean&quot; &#125;, &quot;name&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;, &#125;, &quot;additionalProperties&quot;: false&#125; properties中的健名就是我们需要检验的options中的字段名称，additionalProperties代表了是否允许options中还有其他额外的属性。 less-loader源码分析 写完我们自己简单的less-loader，让我们来看一下官方的less-loader源码到底是怎么样的，这里贴上部分源码： 123456789101112131415161718192021222324252627282930313233343536373839import less from &#x27;less&#x27;;import &#123; getOptions &#125; from &#x27;loader-utils&#x27;;import &#123; validate &#125; from &#x27;schema-utils&#x27;;import schema from &#x27;./options.json&#x27;;async function lessLoader(source) &#123; const options = getOptions(this); //校验参数 validate(schema, options, &#123; name: &#x27;Less Loader&#x27;, baseDataPath: &#x27;options&#x27;, &#125;); const callback = this.async(); //对options进一步处理，生成less渲染的参数 const lessOptions = getLessOptions(this, options); //是否使用sourceMap，默认取options中的参数 const useSourceMap = typeof options.sourceMap === &#x27;boolean&#x27; ? options.sourceMap : this.sourceMap; //如果使用sourceMap，就在渲染参数加入 if (useSourceMap) &#123; lessOptions.sourceMap = &#123; outputSourceFiles: true, &#125;; &#125; let data = source; let result; try &#123; result = await less.render(data, lessOptions); &#125; catch (error) &#123; &#125; const &#123; css, imports &#125; = result; //有sourceMap就进行处理 let map = typeof result.map === &#x27;string&#x27; ? JSON.parse(result.map) : result.map; callback(null, css, map);&#125;export default lessLoader; 可以看到官方的less-loader和我们写的简单的loader本质上都是调用less.render函数，对文件资源字符串进行处理，然后将处理好后的字符串和sourceMap通过callback返回。 loader依赖 在loader中，我们有时候也会使用到外部的资源文件，我们需要在loader对这些资源文件进行声明；这些声明信息主要用于使得缓存loader失效，以及在观察模式(watch mode)下重新编译。 我们尝试写一个banner-loader，在每个js文件资源后面加上我们自定义的注释内容；如果传了filename，就从文件中获取预设好的banner内容，首先我们预设两个banner的txt： 12345//loader/banner1.txt/* build from banner1 *///loader/banner2.txt/* build from banner2 */ 然后在我们的banner-loader中根据参数来进行判断： 1234567891011121314151617181920212223//loader/banner-loaderconst fs = require(&quot;fs&quot;);const path = require(&quot;path&quot;);const &#123; getOptions &#125; = require(&quot;loader-utils&quot;);module.exports = function (source) &#123; const options = getOptions(this); if (options.filename) &#123; let txt = &quot;&quot;; if (options.filename == &quot;banner1&quot;) &#123; this.addDependency(path.resolve(__dirname, &quot;./banner1.txt&quot;)); txt = fs.readFileSync(path.resolve(__dirname, &quot;./banner1.txt&quot;)); &#125; else if (options.filename == &quot;banner2&quot;) &#123; this.addDependency(path.resolve(__dirname, &quot;./banner1.txt&quot;)); txt = fs.readFileSync(path.resolve(__dirname, &quot;./banner1.txt&quot;)); &#125; return source + txt; &#125; else if (options.text) &#123; return source + `/* $&#123;options.text&#125; */`; &#125; else &#123; return source; &#125;&#125;; 这里使用了this.addDependency的API将当前处理的文件添加到文件依赖中（并不是项目的package.json）。如果在观察模式下，依赖的text文件发生了变化，那么打包生成的文件内容也随之变化。 如果不添加this.addDependency的话项目并不会报错，只是在观察模式下，如果依赖的文件发生了变化生成的bundle文件并不能及时更新。 缓存加速 在有些情况下，loader处理需要大量的计算非常耗性能（比如babel-loader），如果每次构建都重新执行相同的转换操作每次构建都会非常慢。 因此webpack默认会将loader的处理结果标记为可缓存，也就是说在需要被处理的文件或者其依赖的文件没有发生变化时，它的输出结果必然是相同的；如果不想让webpack缓存该loader，可以禁用缓存： 12345module.exports = function(source) &#123; // 强制不缓存 this.cacheable(false); return source;&#125;; 手写loader所有代码均在webpackdemo19 手写plugin 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过Webpack提供的API改变输出结果。和手写loader一样，我们先来写一个简单的plugin： 12345678//plugins/MyPlugin.jsclass MyPlugin &#123; constructor() &#123; console.log(&quot;Plugin被创建了&quot;); &#125; apply (compiler) &#123;&#125;&#125;module.exports = MyPlugin; plugin的本质是类；我们在定义plugin时，其实是在定义一个类；定义好plugin后就可以在webpack配置中使用这个插件： 1234567//webpack.config.jsconst MyPlugin = require(&#x27;./plugins/MyPlugin&#x27;)module.exports = &#123; plugins: [ new MyPlugin() ],&#125; 这样我们的插件就在webpack中生效了；这时有些童鞋可能会想起来，我们在使用HtmlWebpackPlugin或者CleanWebpackPlugin等一些官方插件时，可以通过实例化插件传入参数；那么这里我们是否也能通过这种方式给我们的插件传参呢？ 123456789101112131415//plugins/MyPlugin.jsclass MyPlugin &#123; constructor(options) &#123; console.log(&quot;Plugin被创建了&quot;); console.log(options); this.options = options; &#125; apply (compiler) &#123;&#125;&#125;//webpack.config.jsmodule.exports = &#123; plugins: [ new MyPlugin(&#123; title: &#x27;MyPlugin&#x27; &#125;) ],&#125; 我们在构建插件时就能通过options获取配置信息，对插件做一些初始化的工作。在构造函数中我们发现多了一个apply函数，它会在webpack运行时被调用，并且注入compiler对象；其工作流程如下： webpack启动，执行new myPlugin(options)，初始化插件并获取实例 初始化complier对象，调用myPlugin.apply(complier)给插件传入complier对象 插件实例获取complier，通过complier监听webpack广播的事件，通过complier对象操作webpack 我们可以通过apply函数中注入的compiler对象进行注册事件： 123456789101112class MyPlugin &#123; apply(compiler) &#123; //不推荐使用，plugin函数被废弃了 // compiler.plugin(&quot;compile&quot;, (compilation) =&gt; &#123; // console.log(&quot;compile&quot;); // &#125;); //注册完成的钩子 compiler.hooks.done.tap(&quot;MyPlugin&quot;, (compilation) =&gt; &#123; console.log(&quot;compilation done&quot;); &#125;); &#125;&#125; compiler不仅有同步的钩子，通过tap函数来注册，还有异步的钩子，通过tapAsync和tapPromise来注册： 123456789101112131415161718class MyPlugin &#123; apply(compiler) &#123; compiler.hooks.run.tapAsync(&quot;MyPlugin&quot;, (compilation, callback) =&gt; &#123; setTimeout(()=&gt;&#123; console.log(&quot;compilation run&quot;); callback() &#125;, 1000) &#125;); compiler.hooks.emit.tapPromise(&quot;MyPlugin&quot;, (compilation) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(()=&gt;&#123; console.log(&quot;compilation emit&quot;); resolve(); &#125;, 1000) &#125;); &#125;); &#125;&#125; 这里又有一个compilation对象，它和上面提到的compiler对象都是Plugin和webpack之间的桥梁： compiler对象包含了 Webpack 环境所有的的配置信息。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options，loader 和 plugin。当在 webpack 环境中应用一个插件时，插件将收到此 compiler 对象的引用。可以使用它来访问 webpack 的主环境。 compilation对象包含了当前的模块资源、编译生成资源、变化的文件等。当运行webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。compilation 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。 compiler和compilation的区别在于： compiler代表了整个webpack从启动到关闭的生命周期，而compilation只是代表了一次新的编译过程 compiler和compilation暴露出许多钩子，我们可以根据实际需求的场景进行自定义处理 手写FileListPlugin 了解了compiler和compilation的区别，我们就来尝试一个简单的示例插件，在打包目录生成一个filelist.md文件，文件的内容是将所有构建生成文件展示在一个列表中： 1234567891011121314151617181920212223class FileListPlugin &#123; apply(compiler)&#123; compiler.hooks.emit.tapAsync(&#x27;FileListPlugin&#x27;, (compilation, callback)=&gt;&#123; var filelist = &#x27;In this build:\\n\\n&#x27;; // 遍历所有编译过的资源文件， // 对于每个文件名称，都添加一行内容。 for (var filename in compilation.assets) &#123; filelist += &#x27;- &#x27; + filename + &#x27;\\n&#x27;; &#125; // 将这个列表作为一个新的文件资源，插入到 webpack 构建中： compilation.assets[&#x27;filelist.md&#x27;] = &#123; source: function() &#123; return filelist; &#125;, size: function() &#123; return filelist.length; &#125; &#125;; callback(); &#125;) &#125;&#125;module.exports = FileListPlugin 我们这里用到了assets对象，它是所有构建文件的一个输出对象，打印出来大概长这样： 1234&#123; &#x27;main.bundle.js&#x27;: &#123; source: [Function: source], size: [Function: size] &#125;, &#x27;index.html&#x27;: &#123; source: [Function: source], size: [Function: size] &#125;&#125; 我们手动加入一个filelist.md文件的输出；打包后我们在dist文件夹中会发现多了这个文件： 1234In this build:- main.bundle.js- index.html 这个插件就完成了我们的预期任务了。 参考 webpack loader从入门到精通全解析","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"打包工具","slug":"PackTool","permalink":"http://xieyufei.com/tags/PackTool/"}]},{"title":"四种实现浏览器标签页数据通信方式","date":"2020-09-12T04:47:49.000Z","path":"2020/09/12/Tab-Communicate.html","text":"浏览器可以打开多个不同的标签页，有时候需要在这多个标签页共享同一份数据，那如何在多个标签页中进行数据的通信呢？让我们来看一下四种在标签页中通信的方式。 我们在网易云听歌时，可以打开多个标签页进行播放；但是我们发现在一个标签页播放的同时，其他标签如果正在播放，都会自动的停止。 想想这样也是合理的，因为毕竟如果多个标签页都同时播放声音就会干扰，同一时间只能存在一个音乐播放；因此我们也来尝试实现这样一个需求，在不同浏览器中进行数据通信： 我们首先来准备一些数据，和网易云一样，准备一个专辑列表，每个专辑列表中有不同的歌曲，可以通过URL参数传递id来获取不同的专辑页面： 12345678910111213141516171819202122&lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;item header&quot;&gt; &lt;div class=&quot;index&quot;&gt;&lt;/div&gt; &lt;div class=&quot;name&quot;&gt;歌曲标题&lt;/div&gt; &lt;div class=&quot;time&quot;&gt;时长&lt;/div&gt; &lt;div class=&quot;singer&quot;&gt;歌手&lt;/div&gt; &lt;div class=&quot;album&quot;&gt;专辑&lt;/div&gt; &lt;/div&gt; &lt;template v-for=&quot;(item, index) in list&quot;&gt; &lt;div :class=&quot;[&#x27;item&#x27;,&#x27;music&#x27;,activeIndex == index ? &#x27;active&#x27;:&#x27;&#x27;]&quot; @click=&quot;clickMusic(item, index)&quot; :key=&quot;index&quot;&gt; &lt;div class=&quot;index&quot;&gt;&#123;&#123;index+1&#125;&#125;&lt;/div&gt; &lt;div class=&quot;name&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/div&gt; &lt;div class=&quot;time&quot;&gt;&#123;&#123;item.time&#125;&#125;&lt;/div&gt; &lt;div class=&quot;singer&quot;&gt;&#123;&#123;item.singer&#125;&#125;&lt;/div&gt; &lt;div class=&quot;album&quot;&gt;&#123;&#123;item.album&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627new Vue(&#123; el: &#x27;#app&#x27;, data() &#123; return &#123; list: [], activeIndex: -1, &#125; &#125;, mounted() &#123; const &#123; id = &#x27;1&#x27; &#125; = Qs.parse(window.location.search, &#123; ignoreQueryPrefix: true &#125;) axios(&#123; url: &#x27;/api/list&#x27;, params: &#123; id, &#125; &#125;).then((res) =&gt; &#123; return res.data &#125;).then((res) =&gt; &#123; const &#123; list &#125; = res this.list = list &#125;) &#125;,&#125;) cookie 要想在所有的标签页中实现通信，我们必须将数据存放到一个公共的存储空间，所有的标签页都能获取并且还能进行修改；我们知道，cookie在用户所有浏览器标签页中都是共享的，因此，我们可以尝试把选中的数据存放到cookie中去： 1234567891011121314151617181920212223242526272829new Vue(&#123; mounted() &#123; setInterval(() =&gt; &#123; let newValue = Cookies.get(&#x27;music&#x27;) if (newValue) &#123; let parse = &#123;&#125; try &#123; parse = JSON.parse(newValue) &#125; catch (error) &#123;&#125; let &#123; list, &#125; = this let activeIndex = -1 list.map((item, index) =&gt; &#123; if (item.name == parse.name) &#123; activeIndex = index &#125; &#125;) this.activeIndex = activeIndex &#125; &#125;, 1000) &#125;, methods: &#123; clickMusic(item, index) &#123; this.activeIndex = index Cookies.set(&#x27;music&#x27;, JSON.stringify(item)) &#125; &#125;&#125;) 由于更新cookie并不能触发任何事件，因此我们需要通过定时器setInterval来主动监听cookie中的值是否改变；代码看起来没有问题，让我们看一下运行的效果： 存在下面两个问题： 定时器存在时间差，点击后有一定的延迟，cookie本身的弊端 在同一个专辑id页面下，由于选中的数据没有区分页面，相同音乐item也会被选中 因此我们需要给每一个页面区分一个页面id；这个页面id可以从后台接口中获取，这里为了简单展示，我们使用时间戳作为页面id： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//省略其他代码new Vue(&#123; data() &#123; return &#123; page_id: &#x27;0&#x27;, &#125; &#125;, mounted() &#123; let timestamp = new Date().getTime() this.page_id = timestamp + &#x27;&#x27; setInterval(() =&gt; &#123; let newValue = Cookies.get(&#x27;music&#x27;) if (newValue) &#123; let parse = &#123;&#125; try &#123; parse = JSON.parse(newValue) &#125; catch (error) &#123;&#125; let &#123; list, &#125; = this let activeIndex = -1 list.map((item, index) =&gt; &#123; //是当前页面的id是才选中数据 if (item.name == parse.name &amp;&amp; parse.page_id == page_id) &#123; activeIndex = index &#125; &#125;) this.activeIndex = activeIndex &#125; &#125;, 1000) &#125;, methods: &#123; clickMusic(item, index) &#123; this.activeIndex = index let &#123; page_id &#125; = this //存放到cookie时将页面id带入 item = Object.assign(&#123; page_id, &#125;, item) Cookies.set(&#x27;music&#x27;, JSON.stringify(item)) &#125; &#125;&#125;) 我们虽然能通过给每个页面分配id来解决问题2，但是由于定时器的弊端，cookie+setInterval的方案会存在延时的情况。 localStorage localStorage也是浏览器多个页面共用的存储空间；而且localStorage在一个页面中添加、修改或者删除时，都会在非当前页面中被动触发一个storage事件，我们通过在其他页面中监听storage事件，即可拿到storage更新前后的值： 123456789101112131415161718192021222324252627282930//省略其他代码new Vue(&#123; mounted() &#123; let timestamp = new Date().getTime() this.page_id = timestamp + &#x27;&#x27; window.addEventListener(&#x27;storage&#x27;, (ev) =&gt; &#123; const &#123; key, newValue, &#125; = ev if (key === &#x27;music&#x27; &amp;&amp; newValue) &#123; let parse = &#123;&#125; try &#123; parse = JSON.parse(newValue) &#125; catch (error) &#123;&#125; let &#123; list, page_id &#125; = this let activeIndex = -1 list.map((item, index) =&gt; &#123; if (item.name == parse.name &amp;&amp; parse.page_id == page_id) &#123; activeIndex = index &#125; &#125;) this.activeIndex = activeIndex &#125; &#125;) &#125;,&#125;) 相较于cookie的主动监听，localStorage的被动触发不仅在代码显得更加友好，而且还极大的避免了定时器带来的性能损耗。 webworker 我们在《从一道面试题来理解JS事件循环》提到，webworker只能用来做一些消耗CPU的逻辑运算等；webworker也分为Worker和SharedWorker，普通的worker可以直接使用new Worker()创建，只在当前页面中使用；而SharedWorker通过名字我们也能看出，是可以在多个标签页面中数据是共享的； SharedWorker和Worker不同之处在于它第二个参数可以做直接指定name，或者使用对象参数，因此下面三种构造方式是相同的： 123new SharedWorker(&#x27;/public/shared.js&#x27;, &#x27;musicWorker&#x27;);new SharedWorker(&#x27;/public/shared.js&#x27;, &#123; name: &#x27;musicWorker&#x27; &#125;);new SharedWorker(&#x27;/public/shared.js&#x27;, &#x27;musicWorker&#x27;, &#123; type: &#x27;classic&#x27; &#125;); 构造了SharedWorker实例对象后，我们需要通过其port属性进行通信，主要的API如下： 12345const sw = new SharedWorker(&#x27;/public/shared.js&#x27;);//发送数据sw.port.postMessage(&#x27;...&#x27;)//监听数据sw.port.onmessage = function (event) &#123; // ... &#125; 由于构造的多个SharedWorker实例形成了一个共享的连接，因此在连接成功时，我们给每个实例分配一个唯一id： 12345678910111213141516171819202122232425262728293031323334//main.jsnew Vue(&#123; data() &#123; return &#123; workder_id: 0, sw: &#123;&#125;, &#125; &#125;, mounted() &#123; this.sw = new SharedWorker(&#x27;/public/shared.js&#x27;); this.sw.port.addEventListener(&#x27;message&#x27;, (ev) =&gt; &#123; let &#123; type, data &#125; = ev.data //初始化连接时返回一个id if (type == &#x27;id&#x27;) &#123; this.workder_id = data &#125; &#125;) this.sw.port.start() &#125;, methods: &#123; clickMusic(item, index) &#123; //省略部分代码 //每次通信时将id带上 this.sw.port.postMessage(&#123; type: &#x27;set&#x27;, id: this.workder_id, data: item &#125;) &#125; &#125;&#125;) 我们在ShareWorker内部监听connect事件，并且处理内部的port事件： 12345678910111213141516171819202122232425262728293031323334353637//shared.jsconst connectedClients = new Set()let id = 1//给其他连接端发送消息function sendMessageToClients(payload, currentClientId = null) &#123; connectedClients.forEach((&#123; id, client &#125;) =&gt; &#123; if (currentClientId &amp;&amp; currentClientId == id) return; client.postMessage(payload); &#125;);&#125;//当前连接绑定消息监听function setupClient(clientPort) &#123; clientPort.onmessage = (event) =&gt; &#123; const &#123; type, data, id &#125; = event.data; if(type==&#x27;set&#x27;)&#123; sendMessageToClients(&#123; type: &#x27;get&#x27;, data: data, &#125;, id) &#125; &#125;;&#125;self.addEventListener(&quot;connect&quot;, (event) =&gt; &#123; const newClient = event.source; //每次连接后给client唯一id标识 //将每次连接存在数组中 connectedClients.add(&#123; client: newClient, id: id, &#125;); setupClient(newClient); newClient.postMessage(&#123; type: &#x27;id&#x27;, data: id &#125;) id++&#125;); 当写shared.js，我们经常会遇到问题，那么怎么来调试sharedworker呢？直接console.log并不会在标签页面中有输出；我们打开新的标签页chrome://inspect，选择Shared workers然后再选择对应脚本，就能愉快的调试了。 websocket websocket作为全双工通信，自然可以实现多个标签页之间的通信；WebSocket是HTML5新增的协议，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道。 这里我们使用express的一个框架express-ws来模拟websocket服务器；由于服务器会储存很多标签页的连接对象信息，因此我们需要给每个用户进行唯一标识进行区分；我们从服务器获取user_id并保存。 12345678910111213141516171819202122232425262728293031323334//省略其他代码new Vue(&#123; el: &#x27;#app&#x27;, data() &#123; return &#123; list: [], activeIndex: -1, page_id: &#x27;0&#x27;, ws: null &#125; &#125;, mounted() &#123; let timestamp = new Date().getTime() this.page_id = timestamp + &#x27;&#x27; let store_user_id = Cookies.get(&#x27;user_id&#x27;) if (!!store_user_id) &#123; this.connectWs(store_user_id) &#125; else &#123; axios(&#123; url: &#x27;/api/get_user_id&#x27; &#125;) .then((res) =&gt; &#123; return res.data &#125;) .then((res) =&gt; &#123; let &#123; user_id &#125; = res Cookies.set(&#x27;user_id&#x27;, user_id) this.connectWs(user_id) &#125;) &#125; &#125;,&#125;) 通过user_id我们就可以向websocket服务器连接并发起请求了。 123456789101112131415161718192021222324252627282930313233343536//省略其他代码new Vue(&#123; methods: &#123; clickMusic(item, index) &#123; this.activeIndex = index let &#123; page_id &#125; = this item = Object.assign(&#123; page_id, &#125;, item) this.ws.send(JSON.stringify(item)) &#125;, connectWs(user_id) &#123; var ws = new WebSocket(`ws://localhost:9010/ws/$&#123;user_id&#125;`) ws.onmessage = (e) =&gt; &#123; let parse = &#123;&#125; try &#123; parse = JSON.parse(e.data) &#125; catch (error) &#123;&#125; let &#123; list, page_id &#125; = this let activeIndex = -1 list.map((item, index) =&gt; &#123; if (item.name == parse.name &amp;&amp; parse.page_id == page_id) &#123; activeIndex = index &#125; &#125;) this.activeIndex = activeIndex &#125;; this.ws = ws &#125; &#125;&#125;) 在标签页每次和websocket建立连接后，将连接对象存放到数组中。 12345678910111213141516171819202122232425262728293031323334//省略其他代码const expressWs = require(&quot;express-ws&quot;)(app);let clients = [];let musicNum = null;app.ws(&quot;/ws/:user_id&quot;, function (ws, req) &#123; let &#123; user_id &#125; = req.params; clients.push(&#123; user_id, ws, &#125;); ws.send(&quot;连接成功&quot;); ws.on(&quot;message&quot;, function (msg) &#123; let parsed = &#123;&#125;; try &#123; parsed = JSON.parse(msg); &#125; catch (error) &#123;&#125; musicNum = parsed; for (let i = 0; i &lt; clients.length; i++) &#123; let item = clients[i]; if (item.user_id === user_id &amp;&amp; item !== this) &#123; item.ws.send(msg); &#125; &#125; &#125;); ws.on(&quot;close&quot;, function () &#123; for (let i = 0; i &lt; clients.length; i++) &#123; if (clients[i].ws === this) &#123; clients.splice(i, 1); &#125; &#125; &#125;);&#125;); 本文所有代码都在git仓库","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"}]},{"title":"Webpack配置全解析（优化篇）","date":"2020-07-30T04:00:00.000Z","path":"2020/07/30/Webpack-Optimize.html","text":"在上一篇文章Webpack配置全解析介绍了Webpack中loader和plugins的一些基本用法，当loader和plugins使用较多后项目也会越来越耗时，因此这次我们继续学习如何优化webpack的配置来让我们的项目运行的更快耗时更短。 本文将从缩小文件搜索范围、减少打包文件、缓存和多进程四个方面来了解Webpack的优化配置。 缩小文件搜索范围 Webpack会从Entry入口出发，解析文件中的导入模块语句，再递归解析；每次遇到导入语法时会做两件事情： 查找导入模块的位置，比如require(&#39;vue&#39;)就去引入/node_modules/vue/dist/vue.runtime.common.js文件 通过相应的loader来解析导入的模块，比如引入的js就调用babel-loader来转换代码 当项目只有几个文件时，解析文件流程只有几百毫秒，然而随着项目规模的增大，解析文件会越来越耗时，因此我们通过webpack的配置来缩小我们搜索模块的范围 优化loader配置 在上一篇中，我们介绍了使用include/exclude将node_modules中的文件进行包括/排除。 12345678910&#123; rules: [&#123; test: /\\.js$/, use: &#123; loader: &#x27;babel-loader&#x27; &#125;, // exclude: /node_modules/, include: [path.resolve(__dirname, &#x27;src&#x27;)] &#125;]&#125; include表示哪些目录中的文件需要进行babel-loader，exclude表示哪些目录中的文件不要进行babel-loader。这是因为在引入第三方模块的时候，很多模块已经是打包后的，不需要再被处理，比如vue、jQuery等；如果不设置include/exclude就会被loader处理，增加打包时间。 优化module.noParse配置 如果一些第三方模块没有使用AMD/CommonJs规范，可以使用noParse来标记这个模块，这样Webpack在导入模块时，就不进行解析和转换，提升Webpack的构建速度；noParse可以接受一个正则表达式或者一个函数： 12345678&#123; module: &#123; //noParse: /jquery|lodash|chartjs/, noParse: function(content)&#123; return /jquery|lodash|chartjs/.test(content) &#125; &#125;&#125; 对于jQuery、lodash、chartjs等一些库，庞大且没有采用模块化标准，因此我们可以选择不解析他们。 注：被不解析的模块文件中不应该包含require、import等模块语句 经过多次打包尝试，打包性能大概能提升10%~20%；本实例完整代码demo， 优化resolve.modules配置 modules用于告诉webpack去哪些目录下查找引用的模块，默认值是[&quot;node_modules&quot;]，意思是在./node_modules查找模块，找不到再去../node_modules，以此类推。 我们代码中也会有大量的模块被其他模块依赖和引入，由于这些模块位置分布不固定，路径有时候会很长，比如import &#39;../../src/components/button&#39;、import &#39;../../src/utils&#39;；这时我们可以利用modules进行优化 123456789&#123; resolve: &#123; modules: [ path.resolve(__dirname, &quot;src&quot;), path.resolve(__dirname, &quot;node_modules&quot;), &quot;node_modules&quot;, ], &#125;,&#125; 这样我们可以简单的通过import &#39;components/button&#39;、import &#39;utils&#39;进行导入，webpack会会优先从src目录下进行查找 优化resolve.alias配置 alias通过创建import或者require的别名，把原来导入模块的路径映射成一个新的导入路径；它和resolve.modules不同的的是，它的作用是用别名代替前面的路径，不是省略；这样的好处就是webpack直接会去对应别名的目录查找模块，减少了搜索时间。 1234567&#123; resolve: &#123; alias: &#123; &#x27;@&#x27;: path.resolve(__dirname, &#x27;src&#x27;), &#125;, &#125;,&#125; 这样我们就能通过import Buttom from &#39;@/Button&#39;来引入组件了；我们不光可以给自己写的模块设置别名，还可以给第三方模块设置别名： 1234567&#123; resolve: &#123; alias: &#123; &#x27;vue$&#x27;: isDev ? &#x27;vue/dist/vue.runtime.js&#x27; : &#x27;vue/dist/vue.runtime.min.js&#x27;, &#125;, &#125;,&#125; 我们在import Vue from &#39;vue&#39;时，webpack就会帮我们去vue依赖包的dist文件下面引入对应的文件，减少了搜索package.json的时间。 优化resolve.mainFields配置 mainFields用来告诉webpack使用第三方模块中的哪个字段来导入模块；第三方模块中都会有一个package.json文件用来描述这个模块的一些属性，比如模块名(name)、版本号(version)、作者(auth)等等；其中最重要的就是有多个特殊的字段用来告诉webpack导入文件的位置，有多个字段的原因是因为有些模块可以同时用于多个环境，而每个环境可以使用不同的文件。 mainFields的默认值和当前webpack配置的target属性有关： 如果target为webworker或web（默认），mainFields默认值为[&quot;browser&quot;, &quot;module&quot;, &quot;main&quot;] 如果target为其他（包括node），mainFields默认值为[&quot;module&quot;, &quot;main&quot;] 这就是说当我们require(&#39;vue&#39;)的时候，webpack先去vue下面搜索browser字段，没有找到再去搜索module字段，最后搜索main字段。 为了减少搜索的步骤，在明确第三方模块入口文件描述字段时，我们可以将这个字段设置尽量少；一般第三方模块都采用main字段，因此我们可以这样配置： 12345&#123; resolve: &#123; mainFields: [&quot;main&quot;], &#125;&#125; 优化resolve.extensions配置 extensions字段用来在导入模块时，自动带入后缀尝试去匹配对应的文件，它的默认值是： 12345&#123; resolve: &#123; extensions: [&#x27;.js&#x27;, &#x27;.json&#x27;] &#125;&#125; 也就是说我们在require(&#39;./utils&#39;)时，Webpack先匹配utils.js，匹配不到再去匹配utils.json，如果还找不到就报错。 因此extensions数组越长，或者正确后缀的文件越靠后，匹配的次数越多也就越耗时，因此我们可以从以下几点来优化： extensions数组尽量少，项目中不存在的文件后缀不要列进去 出现频率比较高的文件后缀优先放到最前面 在代码中导入文件的时候，要尽量把后缀名带上，避免查找 以上实例完整代码demo。 减少打包文件 在我们项目中不可避免会引入第三方模块，webpack打包时也会将第三方模块作为依赖打包进bundle中，这样就会增加打包文件尺寸和增加耗时，如果能合理得处理这些模块就能提升不少webpack的性能。 提取公共代码 我们的项目通常有多个页面或者多个页面模块（单页面），多个页面之间通常都有公用的函数或者第三方模块，在每个页面中都打包这些模块会造成以下问题： 资源重复加载，浪费用户流量 每个页面加载资源多，首屏展示慢 在Webpack4之前，都是通过CommonsChunkPlugin插件来提取公共代码，然而存在着以下问题 产出的chunk在引入的时候，会包含重复的代码 无法优化异步chunk Webpack4引入了SplitChunksPlugin插件进行公共模块的抽取；由于webpack4开箱即用的特性，它不用单独安装，通过optimization.splitChunks进行配置即可，官方给的默认配置参数如下： 12345678910111213141516171819202122232425262728293031323334353637module.exports = &#123; optimization: &#123; splitChunks: &#123; // 代码分割时默认对异步代码生效，all：所有代码有效，inital：同步代码有效 chunks: &#x27;async&#x27;, // 代码分割最小的模块大小，引入的模块大于 20000B 才做代码分割 minSize: 20000, // 代码分割最大的模块大小，大于这个值要进行代码分割，一般使用默认值 maxSize: 0, // 引入的次数大于等于1时才进行代码分割 minChunks: 1, // 最大的异步请求数量,也就是同时加载的模块最大模块数量 maxAsyncRequests: 30, // 入口文件做代码分割最多分成 30 个 js 文件 maxInitialRequests: 30, // 文件生成时的连接符 automaticNameDelimiter: &#x27;~&#x27;, enforceSizeThreshold: 5000, cacheGroups: &#123; vendors: &#123; // 位于node_modules中的模块做代码分割 test: /[\\\\/]node_modules[\\\\/]/, // 根据优先级决定打包到哪个组里，例如一个 node_modules 中的模块进行代码 priority: -10 &#125;, // 既满足 vendors，又满足 default，那么根据优先级会打包到 vendors 组中。 default: &#123; // 没有 test 表明所有的模块都能进入 default 组，但是注意它的优先级较低。 // 根据优先级决定打包到哪个组里,打包到优先级高的组里。 priority: -20, //如果一个模块已经被打包过了,那么再打包时就忽略这个上模块 reuseExistingChunk: true &#125; &#125; &#125; &#125;&#125;; 我们在home、list、detail三个页面分别引入了vue.js、axios.js和公用的工具函数模块utils.js；我们首先将使用到的第三方模块提取到一个单独的文件，这个文件包含了项目的基础运行环境，一般称为vendors.js；在抽离第三方模块后我们将每个页面都依赖的公共代码提取出来，放到common.js中。 12345678910111213141516171819module.exports = &#123; optimization: &#123; splitChunks: &#123; chunks: &#x27;initial&#x27;, cacheGroups: &#123; vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, priority: 10, name: &#x27;vendors&#x27; &#125;, common: &#123; test: /[\\\\/]src[\\\\/]/, priority: 5, name: &#x27;common&#x27; &#125; &#125; &#125; &#125;&#125; 有时候项目依赖模块比较多，vendors.js文件会特别大，我们还可以对它进一步拆分，按照模块划分： 1234567891011121314151617181920212223&#123; //省略其他配置 cacheGroups: &#123; //涉及vue的模块 vue: &#123; test: /[\\\\/]node_modules[\\\\/](vue|vuex|vue-router)/, priority: 10, name: &#x27;vue&#x27; &#125;, //其他模块 vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, priority: 9, name: &#x27;vendors&#x27; &#125;, common: &#123; test: /[\\\\/]src[\\\\/]/, priority: 5, name: &#x27;common&#x27; &#125; &#125;&#125; 动态链接DllPlugin DLL即动态链接库（Dynamic-Link Library）的缩写，熟悉Windows系统的童鞋在电脑中也经常能看到后缀是dll的文件，偶尔电脑弹框警告也是因为电脑中缺失了某些dll文件；DLL最初用于节约应用程序所需的磁盘和内存空间，当多个程序使用同一个函数库时，DLL可以减少在磁盘和内存中加载代码的重复量，有助于代码的复用。 在Webpack中也引入了DLL的思想，把我们用到的模块抽离出来，打包到单独的动态链接库中去，一个动态链接库中可以有多个模块；当我们在多个页面中用到某一个模块时，不再重复打包，而是直接去引入动态链接库中的模块。 Webpack中集成了对动态链接库的支持，主要用到的两个插件： DllPlugin：创建动态链接库文件 DllReferencePlugin：在主配置中引入打包好的动态链接库文件 我们首先使用DllPlugin来创建动态链接库文件，在项目下新建webpack.dll.js文件： 1234567891011121314151617181920212223const path = require(&quot;path&quot;);const webpack = require(&quot;webpack&quot;);module.exports = &#123; mode: &quot;production&quot;, entry: &#123; vue: [&quot;vue&quot;, &quot;vuex&quot;, &quot;vue-router&quot;], vendor: [&quot;dayjs&quot;, &quot;axios&quot;, &quot;mint-ui&quot;], &#125;, output: &#123; path: path.resolve(__dirname, &quot;public/vendor&quot;), // 指定文件名 filename: &quot;[name].dll.js&quot;, //暴露全局变量的名称 library: &quot;[name]_dll_lib&quot;, &#125;, plugins: [ new webpack.DllPlugin(&#123; path: path.join(__dirname, &quot;public&quot;, &quot;vendor&quot;, &quot;[name].manifest.json&quot;), name: &quot;[name]_dll_lib&quot;, &#125;), ],&#125;; 这里entry设置了多个入口，每个入口也有多个模块文件；然后在package.json添加打包命令 12345&#123; &quot;scripts&quot;:&#123; &quot;build:dll&quot;: &quot;webpack --config=webpack.dll.js&quot; &#125;&#125; 执行npm run build:dll后，我们在/public/vendor目录下得到了我们打包后的动态链接库的文件： 1234├── vendor.dll.js├── vendor.manifest.json├── vue.dll.js└── vue.manifest.json 生成出来的打包文件正好是以两个入口名来命名的，以vue为例，看一下vue.dll.js的内容： 12345678910111213141516171819202122var vue_dll_lib =/******/ (function(modules) &#123; // 省略webpackBootstrap代码/******/ &#125;)/******/ (&#123;/***/ &quot;./node_modules/vue-router/dist/vue-router.esm.js&quot;:/***/ (function(module, exports, __webpack_require__) &#123; //省略vue-router模块代码/***/ &#125;),/***/ &quot;./node_modules/vue/dist/vue.runtime.esm.js&quot;:/***/ (function(module, exports, __webpack_require__) &#123; //省略vue模块代码/***/ &#125;),/***/ &quot;./node_modules/vuex/dist/vuex.esm.js&quot;:/***/ (function(module, exports, __webpack_require__) &#123; //省略vuex模块代码/***/ &#125;),/******/ &#125;); 可以看出，动态链接库中包含了引入模块的所有代码，这些代码存在一个对象中，通过模块路径作为键名来进行引用；并且通过vue_dll_lib暴露到全局；vue.manifest.json则是用来描述动态链接库文件中包含了哪些模块： 1234567891011121314151617&#123; &quot;name&quot;: &quot;vue_dll_lib&quot;, &quot;content&quot;: &#123; &quot;./node_modules/vue-router/dist/vue-router.esm.js&quot;: &#123; &quot;id&quot;: &quot;./node_modules/vue-router/dist/vue-router.esm.js&quot;, &quot;buildMeta&quot;: &#123;&#125; &#125;, &quot;./node_modules/vue/dist/vue.runtime.esm.js&quot;: &#123; &quot;id&quot;: &quot;./node_modules/vue/dist/vue.runtime.esm.js&quot;, &quot;buildMeta&quot;: &#123;&#125; &#125;, &quot;./node_modules/vuex/dist/vuex.esm.js&quot;: &#123; &quot;id&quot;: &quot;./node_modules/vuex/dist/vuex.esm.js&quot;, &quot;buildMeta&quot;: &#123;&#125; &#125;, &#125;&#125; manifest.json描述了对应js文件包含哪些模块，以及对应模块的键名（id），这样我们在模板页面中就可以将动态链接库作为外链引入，当Webpack解析到对应模块时就通过全局变量来获取模块： 123456789101112131415&lt;!-- public/index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;!-- 引入动态链接库 --&gt; &lt;script src=&quot;./vendor/vendor.dll.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./vendor/vue.dll.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 最后我们在打包时，通过DllReferencePlugin将动态链接库引入到主配置中： 12345678910111213//webpack.config.js&#123; plugins: [ new webpack.DllReferencePlugin(&#123; context: path.join(__dirname), manifest: require(&#x27;./public/vendor/vendor.manifest.json&#x27;) &#125;), new webpack.DllReferencePlugin(&#123; context: path.join(__dirname), manifest: require(&#x27;./public/vendor/vue.manifest.json&#x27;) &#125;), ]&#125; 注：动态链接库打包到/public/vendor目录下，还需要通过CopyWebpackPlugin插件将它拷贝到生成后的目录中，否则会出现引用失败的报错；打包动态链接库文件只需要执行一次，除非以后模块升级或者引入新的模块。 引入动态链接库可以将项目中一些不经常更新的模块放到外部文件中，我们再次打包页面逻辑代码时会发现构建速度有了比较大的提升，大概30%~40%，相关代码在demo10。 externals 我们在项目打包时，有一些第三方的库会从CDN引入（比如jQuery等），如果在bundle中再次打包项目就过于臃肿，我们就可以通过配置externals将这些库在打包的时候排除在外。 12345678&#123; externals: &#123; &#x27;jquery&#x27;: &quot;jQuery&quot;, &#x27;react&#x27;: &#x27;React&#x27;, &#x27;react-dom&#x27;: &#x27;ReactDOM&#x27;, &#x27;vue&#x27;: &#x27;Vue&#x27; &#125;&#125; 这样就表示当我们遇到require(&#39;jquery&#39;)时，从全局变量去引用jQuery，其他几个包也同理；这样打包时就把jquery、react、vue和react-dom从bundle中剔除了，本实例完整代码demo。 Tree Shaking Tree Shaking最早由rollup实现，后来webpack2页实现了这项功能；Tree Shaking的字面意思是摇树，一棵树上有一些树叶虽然还挂着，但是它可能已经死掉了，通过摇树方式把这些死掉的树叶去除。 我们项目中也是同样的，我们并没有用到文件的所有模块，但是webpack仍会将整个文件打包进来，文件中一直用不到的代码就是“死代码”；这种情况就用用到Tree Shaking帮我们剔除这些用不到的代码模块。 比如我们定义了一个utils.js文件导出了很多工具模块，然后在index.js中只引用了某些模块： 123456789101112131415//utils.jsvar toString = Object.prototype.toString;export function isArray(val) &#123; return toString.call(val) === &#x27;[object Array]&#x27;;&#125;export function isFunction(val) &#123; return toString.call(val) === &#x27;[object Function]&#x27;;&#125;export function isDate(val) &#123; return toString.call(val) === &#x27;[object Date]&#x27;;&#125;//index.jsimport &#123; isArray &#125; from &#x27;./utils&#x27;isArray() 我们希望在代码中只打包isArray函数到bundle中；需要注意的是，为了让Tree Shaking生效，我们需要使用ES6模块化的语法，因为ES6模块语法是静态化加载模块，它有以下特点： 静态加载模块，效率比CommonJS 模块的加载方式高 ES6 模块是编译时加载，使得静态分析成为可能进一步拓宽JS的语法 如果是require，在运行时确定模块，那么将无法去分析模块是否可用，只有在编译时分析，才不会影响运行时的状态。 使用ES6模块后还有一个问题，因为我们的代码一般都采用babel进行编译，而babel的preset默认会将任何模块类型编译成Commonjs，因此我们还需要修改.babelrc配置文件： 1234567891011&#123; &quot;presets&quot;: [ [ &quot;@babel/preset-env&quot;, &#123; //添加modules：false &quot;modules&quot;: false &#125; ] ]&#125; 配置好babel后我们需要让webpack先将“死代码”标识出来： 1234567&#123; //其他配置 optimization: &#123; usedExports: true, sideEffects: true, &#125;&#125; 运行打包命令后，当我们打开输出的bundle文件时，我们发现虽然一些“死代码”还存在里面，但是加上了一个unused harmony export的标识 123456789/* unused harmony export isFunction *//* unused harmony export isDate */var toString = Object.prototype.toString;function isFunction(val) &#123; return toString.call(val) === &#x27;[object Function]&#x27;;&#125;function isDate(val) &#123; return toString.call(val) === &#x27;[object Date]&#x27;;&#125; 虽然webpack给我们指出了哪些函数用不上，但是还需要我们通过插件来剔除；由于uglifyjs-webpack-plugin不支持ES6语法，这里我们使用terser-webpack-plugin的插件来代替它： 123456789101112131415const TerserJSPlugin = require(&quot;terser-webpack-plugin&quot;);module.exports = &#123; optimization: &#123; usedExports: true, sideEffects: true, minimize: true, minimizer: [ new TerserJSPlugin(&#123; cache: true, parallel: true, sourceMap: false, &#125;), ], &#125;&#125; 这样我们发现打包出来的文件就没有多余的代码了。 注： Tree Shaking在生产环境（production）是默认开启的 对于我们常用的一些第三方模块，我们也可以实现Tree Shaking；以lodash为例，它整个包有非常多的函数，但并不是所有的函数都是我们所用到的，因此我们也需要对它没有用到的代码进行剔除。 123//index.jsimport &#123; chunk &#125; from &#x27;lodash&#x27;console.log(chunk([1,2,3,4], 2)) 打包出来发现包的大小还是能达到70+kb，如果只引用了chunk不应该有这么大；我们打开/node_modules/lodash/index.js发现他还是使用了require的模式导入导出模块，因此导致Tree Shaking失败；我们先安装使用ES6模块版本的lodash：npm i -S lodash-es，然后修改引入包： 123//index.jsimport &#123; chunk &#125; from &#x27;lodash-es&#x27;console.log(chunk([1,2,3,4], 2)) 这样我们生成的bundle包就小很多；本实例完整代码demo。 缓存 我们知道webpack会对不同的文件调用不同的loader进行解析处理，解析的过程也是最耗性能的过程；我们每次改代码也只是修改项目中的少数文件，项目中的大部分文件改动的次数不是那么频繁；那么如果我们将解析文件的结果缓存下来，下次发现同样的文件只需要读取缓存就能极大的提升解析的性能。 cache-loader cache-loader可以将一些对性能消耗比较大的loader生产的结果缓存在磁盘中，等下次再次打包时如果是相同的代码就可以直接读取缓存，减少性能消耗。 注：保存和读取缓存也会产生额外的性能开销，因此cache-loader适合用于对性能消耗较大的loader，否则反而会增加性能消耗 cache-loader的使用也非常简单，安装后在所需要缓存的loader前面添加即可（因为loader加载的顺序是反向的），比如我们需要给babel-loader添加缓存： 12345678910111213141516&#123; //省略其他代码 rules: [ &#123; test: /\\.js/, use: [ &#123; loader: &#x27;cache-loader&#x27; &#125;, &#123; loader: &quot;babel-loader&quot;, &#125;, ], &#125;, ],&#125; 然而我们发现第一次打包的速度并没有发生明显变化，甚至可能还比原来打包的更慢了；同时还多了/node_modules/.cache/cache-loader/这个目录，看名字就是一个缓存文件；我们继续打包，下面图表记录了我几次打包的耗时： 我们发现第一次打包时间都差不多，但是第二次开始缓存文件就开始发挥了重要的作用了，直接减少了75%的耗时。 除了使用cache-loader，babel-loader也提供缓存功能，通过cacheDirectory进行配置： 123456789101112131415&#123; rules: [ &#123; test: /\\.js/, use: [ &#123; loader: &quot;babel-loader&quot;, options: &#123; cacheDirectory: true &#125; &#125;, ], &#125;, ],&#125; 在/node_modules/.cache/babel-loader也多了缓存文件。经过两个使用结果的对比，cache-loader的性能提升更加出色一些；本实例完整代码demo。 HardSourceWebpackPlugin HardSourceWebpackPlugin也可以为模块提供缓存功能，同意也是将文件缓存在磁盘中 首先通过npm i -D hard-source-webpack-plugin来安装插件，并且在配置中添加插件： 1234567var HardSourceWebpackPlugin = require(&#x27;hard-source-webpack-plugin&#x27;);module.exports = &#123; plugins: [ new HardSourceWebpackPlugin() ]&#125; 一般HardSourceWebpackPlugin默认缓存是在/node_modules/.cache/hard-source/[hash]目录下，我们可以设置它的缓存目录和何时创建新的缓存哈希值。 1234567891011121314151617181920212223242526272829module.exports = &#123; plugins: [ new HardSourceWebpackPlugin(&#123; //设置缓存目录的路径 //相对路径或者绝对路径 cacheDirectory: &#x27;node_modules/.cache/hard-source/[confighash]&#x27;, //构建不同的缓存目录名称 //也就是cacheDirectory中的[confighash]值 configHash: function(webpackConfig) &#123; return require(&#x27;node-object-hash&#x27;)(&#123;sort: false&#125;).hash(webpackConfig); &#125;, //环境hash //当loader、plugin或者其他npm依赖改变时进行替换缓存 environmentHash: &#123; root: process.cwd(), directories: [], files: [&#x27;package-lock.json&#x27;, &#x27;yarn.lock&#x27;], &#125;, //自动清除缓存 cachePrune: &#123; //缓存最长时间（默认2天） maxAge: 2 * 24 * 60 * 60 * 1000, //所有的缓存大小超过size值将会被清除 //默认50MB sizeThreshold: 50 * 1024 * 1024 &#125;, &#125;) ]&#125; 通过尝试多次打包，发现能节省大概90%的时间；本实例完整代码demo。 多进程 我们在事件循环中讲到过，js是一门单线程的语言，在同一事件线上只有一个线程在处理任务；因此在webpack解析到JS、CSS、图片或者字体文件时，它需要一个个的去解析编译，不能同时处理多个任务；我们可以通过插件来将任务分给多个子进程去并发执行，子进程处理完成后再将结果发送给主进程。 happypack happypack会自动帮我们分解任务和管理进程，通过名字我们也能看出来，这是一款能够带来快乐的插件。 我们通过npm i -D happypack后就能在webpack中进行配置了： 123456789101112131415161718192021222324252627const happypack = require(&quot;happypack&quot;);module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.js/, exclude: /node_modules/, //将js文件处理给id为js的happypack实例 use: &quot;happypack/loader?id=js&quot;, &#125; ], &#125;, plugins: [ //通过id标识当前happypack是处理什么文件的 new happypack(&#123; id: &quot;js&quot;, //调用处理文件的loader，用法和rules中一致 loaders: [&#123; loader: &quot;babel-loader&quot;, &#125;, &#123; loader: &quot;eslint-loader&quot;, &#125;, ], &#125;), ],&#125; 我们将rules/loader的处理全部交给了happypack进行处理，并且通过id来调用具体的实例，然后在实例中配置具体的loader进行处理；在happypack的实例中除了id和loaders我们还可以配置进程数量： 123456789101112131415161718192021222324//共享进程池，进程池中包含5个子进程var happyThreadPool = happypack.ThreadPool(&#123; size: 5&#125;);&#123; plugins: [ new happypack(&#123; id: &quot;js&quot;, //开启几个子进程，默认3个 threads: 3, //共享进程池 threadPool: happyThreadPool, //是否允许 HappyPack 输出日志 verbose: true, loaders: [&#123; loader: &quot;babel-loader&quot;, &#125;, &#123; loader: &quot;eslint-loader&quot;, &#125;, ], &#125;), ],&#125; 注：threads和threadPool字段只需要配置一个即可。 我们通过happypack.ThreadPool创建了一个包含5个子进程的共享进程池，每个happypack实例可以通过共享进程池来处理文件；相对于给每个happypack实例分配进程，这样可以防止占用过多无用的进程；我们打包看一下所耗时间： 我们发现有了happypack耗时居然还增加了20%~30%，说好的多进程带来快乐呢。 由于我们的项目不够庞大，而加载多进程也需要耗费时间和性能，因此我们才会出现使用了happypack反而增加耗时的情况；所以一般happypack适用于比较大的项目中；本实例完整代码demo。 thread-loader 把thread-loader放置在其他loader之前，在它之后的loader就会在一个单独的进程池中运行，但是在进程池中运行的loader有以下限制： 这些 loader 不能产生新的文件。 这些 loader 不能使用定制的 loader API（也就是说，通过插件）。 这些 loader 无法获取 webpack 的选项设置。 因此，也就是说像MiniCssExtractPlugin.loader等一些提取css的loader是不能使用thread-loader的；跟happypack一样，它也只适合用于文件较多的大项目： 12345678910111213module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.js$/, use: [ &quot;thread-loader&quot;, &quot;babel-loader&quot; ] &#125; ] &#125;&#125; 本实例完整代码demo。","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"打包工具","slug":"PackTool","permalink":"http://xieyufei.com/tags/PackTool/"},{"name":"Webpack","slug":"Webpack","permalink":"http://xieyufei.com/tags/Webpack/"}]},{"title":"深入学习Axios源码（构建配置）","date":"2020-07-18T10:56:39.000Z","path":"2020/07/18/Axios-One.html","text":"axios是我们日常代码中常用的一个http库，它可以用来在浏览器或者node.js中发起http请求；它强大的功能和简单易用的API受到了广大前端童鞋们的青睐；那么它内部是如何来实现的呢，让我们走进它的源码世界一探究竟。 首先来看一下axios有哪些特性： 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF axios的大致处理流程如下： 多种请求方式 axios除了以上的特性，还支持了多种请求方式，方便我们通过不同的方式来请求。 第一种方式axios(option)。 123456axios(&#123; url, method, headers, data&#125;) 第二种方式axios(url[, config])。 12345axios(&#x27;/api/list&#x27;, &#123; method, headers, data&#125;) 第三种方式axios.request(url?,option)，第三种方式同第一种方式本质上一样。 123456axios.request(&#123; url, method, headers, data&#125;) 第四种方式axios.request(url,option)，第四种方式同第三种方式本质上一样。 12345axios.request(url, &#123; method, headers, data&#125;) 第五种方式axios[method](url,option)，这种请求方式主要针对get、delete、head、options方法。 1234axios.get(url,&#123; headers, params&#125;) 第六种方式axios[method](url,data,option)，这种请求方式主要针对post、put、patch方法。 123axios.post(url, data, &#123; headers,&#125;) 这六种请求方式也是我们常见的方式；我们发现前两种请求方式axios作为一个函数直接来请求，而后面四种方式axios则是一个对象；因此我们猜测，axios首先肯定是一个函数，这个函数上又挂载了request、get、post等函数方便我们具体调用某个方法。 目录结构 看代码前先来看一下项目的整体结构 123456789101112131415161718├── /dist/ # 项目输出目录├── /lib/ # 项目源码目录│ ├── /cancel/ # 定义取消功能│ ├── /core/ # 一些核心功能│ │ ├── Axios.js # axios的核心主类│ │ ├── dispatchRequest.js # 用来调用http请求适配器方法发送请求│ │ ├── InterceptorManager.js # 拦截器构造函数│ │ └── settle.js # 根据http响应状态，改变Promise的状态│ ├── /helpers/ # 一些辅助方法│ ├── /adapters/ # 定义请求的适配器 xhr、http│ │ ├── http.js # 实现http适配器│ │ └── xhr.js # 实现xhr适配器│ ├── axios.js # 对外暴露接口│ ├── defaults.js # 默认配置 │ └── utils.js # 公用工具├── package.json # 项目信息├── index.d.ts # 配置TypeScript的声明文件└── index.js # 入口文件 可以发现，我们需要用到的代码大多在/lib目录下。 工具函数 看源码之前我们首先来学习一下axios用到的几个易于混淆的工具函数，以及它们具体是用来实现什么功能的。 bind bind函数用来给某一函数指定调用时的上下文，其源码如下： 12345678910//lib/helpers/bind.jsmodule.exports = function bind(fn, thisArg) &#123; return function wrap() &#123; var args = new Array(arguments.length); for (var i = 0; i &lt; args.length; i++) &#123; args[i] = arguments[i]; &#125; return fn.apply(thisArg, args); &#125;;&#125;; 它的实现效果同Function.prototype.bind 1234567891011121314import bind from &#x27;/lib/helpers/bind.js&#x27;var obj = &#123; name: &#x27;hello&#x27;&#125;function showName() &#123; console.log(this.name)&#125;var instance = bind(showName, obj)//效果同下//var instance = showName.bind(obj)instance() forEach forEach用来遍历对象或者数组；我们知道对象需要for in遍历，而数组用for循环遍历，forEach将两者遍历的方式整合到一起，其源码如下： 12345678910111213141516171819202122//lib/utils.jsfunction forEach(obj, fn) &#123; if (obj === null || typeof obj === &#x27;undefined&#x27;) &#123; return; &#125; //兼容不是数组对象的情况 //如果是基本数据类型同样放到数组中遍历 if (typeof obj !== &#x27;object&#x27;) &#123; obj = [obj]; &#125; if (isArray(obj)) &#123; for (var i = 0, l = obj.length; i &lt; l; i++) &#123; fn.call(null, obj[i], i, obj); &#125; &#125; else &#123; for (var key in obj) &#123; if (Object.prototype.hasOwnProperty.call(obj, key)) &#123; fn.call(null, obj[key], key, obj); &#125; &#125; &#125;&#125; 可以看出forEach对字符串或者数字等基本数据类型做了兼容，对数组和对象做了不同的遍历处理；其中如果遍历的是对象，回调函数每次返回对象的值、键以及对象本身。 123456import &#123; forEach &#125; from &#x27;/lib/utils.js&#x27;forEach([1,2],(elem, index, array)=&gt;&#123;&#125;)forEach(&#123; name: &#x27;hi&#x27;, age: 18&#125;,(value, key, object)=&gt;&#123;&#125;) extend extend将一个对象b上面所有的属性和方法扩展到另一个对象a上，并且指定方法调用的上下文，其源码如下： 1234567891011//lib/utils.jsfunction extend(a, b, thisArg) &#123; forEach(b, function assignValue(val, key) &#123; if (thisArg &amp;&amp; typeof val === &#x27;function&#x27;) &#123; a[key] = bind(val, thisArg); &#125; else &#123; a[key] = val; &#125; &#125;); return a;&#125; 这里forEach就用来遍历对象了；a是目标对象，b是源对象，thisArg是执行上下文，我们可以通过代码尝试一下： 123456789101112131415161718192021import &#123; extend &#125; from &#x27;/lib/utils.js&#x27;var context = &#123; name: &#x27;context&#x27;&#125;var target = &#123; name: &#x27;target&#x27;, say() &#123; console.log(&#x27;i am target,my name is &#x27; + this.name) &#125;&#125;var source = &#123; name: &#x27;source&#x27;, say() &#123; console.log(&#x27;i am source,my name is &#x27; + this.name) &#125;&#125;extend(target, source, context)//sourcetarget.name//i am source,my name is contexttarget.say() 最后运行可以发现source对象上的属性方法都赋值到target对象上，执行上下文是context对象了。 merge merge函数用来将多个对象深度合并为一个新的对象，其源码如下： 1234567891011121314151617181920//lib/utils.jsfunction merge(/* obj1, obj2, obj3, ... */) &#123; var result = &#123;&#125;; function assignValue(val, key) &#123; if (isPlainObject(result[key]) &amp;&amp; isPlainObject(val)) &#123; result[key] = merge(result[key], val); &#125; else if (isPlainObject(val)) &#123; result[key] = merge(&#123;&#125;, val); &#125; else if (isArray(val)) &#123; result[key] = val.slice(); &#125; else &#123; result[key] = val; &#125; &#125; for (var i = 0, l = arguments.length; i &lt; l; i++) &#123; forEach(arguments[i], assignValue); &#125; return result;&#125; isPlainObject判断一个对象是否是一个JS原生对象，即使用Object构造函数创建的对象；如果是对象的话就进行深度的合并，我们写一个demo测试一下： 1234567891011121314151617181920212223242526import &#123; merge &#125; from &#x27;/lib/utils.js&#x27;var obj1 = &#123; a:1, b: &#123; b1:1, b2:2 &#125;&#125;var obj2 = &#123; a:2 b: &#123; b1:4, b3:5 &#125;,&#125;var newObj = merge(obj1, obj2)//最后结果//&#123;// a:2,// b: &#123;// b1:4,// b2:2,// b3:5// &#125;//&#125; 构造实例 介绍完了工具函数我们就真正的进入axios的核心源码部分；首先在index.js中，我们看到通过module.exports = require(&#39;./lib/axios&#39;);导出了axios，因此我们找到/lib/axios文件： 12345678910111213141516171819202122//省略部分代码///lib/axios.jsvar Axios = require(&#x27;./core/Axios&#x27;);var utils = require(&#x27;./utils&#x27;);var bind = require(&#x27;./helpers/bind&#x27;);//默认配置var defaults = require(&#x27;./defaults&#x27;);function createInstance(defaultConfig) &#123; //创建axios实例 var context = new Axios(defaultConfig); //将instance指向Axios.prototype.request函数 var instance = bind(Axios.prototype.request, context); //将Axios.prototype上的属性和方法扩展到instance上 utils.extend(instance, Axios.prototype, context); //将context上的属性和方法扩展到instance上 utils.extend(instance, context); return instance;&#125;var axios = createInstance(defaults);module.exports = axios; 这段代码看上去比较绕，不过我们发现核心部分就是通过createInstance创建了一个axios实例对象，创建的同时传入了defaultConfig对象（根据名字我们也能猜出来这是默认配置），然后将实例对象导出；因此createInstance创建的就是我们使用的那个axios函数。 由于createInstance创建是通过Axios构造函数创建的，因此我们把createInstance放一放，先看一下Axios构造函数做了哪些操作： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var utils = require(&#x27;./../utils&#x27;);var buildURL = require(&#x27;../helpers/buildURL&#x27;);var InterceptorManager = require(&#x27;./InterceptorManager&#x27;);var dispatchRequest = require(&#x27;./dispatchRequest&#x27;);var mergeConfig = require(&#x27;./mergeConfig&#x27;);function Axios(instanceConfig) &#123; //默认配置 this.defaults = instanceConfig; //拦截器 this.interceptors = &#123; request: new InterceptorManager(), response: new InterceptorManager() &#125;;&#125;Axios.prototype.request = function request(config) &#123; //兼容axios.request(url,config)的情况 if (typeof config === &#x27;string&#x27;) &#123; config = arguments[1] || &#123;&#125;; config.url = arguments[0]; &#125; else &#123; config = config || &#123;&#125;; &#125; config = mergeConfig(this.defaults, config); var promise = Promise.resolve(config); //省略部分发送请求的代码 return promise;&#125;;utils.forEach([&#x27;delete&#x27;, &#x27;get&#x27;, &#x27;head&#x27;, &#x27;options&#x27;], function forEachMethodNoData(method) &#123; Axios.prototype[method] = function(url, config) &#123; return this.request(mergeConfig(config || &#123;&#125;, &#123; method: method, url: url &#125;)); &#125;;&#125;);utils.forEach([&#x27;post&#x27;, &#x27;put&#x27;, &#x27;patch&#x27;], function forEachMethodWithData(method) &#123; Axios.prototype[method] = function(url, data, config) &#123; return this.request(mergeConfig(config || &#123;&#125;, &#123; method: method, url: url, data: data &#125;)); &#125;;&#125;);module.exports = Axios; Axios构造函数仅仅做了两个事，一个是将默认配置保存到defaults，另一个则是构造了interceptors拦截器对象；Axios函数在原型对象上还挂载了request、get、post等函数，但是get、post等函数最终都是通过request函数来发起请求的。而且request函数最终返回了一个Promise对象， 因此我们才能通过then函数接收到请求结果。对原型链不了解的童鞋可以看这篇文章一文读懂JS中类、原型和继承。 了解了Axios构造函数的本质，让我们再回到createInstance函数： 1234567function createInstance(defaultConfig) &#123; var context = new Axios(defaultConfig); var instance = bind(Axios.prototype.request, context); utils.extend(instance, Axios.prototype, context); utils.extend(instance, context); return instance;&#125; 我们发现Axios构造出了实例对象context，然而createInstance并不是直接返回了context对象；这是因为上面我们也说了axios是一个函数，然而context是对象，返回对象的话是并不能直接调用的，那怎么办呢？ 我们在Axios源码中发现，真正调用的是Axios原型链上的request方法；因此导出的axios需要关联到request方法，这里巧妙的通过bind函数进行关联，生成关联后的instance函数，同时指定它的调用上下文就是Axios的实例对象，因此instance调用时也能获取到实例对象上的defaults和interceptors属性；但是仅仅关联request还不够，再通过extend函数将Axios原型对象上的所有get、post等函数扩展到instance函数上，因此这也是我们才能够使用多种方式调用的原因所在。 同时，如果我们需要创建多个axios实例，但是某几个axios实例的配置（用了同样的域名等）是一样的，我们不希望每次都要写重复的配置，axios还提供了另一种创建实例模板的方式： 1234567const instance = axios.create(&#123; baseURL: &#x27;https://some-domain.com/api/&#x27;, timeout: 1000, headers: &#123;&#x27;X-Custom-Header&#x27;: &#x27;foobar&#x27;&#125;&#125;);instance.get(&#x27;/list&#x27;)instance.post(&#x27;/add&#x27;) 通过create函数创建了一个有默认配置的实例，这样我们只需要愉快的调用axios的API方法即可；需要请求其他域名只需要再次create即可，这也是工厂模式的一种体现，它的源码实现也很简单，也是通过createInstance创建一个合并配置后的实例： 123axios.create = function create(instanceConfig) &#123; return createInstance(mergeConfig(axios.defaults, instanceConfig));&#125;; 配置合并 实例对象创建好之后，我们就需要把配置进行合并，方便后面发送请求。在看源码前，我们发现上面代码中主要有两种config，一种是defaultConfig，即默认配置，在构造实例的时候传入；另一种是userConfig，也就是我们调用实例进行请求时传入的配置；在上面的代码中，也出现了很多次mergeConfig这个函数，根据命名我们也能看出来，这是用来合并两种配置的。 默认配置 首先让我们看一下axios给我们默认配置了哪些属性： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//lib/defaultsvar utils = require(&#x27;./utils&#x27;);var DEFAULT_CONTENT_TYPE = &#123; &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;&#125;;function getDefaultAdapter() &#123; var adapter; if (typeof XMLHttpRequest !== &#x27;undefined&#x27;) &#123; //浏览器环境使用xhr adapter = require(&#x27;./adapters/xhr&#x27;); &#125; else if (typeof process !== &#x27;undefined&#x27; &amp;&amp; Object.prototype.toString.call(process) === &#x27;[object process]&#x27;) &#123; //node环境使用http adapter = require(&#x27;./adapters/http&#x27;); &#125; return adapter;&#125;var defaults = &#123; adapter: getDefaultAdapter(), transformRequest: [function transformRequest(data, headers) &#123; //省略转换请求数据代码 return data; &#125;], transformResponse: [function transformResponse(data) &#123; if (typeof data === &#x27;string&#x27;) &#123; try &#123; data = JSON.parse(data); &#125; catch (e) &#123; /* Ignore */ &#125; &#125; return data; &#125;], timeout: 0, xsrfCookieName: &#x27;XSRF-TOKEN&#x27;, xsrfHeaderName: &#x27;X-XSRF-TOKEN&#x27;, maxContentLength: -1, maxBodyLength: -1, validateStatus: function validateStatus(status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; &#125;&#125;;defaults.headers = &#123; common: &#123; &#x27;Accept&#x27;: &#x27;application/json, text/plain, */*&#x27; &#125;&#125;;utils.forEach([&#x27;delete&#x27;, &#x27;get&#x27;, &#x27;head&#x27;], function forEachMethodNoData(method) &#123; defaults.headers[method] = &#123;&#125;;&#125;);utils.forEach([&#x27;post&#x27;, &#x27;put&#x27;, &#x27;patch&#x27;], function forEachMethodWithData(method) &#123; defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);&#125;);module.exports = defaults; 可以发现，axios定义了默认的适配器（用于发送请求）、转换器（转换请求和响应数据）和请求头等一些数据；getDefaultAdapter函数用来获取默认的适配器，这样在浏览器端和node环境都可以发送请求；可以看到axios给每个请求方法都定义了一个默认的请求头和一个公共的请求头common，在后面发送请求时会根据传入的请求方法类型使用相应的请求头。 属性分类 下面我们就来看一下mergeConfig是如何将两种config合并的；首先mergeConfig将所有config中用到的字段进行了划分，分成了三类： 没有初始值，其值必须由初始化的时候指定 需要合并的属性，这些属性一般都是对象，处理时需要将对象进行合并 普通属性，这些属性一般都是值类型，如果userConfig中有，则以userConfig为准；没有取defaultConfig的值 1234567891011121314151617181920//可以把config1看做defaultConfig,config2看做userConfigmodule.exports = function mergeConfig(config1, config2) &#123; config2 = config2 || &#123;&#125;; //最终返回合并后的配置 var config = &#123;&#125;; //第一种属性 var valueFromConfig2Keys = [&#x27;url&#x27;, &#x27;method&#x27;, &#x27;data&#x27;]; //第二种属性 var mergeDeepPropertiesKeys = [&#x27;headers&#x27;, &#x27;auth&#x27;, &#x27;proxy&#x27;, &#x27;params&#x27;]; //第三种属性 var defaultToConfig2Keys = [ &#x27;baseURL&#x27;, &#x27;transformRequest&#x27;, &#x27;transformResponse&#x27;, &#x27;paramsSerializer&#x27;, &#x27;timeout&#x27;, &#x27;timeoutMessage&#x27;, &#x27;withCredentials&#x27;, &#x27;adapter&#x27;, &#x27;responseType&#x27;, &#x27;xsrfCookieName&#x27;, &#x27;xsrfHeaderName&#x27;, &#x27;onUploadProgress&#x27;, &#x27;onDownloadProgress&#x27;, &#x27;decompress&#x27;, &#x27;maxContentLength&#x27;, &#x27;maxBodyLength&#x27;, &#x27;maxRedirects&#x27;, &#x27;transport&#x27;, &#x27;httpAgent&#x27;, &#x27;httpsAgent&#x27;, &#x27;cancelToken&#x27;, &#x27;socketPath&#x27;, &#x27;responseEncoding&#x27; ]; var directMergeKeys = [&#x27;validateStatus&#x27;]; //省略下面代码&#125; 对于第一种属性，url、method和data不能从默认配置中取值，因此如果userConfig中有就直接取userConfig中的值。 123456789101112131415function getMergedValue(target, source) &#123; if (utils.isPlainObject(target) &amp;&amp; utils.isPlainObject(source)) &#123; return utils.merge(target, source); &#125; else if (utils.isPlainObject(source)) &#123; return utils.merge(&#123;&#125;, source); &#125; else if (utils.isArray(source)) &#123; return source.slice(); &#125; return source;&#125;utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) &#123; if (!utils.isUndefined(config2[prop])) &#123; config[prop] = getMergedValue(undefined, config2[prop]); &#125;&#125;); 对于第二种属性，如果userConfig中有，就将其与defaultConfig进行合并。 12345678function mergeDeepProperties(prop) &#123; if (!utils.isUndefined(config2[prop])) &#123; config[prop] = getMergedValue(config1[prop], config2[prop]); &#125; else if (!utils.isUndefined(config1[prop])) &#123; config[prop] = getMergedValue(undefined, config1[prop]); &#125;&#125;utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties); 对于第三种普通属性，如果userConfig中有就取userConfig，没有就取defaultConfig中的值。 1234567utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) &#123; if (!utils.isUndefined(config2[prop])) &#123; config[prop] = getMergedValue(undefined, config2[prop]); &#125; else if (!utils.isUndefined(config1[prop])) &#123; config[prop] = getMergedValue(undefined, config1[prop]); &#125;&#125;); 对于除这三种属性之外的其他属性，当做第二种属性处理，通过mergeDeepProperties函数进行整合。 1234567891011121314var axiosKeys = valueFromConfig2Keys .concat(mergeDeepPropertiesKeys) .concat(defaultToConfig2Keys) .concat(directMergeKeys);//获取不在上述三种属性的中的其他属性的数组var otherKeys = Object .keys(config1) .concat(Object.keys(config2)) .filter(function filterAxiosKeys(key) &#123; return axiosKeys.indexOf(key) === -1; &#125;);utils.forEach(otherKeys, mergeDeepProperties); 总结 axios的源码还是有很多的地方值得我们来深入学习的，比如工具函数和它如何构造实例等；我们根据axios的多种请求方式，找到了它在构造实例时巧妙的绑定方式来实现多种请求的调用，构造实例后就需要将用户传入的配置和默认的配置进行整合起来；在下一篇文章中我们会了解axios是如何使用整合后的配置来通过适配器发起请求的。","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"源码","slug":"SourceCode","permalink":"http://xieyufei.com/tags/SourceCode/"}]},{"title":"深入理解linear-gradient","date":"2020-07-10T12:48:47.000Z","path":"2020/07/10/Line-Gradient.html","text":"linear-gradient是CSS3的一个新特性；在以前实现渐变、阴影等一些酷炫效果都是通过图片来实现的，但是通过linear-gradient我们可以实现同样丰富多样的效果。 定义及语法 linear-gradient()称为线性过渡函数，用于创建一个线性渐变的图像。为了创建一个线性渐变，我们需要最少传入三个元素：渐变方向、起始点颜色和终止点颜色（可以有多个终止点）；因此，它的语法也是传入多个节点的颜色即可： background: linear-gradient(direction, color-stop1, color-stop2, …); direction表示渐变的一个方向，color-stop表示渐变方向上不同的节点；我们尝试构建一个彩虹色渐变的div： 12345.box&#123; width: 200px; height: 200px; background: linear-gradient(to bottom,red,orange,yellow,green,blue,indigo,violet);&#125; 我们定义了渐变方向上红橙黄绿青蓝紫七个节点，节点会在div上自动排列分布，节点中间的渐变部分则由浏览器自动计算绘制，因此一个彩虹div就出来了： 渐变线 在渐变容器中，穿过容器中心点和颜色停止点连接在一起的线称为渐变线. 这里的渐变线从A到B，穿过容器的中心点C；渐变线AB与容器的垂直线形成的夹角α，称为渐变角度。 在上面语法中的direction就是用来控制渐变线的方向，它可以接收两种类型的值： 方向关键词：to top、to bottom、to left、to right、to top right、to top left、to bottom right和to bottom left 使用带单位的数字定义渐变角度：例如45deg、1turn等（turn表示圈，1turn=360deg） 如果省略角度值的设置，默认direction就是to bottom，它转换成角度单位就是180deg或者0.5turn。 在上图中，没有设置direction，white至red渐变色是从上至下，它和使用to bottom方向关键词得到的效果是一致的。 另外，使用to top和0deg的效果也是一样的： 除了left、right、top和bottom，另外四个使用了顶角关键词，比如：to top right，表示从容器的一个顶角到它的对角，因此他们的角度依赖于容器的尺寸大小。 可以看出来，如果容器是一个长方形，to top right角度就不为45deg。 渐变节点 在上面demo中多个渐变节点都是浏览器自己均匀分布后计算出来的，我们可以在颜色后面显示的定义颜色在渐变色的位置；每个位置可以用百分比表示，也可以用CSS长度单位（px）来表示。 我们给每个颜色定义了自己的位置，以百分比为单位，这些单位都是以渐变线的开始位置进行计算的。 如果我们将两个渐变节点的位置重合，那么会发生什么呢？ 我们惊奇的发现之前的渐变色没了，而是分割成了不同的色块；同时我们发现两边的色块呈现梯形；在面试完50个人后我写下这篇总结中，我们通过border属性来画了三角形和梯形，因此我们可以通过linear-gradient很方便的就能画出来，这里不再演示。 其他效果 linear-gradient还有一些丰富的效果 进度条效果 这样的进度条效果我们在浏览网页的时候经常会看到，很多都是通过图片或者animate实现的，我们可以通过linear-gradient实现简单的静态效果。 123456789101112.box1 &#123; width: 600px; height: 20px; margin: 20px; border-radius: 4px; background: linear-gradient(45deg, #5BC0DF 0%, #5BC0DF 10%, #76CAE3 10%, #76CAE3 20%, #5BC0DF 20%, #5BC0DF 30%, #76CAE3 30%, #76CAE3 40%, #5BC0DF 40%, #5BC0DF 50%, #76CAE3 50%, #76CAE3 60%, #5BC0DF 60%, #5BC0DF 70%, #76CAE3 70%, #76CAE3 80%, #5BC0DF 80%, #5BC0DF 90%, #76CAE3 90%, #76CAE3 100%);&#125; 通过渐变节点前后相连接，这样一个卡通风格的进度条就完成了。 缺角效果 缺角按钮偶尔也会看到，它的实现其实很简单，将拼接部分的颜色设置为透明即可： 123456789101112131415161718.box1 &#123; width: 100px; height: 40px; line-height: 40px; margin: 40px auto; background: linear-gradient(-135deg, transparent 10px, #162e48 10px); text-align: center; color: #fff;&#125;.box2&#123; width: 100px; height: 40px; line-height: 40px; margin: 40px auto; background: linear-gradient(-45deg, transparent 10px, #162e48 10px); text-align: center; color: #fff;&#125; 开关效果 开关效果也是很多jQuery组件经常用的 1234567891011121314151617181920&lt;style&gt; .switch_box &#123; display: flex; justify-content: space-around; color: #fff; width: 144px; height: 30px; line-height: 30px; background: linear-gradient(45deg, #162e48 50%, #f00 50%); margin: 50px; &#125; .switch_box.active &#123; background: linear-gradient(45deg, #f00 50%, #162e48 50%); &#125;&lt;/style&gt;&lt;div class=&quot;switch_box active&quot;&gt; &lt;div&gt;ON&lt;/div&gt; &lt;div&gt;OFF&lt;/div&gt;&lt;/div&gt;","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"CSS","slug":"CSS","permalink":"http://xieyufei.com/tags/CSS/"}]},{"title":"如何回答面试官问的GET和POST区别这道送命题","date":"2020-06-12T04:00:00.000Z","path":"2020/06/12/Diff-Get-Post.html","text":"在面试中，GET和POST的区别也是面试官非常喜欢问的问题之一；很多童鞋也背的很熟了，GET不安全，POST安全等等，然而这些可能并不是面试官真正想听到的，那么GET和POST区别到底在哪呢？ 我们将从下面六个角度来具体剖析一下GET和POST的真正区别。 安全性角度 一般认为POST在传输数据时更加的安全，因为GET传输时将在URL中显示参数，而POST的数据则放在了请求体（body），所以更安全。 这种想法的由来多半是因为表单form数据提交时默认GET传输时会把表单中的字符拼接到URL后作为参数传送，POST传输表单数据会放在body中；当GET方式提交后会把提交的数据显示在URL上。 12345678910&lt;!-- GET提交 --&gt;&lt;form action=&quot;/api/test/get&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;password&quot;&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;!-- POST提交 --&gt;&lt;form action=&quot;/api/test/post&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;password&quot;&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;&lt;/form&gt; 两种方式提交后URL上的差别让人们觉得POST相对于GET更安全。 然而安全性的说法存在着两个问题： 抓包后POST请求也是能看到请求体（body）中的数据 HTTP规范并未规定说 GET 就不能在请求体（body）中传输数据 既然HTTP规范没有规定，那么为什么就不能传呢？我试着用axios和jQuery来在GET请求体中加入数据，无一例外的失败了；既然框架靠不住那就直接用原生的吧： 12345678910var xhr = new XMLHttpRequest();xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; console.log(xhr.responseText) &#125;&#125;xhr.open(&#x27;GET&#x27;, &#x27;/api/test/get&#x27;, true);xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;);//发送请求xhr.send(&#x27;password=123&#x27;); 我们通过express来接收一下传输的数据： 123456789101112131415//其他代码略app.get(&#x27;/api/test/get&#x27;, function(req, res)&#123; console.log(req.body, &#x27;get body&#x27;) res.json(&#123; code: 1, type: &#x27;get&#x27; &#125;)&#125;)app.post(&#x27;/api/test/post&#x27;, function(req, res)&#123; console.log(req.body, &#x27;post body&#x27;) res.json(&#123; code: 1, type: &#x27;post&#x27; &#125;)&#125;) 正当我兴奋的准备接收数据时，现实狠狠的给了我一拳： 1&#123;&#125; &#x27;get body&#x27; 浏览器并没有往请求体中存放数据，直接把send中传输的数据给丢弃了，那么GET的BODY中真的就不能放数据吗？ 答案自然是可以的，浏览器由于规范问题不会在GET的请求体中添加数据，那我们可以尝试一下通过Fiddler的Composer来添加： 这样我们就能在express中看到GET请求中的 1&#123; password: &#x27;fiddler_123456&#x27; &#125; &#x27;get body&#x27; 既然GET也能在Body中添加数据，那么POST请求数据的安全性并不是面试官期望听到的回答。 数据量角度 常见的GET和POST区别还有GET传输的数据比较少，POST传输数据多；在HTTP规范中并没有对URL的长度和传输的数据大小进行限制，但是在实际开发时，由于浏览器和服务器均对URL的长度进行了限制，因此表现出了GET传输数据少的缺点。在笔者的测试过程中，Chrome的URL长度限制比较好，基本能达到1mb的限制；而在IE11中4kb~5kb的时候浏览器就会自动将URL后的参数丢弃了。 而对于POST请求，由于数据放在请求体中，虽然理论上不会受到限制，但是实际开发中各个服务器也会对POST的数据大小进行一定的限制；比如nginx默认上传图片的大小是2mb，图片超过2mb就会提示413 Request Entity Too Large。 因此不管GET还是POST，数据传输大小都会有限制，只是POST的传输大小相对于GET来说比较大；数据量大小也并不是面试官期望听到的回答。 缓存角度 GET请求多是用来获取数据的，比如一件商品的信息、商品列表等，在一定时间内，商品的信息不会那么快的变化，因此它通常用于缓存。 而POST请求多是用于将表单数据提交到服务端，比如修改姓名、修改密码等操作，需要浏览器必须发送请求到达服务器才能进行操作，因此POST请求不能被缓存。 从上图可以看出，我们同时将GET和POST请求在浏览器中多提交几次，会发现不管多少次提交，POST请求都是200；而GET请求第一次200，后面的请求会304进行缓存下来。 编码角度 GET请求由于请求数据一般都是在URL上，所以GET一般都是URL编码；而POST请求由于请求参数的多样性，因此有多重编码方式；一般POST请求有application/x-www-form-urlencoded、multipart/form-data和application/json三种传输方式。 multipart/form-data一般在上传文件的时候通过Html5的FormData新特性来构造上传表单对象会用到这种编码方式，通过FormData上传的请求类似这样： application/x-www-form-urlencoded是Form表单的默认提交方式，这种方式的好处就是浏览器都支持；但是缺点是在请求发送前需要对数据进行序列化处理，以键值对形式，例如：key1=value1&amp;key2=value2的形式发送到服务器；如果使用jQuery的ajax方法，它内部已经对JSON格式的数据进行了序列化处理了；而使用axios默认使用application/json进行编码，或者自己通过原生Ajax请求就需要自己进行序列化。 随着JSON规范越来越流行，并且浏览器支持程度比较好，application/json编码也越来越被更多的开发者使用；通过Content-Type告诉服务器主体内容是JSON格式的字符串，服务器端就会进行解析；这样的好处是前端人员不需要关心数据结构的复杂度，只要是标准的JSON格式就能提交成功。 幂等性角度 初次看到幂等这个词很多童鞋都很陌生，我们首先来看一下幂等的定义： 在编程中，一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。 HTTP的幂等是指无论调用多少次，无论调用一次还是一千次，都具有同样的副作用。GET请求用于获取资源，不管调用多少次接口，都不会影响返回的资源；因此我们说GET请求是幂等的。 12GET /list # 获取列表GET /detail/1 # 获取详情 比如我们在获取列表数据或者获取详情数据，只是查询数据，不会影响到数据本身，也不会对资源产生副作用；因此我们认为它是幂等的。 这里有的小伙伴可能会提出疑问了，如果通过GET请求返回当前时间，那岂不是返回的结果每时每刻都不一样吗？怎么会幂等呢？ 注意，我们这里强调的是一次和N次对资源产生的副作用是相同的，而非单纯的比较结果相同。比如我们GET /news/1用来获取某个新闻，不管我们调用N次返回的都是新闻，没有产生副作用；但是新闻偶尔会更新，返回的结果可能不尽相同。 而POST请求很明显是非幂等的，因为请求多次，都会产生不同的资源。比如在支付中，我们调用POST请求，虽然我们每次就支付一块钱，但是每次必然会产生不同的订单（如果是同一个订单相信你肯定要投诉的） TCP角度get会产生一个TCP数据包，POST会产生两个TCP数据包。 get会发送http header和data给服务端，服务端返回一个200，请求成功。 post会先发送http header给服务端，告诉服务端等一下会有数据过来，服务端返回100，告诉客户端我已经准备接收数据，post在发送一个data给服务端，服务端返回200，请求成功。","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"面试","slug":"Interview","permalink":"http://xieyufei.com/tags/Interview/"}]},{"title":"Webpack配置全解析（基础篇）","date":"2020-06-06T04:00:00.000Z","path":"2020/06/06/Webpack-Learned.html","text":"Webpack凭借强大的功能，成为最流行和最活跃的打包工具，也是面试时高级程序员必须掌握的“软技能”；笔者结合在项目中的使用经验，介绍webpack的使用；本文是入门篇，主要介绍webpack的入口、输出和各种loader、plugins的使用。 本文所有的demo代码均在WebpackDemo 概念 来看一下官网对webpack的定义： 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个bundle。 首先webpack是一个静态模块打包器，所谓的静态模块，包括脚本、样式表和图片等等；webpack打包时首先遍历所有的静态资源，根据资源的引用，构建出一个依赖关系图，然后再将模块划分，打包出一个或多个bundle。再次白piao一下官网的图，生动的描述了这个过程： 提到webpack，就不得不提webpack的四个核心概念 入口(entry)：指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始 输出(output)：在哪里输出它所创建的 bundles loader：让 webpack 能够去处理那些非 JavaScript 文件 插件(plugins)：用于执行范围更广的任务 你的第一个打包器 我们首先在全局安装webpack： 1npm install webpack webpack-cli –g webpack可以不使用配置文件，直接通过命令行构建，用法如下： 1webpack &lt;entry&gt; [&lt;entry&gt;] -o &lt;output&gt; 这里的entry和output就对应了上述概念中的入口和输入，我们来新建一个入口文件： 1234//demo1/index.jsvar a = 1console.log(a)document.write(&#x27;hello webpack&#x27;) 有了入口文件我们还需要通过命令行定义一下输入路径dist/bundle.js： 1webpack index.js -o dist/bundle.js 这样webpack就会在dist目录生成打包后的文件。 我们也可以在项目目录新建一个html引入打包后的bundle.js文件查看效果。 配置文件 命令行的打包方式仅限于简单的项目，如果我们的项目较为复杂，有多个入口，我们不可能每次打包都把入口记下来；因此一般项目中都使用配置文件来进行打包；配置文件的命令方式如下： 1webpack [--config webpack.config.js] 配置文件默认的名称就是webpack.config.js，一个项目中经常会有多套配置文件，我们可以针对不同环境配置不同的文件，通过--config来进行切换： 1234//生产环境配置webpack --config webpack.prod.config.js//开发环境配置webpack --config webpack.dev.config.js 多种配置类型 config配置文件通过module.exports导出一个配置对象： 123456789101112//webpack.config.jsvar path = require(&#x27;path&#x27;);module.exports = &#123; mode: &#x27;development&#x27;, //入口文件 entry: &#x27;./index.js&#x27;, //输出目录 output: &#123; path: path.resolve(__dirname, &#x27;dist&#x27;), filename: &#x27;bundle.js&#x27; &#125;&#125;; 除了导出为对象，还可以导出为一个函数，函数中会带入命令行中传入的环境变量等参数，这样可以更方便的对环境变量进行配置；比如我们在打包线上正式环境和线上开发环境可以通过env进行区分： 123456789var path = require(&#x27;path&#x27;);//env:环境对象module.exports = function(env, argv)&#123; return &#123; //其他配置 entry: &#x27;./index.js&#x27;, output: &#123;&#125; &#125;&#125;; 另外还可以导出为一个Promise，用于异步加载配置，比如可以动态加载入口文件： 12345678910module.exports = () =&gt; &#123; return new Promise((resolve, reject)=&gt;&#123; setTimeout(()=&gt;&#123; resolve(&#123; entry: &#x27;./index.js&#x27;, output: &#123;&#125; &#125;) &#125;, 5000) &#125;)&#125; 入口 正如在上面提到的，入口是整个依赖关系的起点入口；我们常用的单入口配置是一个页面的入口： 123module.exports = &#123; entry: &#x27;./index.js&#x27;,&#125; 它是下面的简写： 12345module.exports = &#123; entry: &#123; main: &#x27;./index.js&#x27; &#125;,&#125; 但是我们一个页面可能不止一个模块，因此需要将多个依赖文件一起注入，这时就需要用到数组了，代码在demo2中： 12345678910module.exports = &#123; entry: [ //轮播图模块 &#x27;./src/banner.js&#x27;, //主模块 &#x27;./src/index.js&#x27;, //底部模块 &#x27;./src/foot.js&#x27; ],&#125; 有时候我们一个项目可能有不止一个页面，需要将多个页面分开打包，entry支持传入对象的形式，代码在demo3中： 12345678//demo3module.exports = &#123; entry: &#123; home: &#x27;./src/home.js&#x27;, list: &#x27;./src/list.js&#x27;, detail: [&#x27;./src/detail.js&#x27;, &#x27;./src/common.js&#x27;], &#125;,&#125; 这样webpack就会构建三个不同的依赖关系。 输出 output选项用来控制webpack如何输入编译后的文件模块；虽然可以有多个entry，但是只能配置一个output： 123456789module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; path: path.resolve(__dirname, &#x27;dist&#x27;), filename: &#x27;bundle.js&#x27;, //CDN地址 publicPath: &#x27;/&#x27;, &#125;,&#125; 这里我们配置了一个单入口，输出也就是bundle.js；但是如果存在多入口的模式就行不通了，webpack会提示Conflict: Multiple chunks emit assets to the same filename，即多个文件资源有相同的文件名称；webpack提供了占位符来确保每一个输出的文件都有唯一的名称： 1234567891011module.exports = &#123; entry: &#123; home: &#x27;./src/home.js&#x27;, list: &#x27;./src/list.js&#x27;, detail: [&#x27;./src/detail.js&#x27;, &#x27;./src/common.js&#x27;], &#125;, output: &#123; path: path.resolve(__dirname, &#x27;dist&#x27;), filename: &#x27;[name].bundle.js&#x27;, &#125;,&#125; 这样webpack打包出来的文件就会按照入口文件的名称来进行分别打包生成三个不同的bundle文件；还有以下不同的占位符字符串： 占位符 描述 [hash] 模块标识符(module identifier)的 hash [chunkhash] chunk 内容的 hash [name] 模块名称 [id] 模块标识符 [query] 模块的 query，例如，文件名 ? 后面的字符串 在这里引入Module、Chunk和Bundle的概念，上面代码中也经常会看到有这两个名词的出现，那么他们三者到底有什么区别呢？首先我们发现module是经常出现在我们的代码中，比如module.exports；而Chunk经常和entry一起出现，Bundle总是和output一起出现。 module：我们写的源码，无论是commonjs还是amdjs，都可以理解为一个个的module chunk：当我们写的module源文件传到webpack进行打包时，webpack会根据文件引用关系生成chunk文件，webpack 会对这些chunk文件进行一些操作 bundle：webpack处理好chunk文件后，最后会输出bundle文件，这个bundle文件包含了经过加载和编译的最终源文件，所以它可以直接在浏览器中运行。 我们通过下面一张图更深入的理解这三个概念： 总结： module，chunk 和 bundle 其实就是同一份逻辑代码在不同转换场景下的取了三个名字：我们直接写出来的是module，webpack处理时是chunk，最后生成浏览器可以直接运行的bundle。 hash、chunkhash、contenthash 理解了chunk的概念，相信上面表中chunkhash和hash的区别也很容易理解了； hash：是跟整个项目的构建相关，只要项目里有文件更改，整个项目构建的hash值都会更改，并且全部文件都共用相同的hash值。 chunkhash：跟入口文件的构建有关，根据入口文件构建对应的chunk，生成每个chunk对应的hash；入口文件更改，对应chunk的hash值会更改。 contenthash：跟文件内容本身相关，根据文件内容创建出唯一hash，也就是说文件内容更改，hash就更改。 模式 在webpack2和webpack3中我们需要手动加入插件来进行代码的压缩、环境变量的定义，还需要注意环境的判断，十分的繁琐；在webpack4中直接提供了模式这一配置，开箱即可用；如果忽略配置，webpack还会发出警告。 1234567891011121314module.exports = &#123; mode: &#x27;development&#x27;,&#125;;//相当于module.exports = &#123; devtool:&#x27;eval&#x27;, plugins: [ new webpack.NamedModulesPlugin(), new webpack.NamedChunksPlugin(), new webpack.DefinePlugin(&#123; &quot;process.env.NODE_ENV&quot;: JSON.stringify(&quot;development&quot;) &#125;) ]&#125; 开发模式是告诉webpack，我现在是开发状态，也就是打包出来的内容要对开发友好，便于代码调试以及实现浏览器实时更新。 1234567891011121314module.exports = &#123; mode: &#x27;production&#x27;,&#125;;//相当于module.exports = &#123; plugins: [ new UglifyJsPlugin(/*...*/), new webpack.DefinePlugin(&#123; &quot;process.env.NODE_ENV&quot;: JSON.stringify(&quot;production&quot;) &#125;), new webpack.optimize.ModuleConcatenationPlugin(), new webpack.NoEmitOnErrorsPlugin() ]&#125; 生产模式不用对开发友好，只需要关注打包的性能和生成更小体积的bundle。看到这里用到了很多Plugin，不用慌，下面我们会一一解释他们的作用。 相信很多童鞋都曾有过疑问，为什么这边DefinePlugin定义环境变量的时候要用JSON.stringify(&quot;production&quot;)，直接用&quot;production&quot;不是更简单吗？ 我们首先来看下JSON.stringify(&quot;production&quot;)生成了什么；运行结果是&quot;&quot;production&quot;&quot;，注意这里，并不是你眼睛花了或者屏幕上有小黑点，结果确实比&quot;production&quot;多嵌套了一层引号。 我们可以简单的把DefinePlugin这个插件理解为将代码里的所有process.env.NODE_ENV替换为字符串中的内容。假如我们在代码中有如下判断环境的代码： 123456789101112//webpack.config.jsmodule.exports = &#123; plugins: [ new webpack.DefinePlugin(&#123; &quot;process.env.NODE_ENV&quot;: &quot;production&quot; &#125;), ]&#125;//src/index.jsif (process.env.NODE_ENV === &#x27;production&#x27;) &#123; console.log(&#x27;production&#x27;);&#125; 这样生成出来的代码就会编译成这样： 12345//dist/bundle.js//代码中并没有定义production变量if (production === &#x27;production&#x27;) &#123; console.log(&#x27;production&#x27;);&#125; 但是我们代码中可能并没有定义production变量，因此会导致代码直接报错，所以我们需要通过JSON.stringify来包裹一层： 1234567891011121314//webpack.config.jsmodule.exports = &#123; plugins: [ new webpack.DefinePlugin(&#123; //&quot;process.env.NODE_ENV&quot;: JSON.stringify(&quot;production&quot;) //相当于 &quot;process.env.NODE_ENV&quot;: &#x27;&quot;production&quot;&#x27; &#125;), ]&#125;//dist/bundle.jsif (&quot;production&quot; === &#x27;production&#x27;) &#123; console.log(&#x27;production&#x27;);&#125; 这样编译出来的代码就没有问题了。 自动生成页面 在上面的代码中我们发现都是手动来生成index.html，然后引入打包后的bundle文件，但是这样太过繁琐，而且如果生成的bundle文件引入了hash值，每次生成的文件名称不一样，因此我们需要一个自动生成html的插件；首先我们需要安装这个插件： 1npm install --save-dev html-webpack-plugin 在demo3中，我们生成了三个不同的bundle.js，我们希望在三个不同的页面能分别引入这三个文件，如下修改config文件： 12345678910111213141516171819202122module.exports = &#123; //省略其他代码 plugins: [ new HtmlWebpackPlugin(&#123; //引用的模板文件 template: &#x27;./index.html&#x27;, //生成的html名称 filename: &#x27;home.html&#x27;, chunks: [&#x27;home&#x27;] &#125;), new HtmlWebpackPlugin(&#123; template: &#x27;./index.html&#x27;, filename: &#x27;list.html&#x27;, chunks: [&#x27;list&#x27;] &#125;), new HtmlWebpackPlugin(&#123; template: &#x27;./index.html&#x27;, filename: &#x27;detail.html&#x27;, chunks: [&#x27;detail&#x27;] &#125;), ]&#125; 我们以index.html作为模板文件，生成home、list、detail三个不同的页面，并且通过chunks分别引入不同的bundle；如果这里不写chunks，每个页面就会引入所有生成出来的bundle。 html-webpack-plugin还支持以下字段： 1234567891011121314151617181920212223242526272829303132new HtmlWebpackPlugin(&#123; template: &#x27;./index.html&#x27;, filename: &#x27;all.html&#x27;, //页面注入title title: &#x27;html webpack plugin title&#x27;, //默认引入所有的chunks链接 chunks: &#x27;all&#x27;, //注入页面位置 inject: true, //启用hash hash: true, favicon: &#x27;&#x27;, //插入meta标签 meta: &#123; &#x27;viewport&#x27;: &#x27;width=device-width, initial-scale=1.0&#x27; &#125;, minify: &#123; //清除script标签引号 removeAttributeQuotes: true, //清除html中的注释 removeComments: true, //清除html中的空格、换行符 //将html压缩成一行 collapseWhitespace: false, //压缩html的行内样式成一行 minifyCSS: true, //清除内容为空的元素（慎用） removeEmptyElements: false, //清除style和link标签的type属性 removeStyleLinkTypeAttributes: false &#125;&#125;), 上面设置title后需要在模板文件中设置模板字符串： 1&lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; loader loader用于对模块module的源码进行转换，默认webpack只能识别commonjs代码，但是我们在代码中会引入比如vue、ts、less等文件，webpack就处理不过来了；loader拓展了webpack处理多种文件类型的能力，将这些文件转换成浏览器能够渲染的js、css。 module.rules允许我们配置多个loader，能够很清晰的看出当前文件类型应用了哪些loader，loader的代码均在demo4中。 1234567891011121314151617181920&#123; module: &#123; rules: [ &#123; test: /\\.js$/, use: &#123; loader: &#x27;babel-loader&#x27;, options: &#123;&#125; &#125; &#125;, &#123; test: /\\.css$/, use: [ &#123; loader: &#x27;style-loader&#x27; &#125;, &#123; loader: &#x27;css-loader&#x27; &#125; ] &#125;, ] &#125;&#125; 我们可以看到rules属性值是一个数组，每个数组对象表示了不同的匹配规则；test属性时一个正则表达式，匹配不同的文件后缀；use表示匹配了这个文件后调用什么loader来处理，当有多个loader的时候，use就需要用到数组。 多个loader支持链式传递，能够对资源进行流水线处理，上一个loader处理的返回值传递给下一个loader；loader处理有一个优先级，从右到左，从下到上；在上面demo中对css的处理就遵从了这个优先级，css-loader先处理，处理好了再给style-loader；因此我们写loader的时候也要注意前后顺序。 css-loader和style-loader css-loader和style-loader从名称看起来功能很相似，然而两者的功能有着很大的区别，但是他们经常会成对使用；安装方法： 1npm i -D css-loader style-loader css-loader用来解释@import和url()；style-loader用来将css-loader生成的样式表通过&lt;style&gt;标签，插入到页面中去。 123456789101112131415/* /src/head.css */.head&#123; display: flex; background: #666;&#125;/* /src/foot.css */.foot&#123; background: #ccc;&#125;/* /src/index.css */@import &#x27;./head.css&#x27;;@import &#x27;./foot.css&#x27;;.wrap &#123; background: #999;&#125; 然后在入口文件中将index.css引入，就能看到打包的效果，页面中插入了三个style标签，代码在demo4： sass-loader和less-loader 这两个loader看名字大家也能猜到了，就是用来处理sass和less样式的。安装方法： 1npm i -D sass-loader less-loader node-sass 在config中进行配置，代码在demo4： 1234567891011121314151617181920212223&#123; //其他配置 rules: &#123; test: /\\.scss$/, use: [&#123; loader: &#x27;style-loader&#x27; &#125;, &#123; loader: &#x27;css-loader&#x27; &#125;,&#123; loader: &#x27;sass-loader&#x27; &#125;] &#125;,&#123; test: /\\.less$/, use: [&#123; loader: &#x27;style-loader&#x27; &#125;, &#123; loader: &#x27;css-loader&#x27; &#125;,&#123; loader: &#x27;less-loader&#x27; &#125;] &#125;&#125; postcss-loader 都0202年了，小伙伴肯定不想一个一个的手动添加-moz、-ms、-webkit等浏览器私有前缀；postcss提供了很多对样式的扩展功能；啥都不说，先安装起来： 1npm i -D postcss-loader 老规矩，还是在config中进行配置： 1234567891011121314151617181920212223rules: [&#123; test: /\\.scss$/, use: [&#123; loader: &#x27;style-loader&#x27; &#125;, &#123; loader: &#x27;css-loader&#x27; &#125;, &#123; loader: &#x27;postcss-loader&#x27; &#125;,&#123; loader: &#x27;sass-loader&#x27; &#125;]&#125;,&#123; test: /\\.less$/, use: [&#123; loader: &#x27;style-loader&#x27; &#125;, &#123; loader: &#x27;css-loader&#x27; &#125;, &#123; loader: &#x27;postcss-loader&#x27; &#125;,&#123; loader: &#x27;less-loader&#x27; &#125;]&#125;] 正当我们兴冲冲的打包看效果时，发现样式还是老样子，并没有什么改变。 这是因为postcss主要功能只有两个：第一就是把css解析成JS可以操作的抽象语法树AST，第二就是调用插件来处理AST并得到结果；所以postcss一般都是通过插件来处理css，并不会直接处理，所以我们需要先安装一些插件： 1npm i -D autoprefixer postcss-plugins-px2rem cssnano 在项目根目录新建一个.browserslistrc文件。 12&gt; 0.25%last 2 versions 我们将postcss的配置单独提取到项目根目录下的postcss.config.js： 12345678910module.exports = &#123; plugins: [ //自动添加前缀 require(&#x27;autoprefixer&#x27;), //px转为rem，应用于移动端 require(&#x27;postcss-plugins-px2rem&#x27;)(&#123; remUnit: 75 &#125;), //优化合并css require(&#x27;cssnano&#x27;), ]&#125; 有了autoprefixer插件，我们打包后的css就自动加上了前缀。 babel-loader 兼容低版本浏览器的痛相信很多童鞋都经历过，写完代码发现自己的js代码不能运行在IE10或者IE11上，然后尝试着引入各种polyfill；babel的出现给我们提供了便利，将高版本的ES6甚至ES7转为ES5；我们首先安装babel所需要的依赖： 12npm i -D babel-loader @babel/core @babel/preset-env @babel/plugin-transform-runtimenpm i -S @babel/runtime 然后在config添加loader对js进行处理： 123456789&#123; //省略其他配置 rules: [&#123; test: /\\.js/, use: &#123; loader: &#x27;babel-loader&#x27; &#125; &#125;]&#125; 同样的，我们把babel的配置提取到根目录，新建一个.babelrc文件： 12345678&#123; &quot;presets&quot;: [ &quot;@babel/preset-env&quot; ], &quot;plugins&quot;: [ &quot;@babel/plugin-transform-runtime&quot; ]&#125; 我们可以在index.js中尝试写一些es6的语法，看到代码会被转译成es5，代码在demo4中。由于babel-loader的转译速度很慢，在后面我们加入了时间插件后可以看到每个loader的耗时，babel-loader是最耗时间；因此我们要尽可能少的使用babel来转译文件，我们对config进行改进， 1234567891011&#123; //省略其他配置 rules: [&#123; test: /\\.js$/, use: &#123; loader: &#x27;babel-loader&#x27; &#125;, // exclude: /node_modules/, include: [path.resolve(__dirname, &#x27;src&#x27;)] &#125;]&#125; 正则上使用$来进行精确匹配，通过exclude将node_modules中的文件进行排除，include将只匹配src中的文件；可以看出来include的范围比exclude更缩小更精确，因此也是推荐使用include。 file-loader和url-loader file-loader和url-loader都是用来处理图片、字体图标等文件；url-loader工作时分两种情况：当文件大小小于limit参数，url-loader将文件转为base-64编码，用于减少http请求；当文件大小大于limit参数时，调用file-loader进行处理；因此我们优先使用url-loader，首先还是进行安装，安装url-loader之前还需要把file-loader先安装： 1npm i file-loader url-loader -D 接下来还是修改config： 123456789101112131415161718&#123; //省略其他配置 rules: [&#123; test: /\\.(png|jpg|gif|jpeg|webp|svg|eot|ttf|woff|woff2)$/, use: &#123; loader: &#x27;url-loader&#x27;, options: &#123; //10k limit: 10240, //生成资源名称 name: &#x27;[name].[hash:8].[ext]&#x27;, //生成资源的路径 outputPath: &#x27;imgs/&#x27; &#125;, exclude: /node_modules/, &#125; &#125;]&#125; 我们在css中给body添加一个小于10k的居中背景图片： 1234567body&#123; width: 100vw; height: 100vh; background: url(./bg.png) no-repeat; background-size: 400px 400px; background-position: center center;&#125; 打包后查看body的样式可以发现图片已经被替换成base64格式的url了，代码在demo4。 html-withimg-loader 如果我们在页面上引用一个图片，会发现打包后的html还是引用了src目录下的图片，这样明显是错误的，因此我们还需要一个插件对html引用的图片进行处理： 1npm i -D html-withimg-loader 老样子还是在config中对html进行配置： 123456789&#123; //省略其他配置 rules: [&#123; test: /\\.(htm|html)$/, use: &#123; loader: &#x27;html-withimg-loader&#x27; &#125; &#125;]&#125; 然鹅，打开页面发现却是这样的： 这是因为在url-loader中把每个图片作为一个模块来处理了，我们还需要去url-loader中修改： 12345678use: &#123; loader: &#x27;url-loader&#x27;, options: &#123; //10k limit: 10240, esModule: false &#125;&#125; 这样我们在页面上的图片引用也被修改了，代码在demo4中。 注 html-withimg-loader会导致html-webpack-plugin插件注入title的模板字符串&lt;%= htmlWebpackPlugin.options.title %&gt;失效，原封不动的展示在页面上；因此，如果我们想保留两者的功能需要在配置config中把html-withimg-loader删除并且通过下面的方式来引用图片： 1&lt;img src=&quot;&lt;%=require(&#x27;./src/bg1.png&#x27;) %&gt;&quot; alt=&quot;&quot; srcset=&quot;&quot;&gt; vue-loader 最后说一下一个比较特殊的vue-loader，看名字就知道是用来处理vue文件的。 12npm i -D vue-loader vue-template-compilernpm i -S vue 我们首先来创建一个vue文件，具体代码在demo5中： 123456789101112131415161718192021222324252627//src/App.vue&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;box&quot; @click=&quot;tap&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;app&#x27;, data()&#123; return &#123; title: &#x27;app实例&#x27; &#125; &#125;, methods: &#123; tap()&#123; this.title = this.title.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;#app&#123; font-size: 16px; background: #ccc;&#125;&lt;/style&gt; 然后在webpack的入口文件中引用它： 1234567//src/main.jsimport Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;new Vue(&#123; render: h =&gt; h(App)&#125;).$mount(&#x27;#app&#x27;) 不过vue-loader和其他loader不太一样，除了将它和.vue文件绑定之外，还需要引入它的一个插件： 1234567891011121314const VueLoaderPlugin = require(&#x27;vue-loader/lib/plugin&#x27;)module.exports = &#123; module: &#123; rules: [ //省略其他loader &#123; test: /\\.vue$/, loader: &#x27;vue-loader&#x27; &#125;] &#125;, plugins: [ new VueLoaderPlugin(), ]&#125; 这样我们就能愉快的在代码中写vue了。 搭建开发环境 在上面的demo中我们都是通过命令行打包生成dist文件，然后直接打开html或者通过static-server来查看页面的；但是开发中我们写完代码每次都来打包会严重影响开发的效率，我们期望的是写完代码后立即就能够看到页面的效果；webpack-dev-server就很好的提供了一个简单的web服务器，能够实时重新加载。 首先在我们的项目中安装依赖： 1npm i -D webpack webpack-dev-server webpack-dev-server的用法和wepack一样，只不过他会额外启动一个express的服务器。我们在项目中新建一个webpack.dev.config.js配置文件，单独对开发环境进行一个配置，相关代码在demo6中： 1234567891011121314151617181920module.exports = &#123; //省略其他配置 devServer: &#123; //启动服务器端口 port: 9000, //默认是localhost，只能本地访问 host: &quot;0.0.0.0&quot;, //自动打开浏览器 open: false, //启用模块热替换 hot: true, //启用gzip压缩 compress: true &#125;, plugins: [ //热更新插件 new webpack.HotModuleReplacementPlugin(&#123; &#125;) ]&#125; 通过命令行webpack-dev-server来启动服务器，启动后我们发现根目录并没有生成任何文件，因为webpack打包到了内存中，不生成文件的原因在于访问内存中的代码比访问文件中的代码更快。 我们在public/index.html的页面上有时候会引用一些本地的静态文件，直接打开页面的会发现这些静态文件的引用失效了，我们可以修改server的工作目录，同时指定多个静态资源的目录： 1234contentBase: [ path.join(__dirname, &quot;public&quot;), path.join(__dirname, &quot;assets&quot;)] 热更新（Hot Module Replacemen简称HMR）是在对代码进行修改并保存之后，webpack对代码重新打包，并且将新的模块发送到浏览器端，浏览器通过新的模块替换老的模块，这样就能在不刷新浏览器的前提下实现页面的更新。 可以看出浏览器和webpack-dev-server之间通过一个websock进行连接，初始化的时候client端保存了一个打包后的hash值；每次更新时server监听文件改动，生成一个最新的hash值再次通过websocket推送给client端，client端对比两次hash值后向服务器发起请求返回更新后的模块文件进行替换。 我们点击源码旁的行数看一下编译后的源码是什么样的： 发现跟我们的源码差距还是挺大的，本来是一个简单add函数，通过webpack的模块封装，已经很难理解原来代码的含义了，因此，我们需要将编译后的代码映射回源码；devtool中不同的配置有不同的效果和速度，综合性能和品质后，我们一般在开发环境使用cheap-module-eval-source-map，在生产环境使用source-map。 1234module.exports = &#123; devtool: &#x27;cheap-module-eval-source-map&#x27;, //其他配置&#125; 其他各模式的对比： plugins 在上面我们也介绍了DefinePlugin、HtmlWebpackPlugin等很多插件，我们发现这些插件都能够不同程度的影响着webpack的构建过程，下面还有一些常用的插件，plugins相关代码在demo7中。 clean-webpack-plugin clean-webpack-plugin用于在打包前清理上一次项目生成的bundle文件，它会根据output.path自动清理文件夹；这个插件在生产环境用的频率非常高，因为生产环境经常会通过hash生成很多bundle文件，如果不进行清理的话每次都会生成新的，导致文件夹非常庞大；这个插件安装使用非常方便： 1npm i -D clean-webpack-plugin 安装后我们在config中配置一下就可以了： 1234567891011const &#123; CleanWebpackPlugin &#125; = require(&#x27;clean-webpack-plugin&#x27;);module.exports = &#123; //其他配置 plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; template: &#x27;./public/index.html&#x27;, filename: &#x27;index.html&#x27;, &#125;) ]&#125; mini-css-extract-plugin 我们之前的样式都是通过style-loader插入到页面中去，但是生产环境需要单独抽离样式文件，mini-css-extract-plugin就可以帮我从js中剥离样式： 1npm i -D mini-css-extract-plugin 我们在开发环境使用style-loader，生产环境使用mini-css-extract-plugin： 1234567891011121314151617181920212223const MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;);module.exports = &#123; //其他配置 module: &#123; rules: [ &#123; test: /\\.less/, use: [&#123; loader: isDev ? &#x27;style-loader&#x27; : MiniCssExtractPlugin.loader &#125;,&#123; loader: &#x27;css-loader&#x27; &#125;,&#123; loader: &#x27;less-loader&#x27; &#125;] &#125; ] &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: &quot;[name].[hash:8].css&quot;, &#125;) ]&#125; 引入loader后，我们还需要配置plugin，提取的css同样支持output.filename中的占位符字符串。 optimize-css-assets-webpack-plugin 我们可以发现虽然配置了production模式，打包出来的js压缩了，但是打包出来的css确没有压缩；在生产环境我们需要对css进行一下压缩： 1npm i optimize-css-assets-webpack-plugin -D 然后也是引入插件： 1234567const OptimizeCSSAssetsPlugin = require(&#x27;optimize-css-assets-webpack-plugin&#x27;);module.exports = &#123; //其他配置 plugins: [ new OptimizeCSSAssetsPlugin(), ]&#125; copy-webpack-plugin 和demo6中一样，我们在public/index.html中引入了静态资源，但是打包的时候webpack并不会帮我们拷贝到dist目录，因此copy-webpack-plugin就可以很好地帮我做拷贝的工作了 1npm i -D copy-webpack-plugin 在config中配置我们需要拷贝的源路径和目标路径： 1234567891011121314const CopyWebpackPlugin = require(&#x27;copy-webpack-plugin&#x27;);module.exports = &#123; plugins: [ new CopyWebpackPlugin(&#123; patterns: [ &#123; from: &#x27;public/js/*.js&#x27;, to: path.resolve(__dirname, &#x27;dist&#x27;, &#x27;js&#x27;), flatten: true, &#125; ] &#125;), ]&#125; ProvidePlugin ProvidePlugin可以很快的帮我们加载想要引入的模块，而不用require。一般我们加载jQuery需要先把它import： 12import $ from &#x27;jquery&#x27;$(&#x27;.box&#x27;).html(&#x27;box&#x27;) 但是我们在config中配置ProvidePlugin插件后能够不用import，直接使用$： 12345678module.exports = &#123; plugins: [ new webpack.ProvidePlugin(&#123; $: &#x27;jquery&#x27;, jQuery: &#x27;jquery&#x27; &#125;), ]&#125; 但是如果在项目中引入了太多模块并且没有require会让人摸不着头脑，因此建议加载一些常见的比如jQuery、vue、lodash等。 loader和plugin的区别 介绍了这么多loader和plugin，我们来回顾一下他们两者的区别： loader：由于webpack只能识别js，loader相当于翻译官的角色，帮助webpack对其他类型的资源进行转译的预处理工作。plugins：plugins扩展了webpack的功能，在webpack运行时会广播很多事件，plugin可以监听这些事件，然后通过webpack提供的API来改变输出结果。 总结 最后，介绍了这么多，本文是webpack基础篇，还有很多生产环境的优化还没有写到；因此各位看官敬请期待优化篇。 参考： 再来一打Webpack面试题Webpack HMR 原理解析","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"打包工具","slug":"PackTool","permalink":"http://xieyufei.com/tags/PackTool/"},{"name":"Webpack","slug":"Webpack","permalink":"http://xieyufei.com/tags/Webpack/"}]},{"title":"从零开始手写Promise","date":"2020-05-20T04:00:00.000Z","path":"2020/05/20/Handwrite-Promise.html","text":"面试的时候经常会问到Promise的使用；有的面试官再深入一点，会继续问是否了解Promise的实现方式，或者有没有阅读过Promise的源码；今天我们就来看一下，Promise在内部是如何实现来链式调用的。 什么是Promise 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise提供统一的API，各种异步操作都可以用同样的方法进行处理。 Promise出现之前都是通过回调函数来实现，回调函数本身没有问题，但是嵌套层级过深，很容易掉进回调地狱。 12345678const fs = require(&#x27;fs&#x27;);fs.readFile(&#x27;1.txt&#x27;, (err,data) =&gt; &#123; fs.readFile(&#x27;2.txt&#x27;, (err,data) =&gt; &#123; fs.readFile(&#x27;3.txt&#x27;, (err,data) =&gt; &#123; //可能还有后续代码 &#125;); &#125;);&#125;); 如果每次读取文件后还要进行逻辑的判断或者异常的处理，那么整个回调函数就会非常复杂且难以维护。Promise的出现正是为了解决这个痛点，我们可以把上面的回调嵌套用Promise改写一下： 1234567891011121314151617181920const readFile = function(fileName)&#123; return new Promise((resolve, reject)=&gt;&#123; fs.readFile(fileName, (err, data)=&gt;&#123; if(err)&#123; reject(err) &#125; else &#123; resolve(data) &#125; &#125;) &#125;)&#125;readFile(&#x27;1.txt&#x27;) .then(data =&gt; &#123; return readFile(&#x27;2.txt&#x27;); &#125;).then(data =&gt; &#123; return readFile(&#x27;3.txt&#x27;); &#125;).then(data =&gt; &#123; //... &#125;); Promise规范 promise最早是在commonjs社区提出来的，当时提出了很多规范。比较接受的是promise/A规范。但是promise/A规范比较简单，后来人们在这个基础上，提出了promise/A+规范，也就是实际上的业内推行的规范；es6也是采用的这种规范，但是es6在此规范上还加入了Promise.all、Promise.race、Promise.catch、Promise.resolve、Promise.reject等方法。 我们可以通过脚本来测试我们写的Promise是否符合promise/A+的规范。将我们实现的Promise加入以下代码： 12345678Promise.defer = Promise.deferred = function () &#123; let dfd = &#123;&#125;; dfd.promise = new Promise((resolve, reject) =&gt; &#123; dfd.resolve = resolve; dfd.reject = reject; &#125;); return dfd;&#125; 然后通过module.exports导出，安装测试的脚本： 1npm install -g promises-aplus-tests 在实现Promise的目录执行以下命令： 1promises-aplus-tests promise.js 接下来，脚本会对照着promise/A+的规范，对我们的脚本来一条一条地进行测试。 Promise基本结构 我们先回顾一下，我们平时都是怎么使用Promise的： 1234567891011var p = new Promise(function(resolve, reject)&#123; console.log(&#x27;执行&#x27;) setTimeout(function()&#123; resolve(2) &#125;, 1000)&#125;)p.then(function(res)&#123; console.log(&#x27;suc&#x27;,res)&#125;,function(err)&#123; console.log(&#x27;err&#x27;,err)&#125;) 首先看出来，Promise是通过构造函数实例化一个对象，然后通过实例对象上的then方法，来处理异步返回的结果。同时，promise/A+规范规定了： promise 是一个拥有 then 方法的对象或函数，其行为符合本规范； 一个 Promise 的当前状态必须为以下三种状态中的一种：等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）。 1234567891011121314151617const PENDING = &#x27;pending&#x27;const FULFILLED = &#x27;fulfilled&#x27;const REJECTED = &#x27;rejected&#x27;function Promise(executor) &#123; var _this = this this.state = PENDING; //状态 this.value = undefined; //成功结果 this.reason = undefined; //失败原因 function resolve(value) &#123;&#125; function reject(reason) &#123;&#125;&#125;Promise.prototype.then = function (onFulfilled, onRejected) &#123;&#125;;module.exports = Promise; 当我们实例化Promise时，构造函数会马上调用传入的执行函数executor，我们可以试一下： 123let p = new Promise((resolve, reject) =&gt; &#123; console.log(&#x27;执行了&#x27;);&#125;); 因此在Promise中构造函数立马执行，同时将resolve函数和reject函数作为参数传入： 123456789function Promise(executor) &#123; var _this = this this.state = PENDING; //状态 this.value = undefined; //成功结果 this.reason = undefined; //失败原因 function resolve(value) &#123;&#125; function reject(reason) &#123;&#125; executor(resolve, reject)&#125; 但是executor也会可能存在异常，因此通过try/catch来捕获一下异常情况： 12345try &#123; executor(resolve, reject);&#125; catch (e) &#123; reject(e);&#125; 不可变 promise/A+规范中规定，当Promise对象已经由等待态（Pending）改变为执行态（Fulfilled）或者拒绝态（Rejected）后，就不能再次更改状态，且终值也不可改变。 因此我们在回调函数resolve和reject中判断，只能是pending状态的时候才能更改状态： 123456789101112function resolve(value) &#123; if(_this.state === PENDING)&#123; _this.state = FULFILLED _this.value = value &#125;&#125;function reject(reason) &#123; if(_this.state === PENDING)&#123; _this.state = REJECTED _this.reason = reason &#125;&#125; 我们更改状态的同时，将回调函数中成功的结果或者失败的原因都保存在对应的属性中，方便以后来获取。 then实现 当Promise的状态改变之后，不管成功还是失败，都会触发then回调函数。因此，then的实现也很简单，就是根据状态的不同，来调用不同处理终值的函数。 12345678Promise.prototype.then = function (onFulfilled, onRejected) &#123; if(this.state === FULFILLED)&#123; typeof onFulfilled === &#x27;function&#x27; &amp;&amp; onFulfilled(this.value) &#125; if(this.state === REJECTED)&#123; typeof onRejected === &#x27;function&#x27; &amp;&amp; onRejected(this.reason) &#125;&#125;; 在规范中也说了，onFulfilled和onRejected是可选的，因此我们对两个值进行一下类型的判断： onFulfilled 和 onRejected 都是可选参数。如果 onFulfilled 不是函数，其必须被忽略。如果 onRejected 不是函数，其必须被忽略 代码写到这里，貌似该有的实现方式都有了，我们来写个demo测试一下： 123456789101112var myP = new Promise(function(resolve, reject)&#123; console.log(&#x27;执行&#x27;) setTimeout(function()&#123; reject(3) &#125;, 1000)&#125;);myP.then(function(res)&#123; console.log(res)&#125;,function(err)&#123; console.log(err)&#125;); 然鹅，很遗憾，运行起来我们发现只打印了构造函数中的执行，下面的then函数根本都没有执行。我们整理一下代码的运行流畅： 当then里面函数运行时，resolve由于是异步执行的，还没有来得及修改state，此时还是PENDING状态；因此我们需要对异步的情况做一下处理。 支持异步 那么如何让我们的Promise来支持异步呢？我们可以参考发布订阅模式，在执行then方法的时候，如果当前还是PENDING状态，就把回调函数寄存到一个数组中，当状态发生改变时，去数组中取出回调函数；因此我们先在Promise中定义一下变量： 1234function Promise(executor) &#123; this.onFulfilled = [];//成功的回调 this.onRejected = []; //失败的回调&#125; 这样，当then执行时，如果还是PENDING状态，我们不是马上去执行回调函数，而是将其存储起来： 123456789101112Promise.prototype.then = function (onFulfilled, onRejected) &#123; if(this.state === FULFILLED)&#123; typeof onFulfilled === &#x27;function&#x27; &amp;&amp; onFulfilled(this.value) &#125; if(this.state === REJECTED)&#123; typeof onRejected === &#x27;function&#x27; &amp;&amp; onRejected(this.reason) &#125; if(this.state === PENDING)&#123; typeof onFulfilled === &#x27;function&#x27; &amp;&amp; this.onFulfilled.push(onFulfilled) typeof onRejected === &#x27;function&#x27; &amp;&amp; this.onRejected.push(onRejected) &#125;&#125;; 存储起来后，当resolve或者reject异步执行的时候就可以来调用了： 1234567891011121314function resolve(value) &#123; if(_this.state === PENDING)&#123; _this.state = FULFILLED _this.value = value _this.onFulfilled.forEach(fn =&gt; fn(value)) &#125;&#125;function reject(reason) &#123; if(_this.state === PENDING)&#123; _this.state = REJECTED _this.reason = reason _this.onRejected.forEach(fn =&gt; fn(reason)) &#125;&#125; 有童鞋可能会提出疑问了，为什么这边onFulfilled和onRejected要存在数组中，直接用一个变量接收不是也可以么？下面看一个例子： 12345678910111213var p = new Promise((resolve, reject)=&gt;&#123; setTimeout(()=&gt;&#123; resolve(4) &#125;, 0)&#125;)p.then((res)=&gt;&#123; //4 res console.log(res, &#x27;res&#x27;)&#125;)p.then((res1)=&gt;&#123; //4 res1 console.log(res1, &#x27;res1&#x27;)&#125;) 我们分别调用了两次then，如果是一个变量的话，最后肯定只会运行后一个then，把之前的覆盖了，如果是数组的话，两个then都能正常运行。 至此，我们运行demo，就能如愿以偿的看到运行结果了；一个四十行左右的简单Promise垫片就此完成了。这里贴一下完整的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243const PENDING = &#x27;pending&#x27;const FULFILLED = &#x27;fulfilled&#x27;const REJECTED = &#x27;rejected&#x27;function Promise(executor) &#123; var _this = this this.state = PENDING; //状态 this.value = undefined; //成功结果 this.reason = undefined; //失败原因 this.onFulfilled = [];//成功的回调 this.onRejected = []; //失败的回调 function resolve(value) &#123; if(_this.state === PENDING)&#123; _this.state = FULFILLED _this.value = value _this.onFulfilled.forEach(fn =&gt; fn(value)) &#125; &#125; function reject(reason) &#123; if(_this.state === PENDING)&#123; _this.state = REJECTED _this.reason = reason _this.onRejected.forEach(fn =&gt; fn(reason)) &#125; &#125; try &#123; executor(resolve, reject); &#125; catch (e) &#123; reject(e); &#125;&#125;Promise.prototype.then = function (onFulfilled, onRejected) &#123; if(this.state === FULFILLED)&#123; typeof onFulfilled === &#x27;function&#x27; &amp;&amp; onFulfilled(this.value) &#125; if(this.state === REJECTED)&#123; typeof onRejected === &#x27;function&#x27; &amp;&amp; onRejected(this.reason) &#125; if(this.state === PENDING)&#123; typeof onFulfilled === &#x27;function&#x27; &amp;&amp; this.onFulfilled.push(onFulfilled) typeof onRejected === &#x27;function&#x27; &amp;&amp; this.onRejected.push(onRejected) &#125;&#125;; 链式调用then 相信上面的Promise垫片应该很容易理解，下面链式调用才是Promise的难点和核心点；我们对照promise/A+规范，一步一步地来实现，我们先来看一下规范是如何来定义的： then 方法必须返回一个 promise 对象 promise2 = promise1.then(onFulfilled, onRejected); 也就是说，每个then方法都要返回一个新的Promise对象，这样我们的then方法才能不断的链式调用；因此上面的简单垫片中then方法就不适用了，因为它什么都没有返回，我们对其进行简单的改写，不论then进行什么操作，都返回一个新的Promise对象： 12345Promise.prototype.then = function (onFulfilled, onRejected) &#123; let promise2 = new Promise((resolve, reject)=&gt;&#123; &#125;) return promise2&#125; 我们继续看then的执行过程： 如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行下面的 Promise 解决过程：[[Resolve]](promise2, x) 如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e 如果 onFulfilled 不是函数且 promise1 成功执行， promise2 必须成功执行并返回相同的值 如果 onRejected 不是函数且 promise1 拒绝执行， promise2 必须拒绝执行并返回相同的据因 首先第一点，我们知道onFulfilled和onRejected执行之后都会有一个返回值x，对返回值x处理就需要用到Promise解决过程，这个我们下面再说；第二点需要对onFulfilled和onRejected进行异常处理，没什么好说的；第三和第四点，说的其实是一个问题，如果onFulfilled和onRejected两个参数没有传，则继续往下传（值的传递特性）；举个例子： 123456789101112var p = new Promise(function(resolve, reject)&#123; setTimeout(function()&#123; resolve(3) &#125;, 1000)&#125;);p.then(1,1).then(&#x27;&#x27;,&#x27;&#x27;).then().then(function(res)&#123; //3 console.log(res)&#125;) 这里不管onFulfilled和onRejected传什么值，只要不是函数，就继续向下传入，直到有函数进行接收；因此我们对then方法进行如下完善： 1234567891011121314151617181920212223//_this是promise1的实例对象var _this = thisonFulfilled = typeof onFulfilled === &#x27;function&#x27; ? onFulfilled : value =&gt; valueonRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : reason =&gt; &#123; throw reason &#125;var promise2 = new Promise((resolve, reject)=&gt;&#123; if(_this.state === FULFILLED)&#123; let x = onFulfilled(_this.value) resolvePromise(promise2, x, resolve, reject) &#125; else if(_this.state === REJECTED)&#123; let x = onRejected(_this.reason) resolvePromise(promise2, x ,resolve, reject) &#125; else if(_this.state === PENDING)&#123; _this.onFulfilled.push(()=&gt;&#123; let x = onFulfilled(_this.value) resolvePromise(promise2, x, resolve, reject) &#125;) _this.onRejected.push(()=&gt;&#123; let x = onRejected(_this.reason) resolvePromise(promise2, x ,resolve, reject) &#125;) &#125;&#125;) 我们发现函数中有一个resolvePromise，就是上面说的Promise解决过程，它是对新的promise2和上一个执行结果 x 的处理，由于具有复用性，我们把它抽成一个单独的函数，这也是上面规范中定义的第一点。 由于then的回调是异步执行的，因此我们需要把onFulfilled和onRejected执行放到异步中去执行，同时做一下错误的处理： 1234567891011121314151617181920212223242526272829303132333435363738394041//其他代码略if(_this.state === FULFILLED)&#123; setTimeout(()=&gt;&#123; try &#123; let x = onFulfilled(_this.value) resolvePromise(promise2, x, resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;)&#125; else if(_this.state === REJECTED)&#123; setTimeout(()=&gt;&#123; try &#123; let x = onRejected(_this.reason) resolvePromise(promise2, x ,resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;)&#125; else if(_this.state === PENDING)&#123; _this.onFulfilled.push(()=&gt;&#123; setTimeout(()=&gt;&#123; try &#123; let x = onFulfilled(_this.value) resolvePromise(promise2, x, resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;) &#125;) _this.onRejected.push(()=&gt;&#123; setTimeout(()=&gt;&#123; try &#123; let x = onRejected(_this.reason) resolvePromise(promise2, x ,resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;) &#125;)&#125; Promise解决过程 Promise 解决过程是一个抽象的操作，其需输入一个 promise 和一个值，我们表示为 [[Resolve]](promise, x)，如果 x 有 then 方法且看上去像一个 Promise ，解决程序即尝试使 promise 接受 x 的状态；否则其用 x 的值来执行 promise 。 这段话比较抽象，通俗一点的来说就是promise的解决过程需要传入一个新的promise和一个值x，如果传入的x是一个thenable的对象（具有then方法），就接受x的状态： 123456//promise2：新的Promise对象//x：上一个then的返回值//resolve：promise2的resolve//reject：promise2的rejectfunction resolvePromise(promise2, x, resolve, reject) &#123;&#125; 定义好函数后，来看具体的操作说明： x 与 promise 相等 如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise x 为 Promise 如果 x 处于等待态， promise 需保持为等待态直至 x 被执行或拒绝 如果 x 处于执行态，用相同的值执行 promise 如果 x 处于拒绝态，用相同的据因拒绝 promise x 为对象或函数 把 x.then 赋值给 then 如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 promise 如果 then 是函数，将 x 作为函数的作用域 this 调用之。传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise: 如果 resolvePromise 以值 y 为参数被调用，则运行 [[Resolve]](promise, y) 如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise 如果 resolvePromise 和 rejectPromise 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用 如果 then 不是函数，以 x 为参数执行 promise 如果 x 不为对象或者函数，以 x 为参数执行 promise 首先第一点，如果x和promise相等，这是一种什么情况呢，就是相当于把自己返回出去了： 1234567var p = new Promise(function(resolve, reject)&#123; resolve(3)&#125;);//Uncaught (in promise) TypeError: Chaining cycle detected for promise #&lt;Promise&gt;var p2 = p.then(function()&#123; return p2&#125;) 这样会陷入一个死循环中，因此我们首先要把这种情况给排除掉： 12345function resolvePromise(promise2, x, resolve, reject) &#123; if (promise2 === x) &#123; reject(new TypeError(&#x27;Chaining cycle&#x27;)); &#125;&#125; 接下来就是对不同情况的判断了，首先我们把 x 为对象或者函数的情况给判断出来： 1234567891011function resolvePromise(promise2, x, resolve, reject) &#123; if (promise2 === x) &#123; reject(new TypeError(&#x27;Chaining cycle&#x27;)); &#125; if (x !== null &amp;&amp; (typeof x === &#x27;object&#x27; || typeof x === &#x27;function&#x27;)) &#123; //函数或对象 &#125; else &#123; //普通值 resolve(x) &#125;&#125; 如果 x 为对象或函数，就把 x.then 赋值给 then好理解，但是第二点取then有可能会报错是为什么呢？这是因为需要考虑到所有出错的情况（防小人不防君子），如果有人实现Promise对象的时候使用Object.defineProperty()恶意抛错，导致程序崩溃，就像这样： 12345678var Promise = &#123;&#125;;Object.defineProperty(Promise, &#x27;then&#x27;, &#123; get: function()&#123; throw Error(&#x27;error&#x27;) &#125;&#125;)//Uncaught Error: errorPromise.then 因此，我们取then的时候也需要try/catch： 123456789//其他代码略if (x !== null &amp;&amp; (typeof x === &#x27;object&#x27; || typeof x === &#x27;function&#x27;)) &#123; //函数或对象 try &#123; let then = x.then &#125; catch(e)&#123; reject(e) &#125;&#125; 取出then后，回到3.3，判断如果是一个函数，就将 x 作为函数的作用域 this 调用，同时传入两个回调函数作为参数。 123456789101112131415//其他代码略try &#123; let then = x.then if(typeof then === &#x27;function&#x27;)&#123; then.call(x, (y)=&gt;&#123; resolve(y) &#125;, (r) =&gt;&#123; reject(r) &#125;) &#125; else &#123; resolve(x) &#125;&#125; catch(e)&#123; reject(e)&#125; 这样，我们的链式调用就能顺利的调用起来了；但是还有一种特殊的情况，如果resolve的y值还是一个Promise对象，这时就应该继续执行，比如下面的例子： 1234567891011121314var p1 = new Promise((resolve, reject)=&gt;&#123; resolve(&#x27;p1&#x27;)&#125;)p1.then((res)=&gt;&#123; return new Promise((resolve, reject)=&gt;&#123; resolve(new Promise((resolve, reject)=&gt;&#123; resolve(&#x27;p2&#x27;) &#125;)) &#125;)&#125;).then((res1)=&gt;&#123; //Promise &#123;state: &quot;fulfilled&quot;, value: &quot;p2&quot;&#125; console.log(res1)&#125;) 这时候第二个then打印出来的是一个promise对象；我们应该继续递归调用resolvePromise（参考规范3.3.1），因此，最终resolvePromise的完整代码如下： 1234567891011121314151617181920212223242526272829303132function resolvePromise(promise2, x, resolve, reject)&#123; if(promise2 === x)&#123; reject(new TypeError(&#x27;Chaining cycle&#x27;)) &#125; if(x &amp;&amp; typeof x === &#x27;object&#x27; || typeof x === &#x27;function&#x27;)&#123; let used; try &#123; let then = x.then if(typeof then === &#x27;function&#x27;)&#123; then.call(x, (y)=&gt;&#123; if (used) return; used = true resolvePromise(promise2, y, resolve, reject) &#125;, (r) =&gt;&#123; if (used) return; used = true reject(r) &#125;) &#125; else &#123; if (used) return; used = true resolve(x) &#125; &#125; catch(e)&#123; if (used) return; used = true reject(e) &#125; &#125; else &#123; resolve(x) &#125;&#125; 到这里，我们的Promise也能够完整的实现链式调用了；然后把代码用promises-aplus-tests测试一下，完美的通过了872项测试。 完整Promise代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132const PENDING = &#x27;pending&#x27;const FULFILLED = &#x27;fulfilled&#x27;const REJECTED = &#x27;rejected&#x27;function Promise(executor) &#123; var _this = this this.state = PENDING; //状态 this.value = undefined; //成功结果 this.reason = undefined; //失败原因 this.onFulfilled = [] this.onRejected = [] function resolve(value) &#123; if(_this.state === PENDING)&#123; _this.state = FULFILLED _this.value = value _this.onFulfilled.forEach(fn =&gt; fn(value)) &#125; &#125; function reject(reason) &#123; if(_this.state === PENDING)&#123; _this.state = REJECTED _this.reason = reason _this.onRejected.forEach(fn =&gt; fn(reason)) &#125; &#125; try &#123; executor(resolve, reject) &#125; catch (error) &#123; reject(error) &#125;&#125;Promise.prototype.then = function (onFulfilled, onRejected) &#123; var _this = this onFulfilled = typeof onFulfilled === &#x27;function&#x27; ? onFulfilled : value =&gt; value onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : reason =&gt; &#123; throw reason &#125; var promise2 = new Promise((resolve, reject)=&gt;&#123; if(_this.state === FULFILLED)&#123; setTimeout(()=&gt;&#123; try &#123; let x = onFulfilled(_this.value) resolvePromise(promise2, x, resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;) &#125; else if(_this.state === REJECTED)&#123; setTimeout(()=&gt;&#123; try &#123; let x = onRejected(_this.reason) resolvePromise(promise2, x ,resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;) &#125; else if(_this.state === PENDING)&#123; _this.onFulfilled.push(()=&gt;&#123; setTimeout(()=&gt;&#123; try &#123; let x = onFulfilled(_this.value) resolvePromise(promise2, x, resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;) &#125;) _this.onRejected.push(()=&gt;&#123; setTimeout(()=&gt;&#123; try &#123; let x = onRejected(_this.reason) resolvePromise(promise2, x ,resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;) &#125;) &#125; &#125;) return promise2&#125;;function resolvePromise(promise2, x, resolve, reject)&#123; if(promise2 === x)&#123; reject(new TypeError(&#x27;Chaining cycle&#x27;)) &#125; if(x &amp;&amp; typeof x === &#x27;object&#x27; || typeof x === &#x27;function&#x27;)&#123; let used; try &#123; let then = x.then if(typeof then === &#x27;function&#x27;)&#123; then.call(x, (y)=&gt;&#123; if (used) return; used = true resolvePromise(promise2, y, resolve, reject) &#125;, (r) =&gt;&#123; if (used) return; used = true reject(r) &#125;) &#125; else &#123; if (used) return; used = true resolve(x) &#125; &#125; catch(e)&#123; if (used) return; used = true reject(e) &#125; &#125; else &#123; resolve(x) &#125;&#125;Promise.defer = Promise.deferred = function () &#123; let dfd = &#123;&#125;; dfd.promise = new Promise((resolve, reject) =&gt; &#123; dfd.resolve = resolve; dfd.reject = reject; &#125;); return dfd;&#125;module.exports = Promise; 参考promise/A规范（英文）promise/A+规范（英文）promise/A+规范（中文）","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"Promise","slug":"Promise","permalink":"http://xieyufei.com/tags/Promise/"}]},{"title":"Promise A+ 规范（中文翻译）","date":"2020-05-19T04:00:00.000Z","path":"2020/05/19/Promises-A-Plus.html","text":"英文原文：Promise/A+图灵译文：【翻译】Promises/A+规范 译者序：一年前曾译过 Promise/A+ 规范，适时完全不懂 Promise 的思想，纯粹将翻译的过程当作学习，旧文译下来诘屈聱牙，读起来十分不顺畅。谁知这样一篇拙译，一年之间竟然点击数千，成为谷歌搜索的头条。今日在理解之后重译此规范，以飨读者。 一个开放、健全且通用的 JavaScript Promise 标准。由开发者制定，供开发者参考。 译文术语 解决（fulfill）：指一个 promise 成功时进行的一系列操作，如状态的改变、回调的执行。虽然规范中用 fulfill 来表示解决，但在后世的 promise 实现多以 resolve 来指代之。 拒绝（reject）：指一个 promise 失败时进行的一系列操作。 终值（eventual value）：所谓终值，指的是 promise 被解决时传递给解决回调的值，由于 promise 有一次性的特征，因此当这个值被传递时，标志着 promise 等待态的结束，故称之终值，有时也直接简称为值（value）。 据因（reason）：也就是拒绝原因，指在 promise 被拒绝时传递给拒绝回调的值。 Promise 表示一个异步操作的最终结果，与之进行交互的方式主要是 then 方法，该方法注册了两个回调函数，用于接收 promise 的终值或本 promise 不能执行的原因。 本规范详细列出了 then 方法的执行过程，所有遵循 Promises/A+ 规范实现的 promise 均可以本标准作为参照基础来实施 then 方法。因而本规范是十分稳定的。尽管 Promise/A+ 组织有时可能会修订本规范，但主要是为了处理一些特殊的边界情况，且这些改动都是微小且向下兼容的。如果我们要进行大规模不兼容的更新，我们一定会在事先进行谨慎地考虑、详尽的探讨和严格的测试。 从历史上说，本规范实际上是把之前 Promise/A 规范 中的建议明确成为了行为标准：我们一方面扩展了原有规范约定俗成的行为，一方面删减了原规范的一些特例情况和有问题的部分。 最后，核心的 Promises/A+ 规范不设计如何创建、解决和拒绝 promise，而是专注于提供一个通用的 then 方法。上述对于 promises 的操作方法将来在其他规范中可能会提及。 术语 Promisepromise 是一个拥有 then 方法的对象或函数，其行为符合本规范； thenable是一个定义了 then 方法的对象或函数，文中译作“拥有 then 方法”； 值（value）指任何 JavaScript 的合法值（包括 undefined , thenable 和 promise）； 异常（exception）是使用 throw 语句抛出的一个值。 据因（reason）表示一个 promise 的拒绝原因。 要求 Promise 的状态一个 Promise 的当前状态必须为以下三种状态中的一种：等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）。 等待态（Pending）处于等待态时，promise 需满足以下条件： 可以迁移至执行态或拒绝态 执行态（Fulfilled）处于执行态时，promise 需满足以下条件： 不能迁移至其他任何状态 必须拥有一个不可变的终值 拒绝态（Rejected）处于拒绝态时，promise 需满足以下条件： 不能迁移至其他任何状态 必须拥有一个不可变的据因 这里的不可变指的是恒等（即可用 === 判断相等），而不是意味着更深层次的不可变（译者注： 盖指当 value 或 reason 不是基本值时，只要求其引用地址相等，但属性值可被更改）。 Then 方法一个 promise 必须提供一个 then 方法以访问其当前值、终值和据因。 promise 的 then 方法接受两个参数： 1promise.then(onFulfilled, onRejected) 参数可选onFulfilled 和 onRejected 都是可选参数。 如果 onFulfilled 不是函数，其必须被忽略 如果 onRejected 不是函数，其必须被忽略 onFulfilled 特性如果 onFulfilled 是函数： 当 promise 执行结束后其必须被调用，其第一个参数为 promise 的终值 在 promise 执行结束前其不可被调用 其调用次数不可超过一次 onRejected 特性如果 onRejected 是函数： 当 promise 被拒绝执行后其必须被调用，其第一个参数为 promise 的据因 在 promise 被拒绝执行前其不可被调用 其调用次数不可超过一次 调用时机onFulfilled 和 onRejected 只有在执行环境堆栈仅包含平台代码时才可被调用[注1][1] 调用要求onFulfilled 和 onRejected 必须被作为函数调用（即没有 this 值）[注2][2] 多次调用then 方法可以被同一个 promise 调用多次 当 promise 成功执行时，所有 onFulfilled 需按照其注册顺序依次回调 当 promise 被拒绝执行时，所有的 onRejected 需按照其注册顺序依次回调 返回then 方法必须返回一个 promise 对象 [注3][3] 1promise2 = promise1.then(onFulfilled, onRejected); 如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行下面的 Promise 解决过程：[[Resolve]](promise2, x) 如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e 如果 onFulfilled 不是函数且 promise1 成功执行， promise2 必须成功执行并返回相同的值 如果 onRejected 不是函数且 promise1 拒绝执行， promise2 必须拒绝执行并返回相同的据因 译者注： 理解上面的“返回”部分非常重要，即：不论 promise1 被 reject 还是被 resolve 时 promise2 都会被 resolve，只有出现异常时才会被 rejected。 Promise 解决过程Promise 解决过程 是一个抽象的操作，其需输入一个 promise 和一个值，我们表示为 [[Resolve]](promise, x)，如果 x 有 then 方法且看上去像一个 Promise ，解决程序即尝试使 promise 接受 x 的状态；否则其用 x 的值来执行 promise 。 这种 thenable 的特性使得 Promise 的实现更具有通用性：只要其暴露出一个遵循 Promise/A+ 协议的 then 方法即可；这同时也使遵循 Promise/A+ 规范的实现可以与那些不太规范但可用的实现能良好共存。 运行 [[Resolve]](promise, x) 需遵循以下步骤： x 与 promise 相等如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise x 为 Promise如果 x 为 Promise ，则使 promise 接受 x 的状态 [注4][4]： 如果 x 处于等待态， promise 需保持为等待态直至 x 被执行或拒绝 如果 x 处于执行态，用相同的值执行 promise 如果 x 处于拒绝态，用相同的据因拒绝 promise x 为对象或函数如果 x 为对象或者函数： 把 x.then 赋值给 then [注5][5] 如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 promise 如果 then 是函数，将 x 作为函数的作用域 this 调用之。传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise: 如果 resolvePromise 以值 y 为参数被调用，则运行 [[Resolve]](promise, y) 如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise 如果 resolvePromise 和 rejectPromise 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用 如果调用 then 方法抛出了异常 e： 如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之 否则以 e 为据因拒绝 promise 如果 then 不是函数，以 x 为参数执行 promise 如果 x 不为对象或者函数，以 x 为参数执行 promise 如果一个 promise 被一个循环的 thenable 链中的对象解决，而 [[Resolve]](promise, thenable) 的递归性质又使得其被再次调用，根据上述的算法将会陷入无限递归之中。算法虽不强制要求，但也鼓励施者检测这样的递归是否存在，若检测到存在则以一个可识别的 TypeError 为据因来拒绝 promise [注6][6]。 注释 注1 这里的平台代码指的是引擎、环境以及 promise 的实施代码。实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。这个事件队列可以采用“宏任务（macro-task）”机制或者“微任务（micro-task）”机制来实现。由于 promise 的实施代码本身就是平台代码（译者注： 即都是 JavaScript），故代码自身在处理在处理程序时可能已经包含一个任务调度队列或[『跳板』]。 译者注： 这里提及了 macrotask 和 microtask 两个概念，这表示异步任务的两种分类。在挂起任务时，JS 引擎会将所有任务按照类别分到这两个队列中，首先在 macrotask 的队列（这个队列也被叫做 task queue）中取出第一个任务，执行完毕后取出 microtask 队列中的所有任务顺序执行；之后再取 macrotask 任务，周而复始，直至两个队列的任务都取完。 两个类别的具体分类如下： macro-task: script（整体代码）, setTimeout, setInterval, setImmediate, I/O, UI rendering micro-task: process.nextTick, Promises（这里指浏览器实现的原生 Promise）, Object.observe, MutationObserver 详见 stackoverflow 解答 注2 也就是说在 严格模式（strict） 中，函数 this 的值为 undefined ；在非严格模式中其为全局对象。 注3 代码实现在满足所有要求的情况下可以允许 promise2 === promise1 。每个实现都要文档说明其是否允许以及在何种条件下允许 promise2 === promise1 。 注4 总体来说，如果 x 符合当前实现，我们才认为它是真正的 promise 。这一规则允许那些特例实现接受符合已知要求的 Promises 状态。 注5 这步我们先是存储了一个指向 x.then 的引用，然后测试并调用该引用，以避免多次访问 x.then 属性。这种预防措施确保了该属性的一致性，因为其值可能在检索调用时被改变。 注6 实现不应该对 thenable 链的深度设限，并假定超出本限制的递归就是无限循环。只有真正的循环递归才应能导致 TypeError 异常；如果一条无限长的链上 thenable 均不相同，那么递归下去永远是正确的行为。","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"Promise","slug":"Promise","permalink":"http://xieyufei.com/tags/Promise/"}]},{"title":"Vue中$nextTick源码解析","date":"2020-04-23T03:00:00.000Z","path":"2020/04/23/Vue-nextTick.html","text":"在做项目的时候，我们经常会用到nextTick，简单的理解就是它就是一个setTimeout函数，将函数放到异步后去处理；将它替换成setTimeout好像也能跑起来，但它仅仅这么简单吗？那为什么我们不直接用setTimeout呢？让我们深入剖析一下。 发现问题 记得之前有一个需求，就是根据文字的行数来显示展开更多的一个按钮，因此我们在Vue中给数据赋值之后需要获取文字高度。 1234567891011121314151617&lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;msg&quot;&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt;&lt;/div&gt;new Vue(&#123; el: &#x27;#app&#x27;, data: function()&#123; return &#123; msg: &#x27;&#x27; &#125; &#125;, mounted()&#123; this.msg = &#x27;我是测试文字&#x27; console.log(document.querySelector(&#x27;.msg&#x27;).offsetHeight) //0 &#125;&#125;) 这时不管怎么获取，文字的Div高度都是0；但是直接获取却是有值： 同样的情况也发生在给子组件传参上；我们给子组件传参数后，在子组件中调用函数查看参数。 1234567891011121314151617181920212223242526&lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;msg&quot;&gt; &lt;form-report ref=&quot;child&quot; :name=&quot;childName&quot;&gt;&lt;/form-report&gt; &lt;/div&gt;&lt;/div&gt;Vue.component(&#x27;form-report&#x27;, &#123; props: [&#x27;name&#x27;], methods: &#123; showName()&#123; console.log(&#x27;子组件name：&#x27;+this.name) &#125; &#125;, template: &#x27;&lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;&#x27;&#125;)new Vue(&#123; el: &#x27;#app&#x27;, data: function()&#123; return &#123; childName: &#x27;&#x27;, &#125; &#125;, mounted()&#123; this.childName = &#x27;我是子组件名字&#x27; this.$refs.child.showName() &#125;&#125;) 虽然页面上展示了子组件的name，但是打印出来却是空值： 异步更新 我们发现上述两个问题的发生，不管子组件还是父组件，都是在给data中赋值后立马去查看数据导致的。由于“查看数据”这个动作是同步操作的，而且都是在赋值之后；因此我们猜测一下，给数据赋值操作是一个异步操作，并没有马上执行，Vue官网对数据操作是这么描述的： 可能你还没有注意到，Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。 也就是说我们在设置this.msg = &#39;some thing&#39;的时候，Vue并没有马上去更新DOM数据，而是将这个操作放进一个队列中；如果我们重复执行的话，队列还会进行去重操作；等待同一事件循环中的所有数据变化完成之后，会将队列中的事件拿出来处理。 这样做主要是为了提升性能，因为如果在主线程中更新DOM，循环100次就要更新100次DOM；但是如果等事件循环完成之后更新DOM，只需要更新1次。还不了解事件循环的童鞋，可以看我的另一篇文章从一道面试题来理解JS事件循环 为了在数据更新操作之后操作DOM，我们可以在数据变化之后立即使用Vue.nextTick(callback)；这样回调函数会在DOM更新完成后被调用，就可以拿到最新的DOM元素了。 123456789101112//第一个demothis.msg = &#x27;我是测试文字&#x27;this.$nextTick(()=&gt;&#123; //20 console.log(document.querySelector(&#x27;.msg&#x27;).offsetHeight)&#125;)//第二个demothis.childName = &#x27;我是子组件名字&#x27;this.$nextTick(()=&gt;&#123; //子组件name：我是子组件名字 this.$refs.child.showName()&#125;) nextTick源码分析 了解了nextTick的用法和原理之后，我们就来看一下Vue是怎么来实现这波“操作”的。 Vue把nextTick的源码单独抽到一个文件中，/src/core/util/next-tick.js，删掉注释也就大概六七十行的样子，让我们逐段来分析。 12345678910111213141516171819202122232425262728const callbacks = []let pending = falselet timerFuncexport function nextTick (cb?: Function, ctx?: Object) &#123; let _resolve callbacks.push(() =&gt; &#123; if (cb) &#123; try &#123; cb.call(ctx) &#125; catch (e) &#123; handleError(e, ctx, &#x27;nextTick&#x27;) &#125; &#125; else if (_resolve) &#123; _resolve(ctx) &#125; &#125;) if (!pending) &#123; pending = true timerFunc() &#125; // $flow-disable-line if (!cb &amp;&amp; typeof Promise !== &#x27;undefined&#x27;) &#123; return new Promise(resolve =&gt; &#123; _resolve = resolve &#125;) &#125;&#125; 我们首先找到nextTick这个函数定义的地方，看看它具体做了什么操作；看到它在外层定义了三个变量，有一个变量看名字就很熟悉：callbacks，就是我们上面说的队列；在nextTick的外层定义变量就形成了一个闭包，所以我们每次调用$nextTick的过程其实就是在向callbacks新增回调函数的过程。 callbacks新增回调函数后又执行了timerFunc函数，pending用来标识同一个时间只能执行一次。那么这个timerFunc函数是做什么用的呢，我们继续来看代码： 123456789101112131415161718192021222324252627282930313233343536export let isUsingMicroTask = falseif (typeof Promise !== &#x27;undefined&#x27; &amp;&amp; isNative(Promise)) &#123; //判断1：是否原生支持Promise const p = Promise.resolve() timerFunc = () =&gt; &#123; p.then(flushCallbacks) if (isIOS) setTimeout(noop) &#125; isUsingMicroTask = true&#125; else if (!isIE &amp;&amp; typeof MutationObserver !== &#x27;undefined&#x27; &amp;&amp; ( isNative(MutationObserver) || MutationObserver.toString() === &#x27;[object MutationObserverConstructor]&#x27;)) &#123; //判断2：是否原生支持MutationObserver let counter = 1 const observer = new MutationObserver(flushCallbacks) const textNode = document.createTextNode(String(counter)) observer.observe(textNode, &#123; characterData: true &#125;) timerFunc = () =&gt; &#123; counter = (counter + 1) % 2 textNode.data = String(counter) &#125; isUsingMicroTask = true&#125; else if (typeof setImmediate !== &#x27;undefined&#x27; &amp;&amp; isNative(setImmediate)) &#123; //判断3：是否原生支持setImmediate timerFunc = () =&gt; &#123; setImmediate(flushCallbacks) &#125;&#125; else &#123; //判断4：上面都不行，直接用setTimeout timerFunc = () =&gt; &#123; setTimeout(flushCallbacks, 0) &#125;&#125; 这里出现了好几个isNative函数，这是用来判断所传参数是否在当前环境原生就支持；例如某些浏览器不支持Promise，虽然我们使用了垫片(polify)，但是isNative(Promise)还是会返回false。 可以看出这边代码其实是做了四个判断，对当前环境进行不断的降级处理，尝试使用原生的Promise.then、MutationObserver和setImmediate，上述三个都不支持最后使用setTimeout；降级处理的目的都是将flushCallbacks函数放入微任务(判断1和判断2)或者宏任务(判断3和判断4)，等待下一次事件循环时来执行。MutationObserver是Html5的一个新特性，用来监听目标DOM结构是否改变，也就是代码中新建的textNode；如果改变了就执行MutationObserver构造函数中的回调函数，不过是它是在微任务中执行的。 那么最终我们顺藤摸瓜找到了最终的大boss：flushCallbacks；nextTick不顾一切的要把它放入微任务或者宏任务中去执行，它究竟是何方神圣呢？让我们来一睹它的真容： 12345678function flushCallbacks () &#123; pending = false const copies = callbacks.slice(0) callbacks.length = 0 for (let i = 0; i &lt; copies.length; i++) &#123; copies[i]() &#125;&#125; 本来以为有多复杂的flushCallbacks，居然不过短短的8行。它所做的事情也非常的简单，把callbacks数组复制一份，然后把callbacks置为空，最后把复制出来的数组中的每个函数依次执行一遍；所以它的作用仅仅是用来执行callbacks中的回调函数。 总结 到这里，整体nextTick的代码都分析完毕了，总结一下它的流程就是： 把回调函数放入callbacks等待执行 将执行函数放到微任务或者宏任务中 事件循环到了微任务或者宏任务，执行函数依次执行callbacks中的回调 再回到我们开头说的setTimeout，可以看出来nextTick是对setTimeout进行了多种兼容性的处理，宽泛的也可以理解为将回调函数放入setTimeout中执行；不过nextTick优先放入微任务执行，而setTimeout是宏任务，因此nextTick一般情况下总是先于setTimeout执行，我们可以在浏览器中尝试一下： 12345678910setTimeout(()=&gt;&#123; console.log(1)&#125;, 0)this.$nextTick(()=&gt;&#123; console.log(2)&#125;)this.$nextTick(()=&gt;&#123; console.log(3)&#125;)//运行结果 2 3 1 最后验证猜想，当前宏任务执行完成后，优先执行两个微任务，最后再执行宏任务。","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"源码","slug":"SourceCode","permalink":"http://xieyufei.com/tags/SourceCode/"},{"name":"Vue","slug":"Vue","permalink":"http://xieyufei.com/tags/Vue/"}]},{"title":"一文读懂JS中类、原型和继承","date":"2020-04-10T04:12:12.000Z","path":"2020/04/10/Js-Class-Inherit.html","text":"很多前端小伙伴，包括我自己在开始学习JS时对__proto__和ptototype这两个概念时都是一脸懵逼，面试时遇到原型链的问题总是瑟瑟发抖；不过真正的勇士敢于直面难题，经过对原型链不断的探索，本文对JS中类和原型的概念进行了深入的讲解，同时从原型方面来了解JS中继承是什么。 构造函数和对象 首先让我们看一下，在其他语言中是怎么来定义类的。在JAVA中类可以看出是创建对象的模板，我们可以这样定义类： 1234567891011public class Person&#123; String breed; int age; String color; void barking()&#123; &#125; void hungry()&#123; &#125; void sleeping()&#123; &#125;&#125; 但是ES6之前都没有class，那么JS怎么定义类呢？在JS中函数是一等公民，我们可以通过构造函数（即JAVA中的类）来创建对象。所谓构造函数，就是提供了一个生成对象的模板并描述对象的基本结构的函数。一个构造函数，可以生成多个对象，每个对象都有相同的结构。总的来说，构造函数就是对象的模板，对象就是构造函数的实例。 12345678910111213// Person类function Person(name) &#123; // 实例属性 this.name = name // 实例方法 this.sayName = function() &#123; return this.name &#125;&#125;var person1 = new Person(&#x27;xyf1&#x27;)var person2 = new Person(&#x27;xyf2&#x27;)//trueconsole.log(person1.constructor === Person) 我们通过new来构建实例化对象，类函数中的this总是指向实例化的对象，每一个实例对象都有一个不可枚举的属性constructor属性来指向构造函数，即Person。 我们把person1打印出来看一下到底有什么： 实例对象中可以看到我们在类中定义的name属性和sayName方法都有了，但是constructor属性并没有，但是却能取到值。 构造函数缺点 所有的实例对象都会单独创建自己的属性和方法，不同实例对象之间无法共享通用的属性。 123456//xyf1person1.sayName()//xyf2person2.sayName()//falseperson1.sayName === person2.sayName 但是有的属性或者方法是共有的，我们希望每个实例对象创建的时候就能有，比如说每个人天生就会哭（cry），不用一出生的时候还要“手把手教”。 原型对象prototype 为了解决实例对象之间共享属性的问题，JS提供了prototype属性。 123456789101112131415function Person(name) &#123; // 实例属性 this.name = name // 实例方法 this.sayName = function() &#123; return this.name &#125;&#125;Person.prototype.cry = function()&#123; console.log(&#x27;cry&#x27;)&#125;var person1 = new Person(&#x27;xyf1&#x27;)var person2 = new Person(&#x27;xyf2&#x27;)//trueperson1.cry === person2.cry prototype是从一个函数指向一个对象，即函数才有prototype属性。它的作用是让该构造函数创建的所有实例对象们都能找到公用的属性和方法。任何函数在创建实例对象的时候，其实会关联该函数的prototype对象。因此我们继续把原型图补充完整： 需要注意的是，我们可以修改原型对象的引用，但是仍需要把constructor属性指向回构造函数；上面的cry函数绑定我们可以这样改写： 123456Person.prototype = &#123; constructor: Person, cry: function()&#123; console.log(&#x27;cry&#x27;) &#125;&#125; 原型链 有了原型对象，我们知道了，实例对象的属性和方法，有可能是定义在自身，也有可能是定义在他的原型对象上。通过上面的cry函数我们可以看出，实例对象能够直接获取原型对象上的属性和方法，那么它是怎么获取的呢？在上面打印的person1中我们发现有一个特别的属性__proto__展开看一下： 因此__proto__指向了实例对象的原型对象；当你访问一个对象上没有的属性时，对象就会去__proto__上面找，如果还是找不到，就会继续找原型对象的__proto__，直到原型对象为null；因此__proto__构成了一条原型链。 同时我们也解答了上面实例对象上没有constructor属性的问题，constructor属性真正存在于原型对象上，所以实例对象才能获取到，我们继续完善原型图（虚线表示该属性或方法并不是真正存在）： 同时，原型对象也是一个对象，既然是对象，那么肯定也有它自己的原型对象，那么它的原型对象是谁呢？我们知道，JS中所有的对象都是Object的实例，并继承Object.prototype的属性和方法；字面量var a = &#123;&#125;实际上也是new Object()的语法糖，因此： 12345678var obj1 = &#123;&#125;var obj2 = new Object()//trueobj1.__proto__ === Object.prototype//trueobj2.__proto__ === Object.prototype//truePerson.prototype.__proto__ === Object.prototype 我们继续完善原型图： constructor 我们说过constructor用来指向构造函数；同时，constructor真正存在于原型对象上，因此，我们可以得到下面的等式关系： 12//truePerson.prototype.constructor === Person 在学数据类型判断的时候学过，constructor可以用来进行数据类型的判断： 123456console.log((2).constructor === Number); // true console.log((true).constructor === Boolean);// true console.log((&#x27;str&#x27;).constructor === String);// true console.log(([]).constructor === Array);// true console.log((function() &#123;&#125;).constructor === Function);// true console.log((&#123;&#125;).constructor === Object);// true 这种方式看起来能判断所有类型，但是一旦我们更改了原型对象，这种方式就不可靠了。 123456function Fn()&#123;&#125;;Fn.prototype = new Array(); var f = new Fn();console.log(f.constructor===Fn); // falseconsole.log(f.constructor===Array); // true 在JS中，函数本身也可以看成是对象，对这种又是函数，又是对象，有一个特殊的称呼：函数对象；我们调用函数的fn.call和fn.apply其实调用的是继承自其原型对象上的Function.prototype.call和Function.prototype.apply，因此函数都是Function函数的实例对象；既然是实例对象，所以Person函数也拥有__proto__和constructor属性，我们来看一下函数的属性： 123456789101112//ƒ Function() &#123; [native code] &#125;console.log(Person.constructor)//truePerson.constructor === Function//falsePerson.hasOwnProperty(&#x27;constructor&#x27;)//ƒ () &#123; [native code] &#125;console.log(Person.__proto__)//truePerson.__proto__.hasOwnProperty(&#x27;constructor&#x27;)//trueFunction.prototype.hasOwnProperty(&#x27;constructor&#x27;) 可以看出来，Person构造函数和JS普通的对象没有任何区别，有自己的constructor属性，指向Function函数，说明Person函数是Function函数的实例对象；而且constructor属性不在Person本身，而在其原型对象Function.prototype上，因此我们再次完善一下原型图： 鸡生蛋蛋生鸡 到这里，我们发现最终原型图指向了四个基本的东西：Object、Object.prototype、Function和Function.prototype，他们之间的关系是整个原型关系里面最难理解的，为了避免干扰，我们给他们四个单独开个图： 我们知道Object函数和Person函数一样，都是函数对象，因此都是Function函数的实例对象。 12345678910//trueObject.constructor === Function//trueObject instanceof Function//trueObject instanceof Object//falseObject.hasOwnProperty(&#x27;constructor&#x27;)//trueObject.__proto__ === Function.prototype 因此我们完善Object和Function的关系： 既然Object是构造函数，我们又想起Function也能通过new Function()来构造匿名函数，同时自己又是自己的constructor。 12345678910//trueFunction.constructor === Function//trueFunction instanceof Object//trueFunction instanceof Function//falseFunction.hasOwnProperty(&#x27;constructor&#x27;)//trueFunction.__proto__ === Function.prototype 同时我们猜测Function.prototype和Person.prototype一样是个对象，因此它的原型对象肯定就是Object.prototype。 12//trueFunction.prototype.__proto__ === Object.prototype 我们继续完善原型图： 这样，整个原型链最有意思的一幕出现了；Object是构造函数，继承了Function.prototype；Function函数也是对象，继承了Object.prototype，那么到底是先有了Object，还是先有Function？这似乎是一个无解的悖论。 我们发现导致鸡和蛋问题的根本原因在于Function.__proto__指向了Function.prototype，让Function继承了Object.prototype上的方法，因此我们需要对Function.prototype来进一步的了解： 12345678910//functiontypeof Function.prototype//undefinedFunction.prototype()//trueFunction.prototype instanceof Object//falseFunction.prototype instanceof Function//undefinedFunction.prototype.prototype 我们发现Function.prototype是个特殊的函数对象，但是没有prototype属性；针对上面的代码，我们梳理了以下几点： Function.prototype像普通函数一样可以调用，但总是返回undefined Function.prototype继承于Object.prototype，并且没有prototype这个属性 因此Function.prototype是个标准的内置对象，它继承于Object.prototype，而我们知道Object.prototype===null，说明原型链到Object.prototype就终止了。 结论：先有 Object.prototype（原型链顶端），Function.prototype 继承 Object.prototype 而产生，最后，Function 和Object和其它构造函数继承Function.prototype而产生。 静态属性和方法 所谓的静态方法，是指不需要声明类的实例就可以使用的方法。在JAVA中我们可以直接在类中加一个static定义静态方法 123456789public class Person&#123; static int num = 0; public static void say() &#123; System.out.println(&quot;hello&quot;); &#125; public static void main(String[] args)&#123; Person.say(); &#125;&#125; 在ES5中，我们直接将它作为类函数的属性即可： 12345678910function Person()&#123;&#125;Person.staticSay = function()&#123; console.log(&#x27;static say&#x27;) //ƒ Person()&#123;&#125; console.log(this)&#125;Person.num = 10Person.staticSay()//10console.log(Person.num) 静态方法和实例方法最主要的区别就是实例方法可以访问到实例对象，可以对实例进行操作，而静态方法一般用于跟实例无关的操作。静态方法最常见的是在jQuery的一些工具函数中，比如$.ajax()、$.trim()，可以看出来这两个函数也是直接定义在jQuery对象（即$对象）上的，因为其不需要获取DOM元素$(‘div’)。 手写instanceof 除了constructor，我们还有instanceof来进行数据类型的判断；instanceof主要用来判断一个实例是否属于某种类型，让我们先看一下instanceof的简单用法： 123456//true[] instanceof Array//trueperson1 instanceof Person//trueperson1 instanceof Object instanceof第一个变量是一个对象A，第二个变量是一个函数B，沿着A的原型链__proto__一直向上找，如果能找到一个__proto__等于B的prototype，则返回true；如果找到终点还没找到则返回false。 1234567891011121314151617function _instanceOf(A, B)&#123; if(!A || !B)&#123; return false &#125; var O = B.prototype A = A.__proto__ while(true)&#123; if(A === null)&#123; return false &#125; else if(O === A)&#123; return true &#125; else &#123; //每次循环继续找__proto__ A = A.__proto__ &#125; &#125;&#125; 手写new 通过上面的的原型链，我们知道了new本质上就是调用构造函数生成一个对象，这个对象能够访问构造函数的的原型对象，因为我们来尝试模拟一下new的实现。 12345678function myNew(Fn)&#123; var obj = new Object() Fn.call(obj) obj.__proto__ = Fn.prototype return obj&#125;var newObj = myNew(Person)console.log(newObj) 我们首先构建了一个空对象；然后将空对象作为this，调用构造函数绑定参数；最后将该对象的__proto__指向构造函数的原型对象。 可以看到生成出来的对象该有的属性都有了，原型链也绑定成功了，但是存在的问题就是不能进行传参，因此我们进行一下改进： 12345678function myNew(Fn, ...param)&#123; var obj = new Object() Fn.call(obj, ...param) obj.__proto__ = Fn.prototype return obj&#125;var newObj = myNew(Person, &#x27;new obj&#x27;)console.log(newObj) 可以看到返回的对象已经和原生new生成出来的几乎一模一样了。但是我们对构造函数进行一些修改： 1234567891011function Person(name) &#123; this.name = name this.sayName = function() &#123; return this.name &#125; return 2// return &#x27;hello&#x27;// return &#123;a:3&#125;// return []// return function()&#123;&#125;&#125; 我们在构造函数中返回了多种类型，经过测试发现：如果构造函数返回引用类型，new生成的就是返回的对象；如果返回基本数据类型，new生成新的对象。因此我们终极版的new函数如下： 1234567function myNew(Fn, ...param)&#123; var obj = new Object() var result = Fn.call(obj, ...param) obj.__proto__ = Fn.prototype return typeof result === &#x27;object&#x27; || typeof result === &#x27;function&#x27; ? result : obj&#125; ES5继承 所谓的继承，就是把子类继承父类所有的属性和方法；同时我们也知道父类上的属性和方法不仅在自身构造函数，原型链上也会有属性和方法，因此我们也需要继承过来。 既然继承是继承父类的属性和方法，那么我们上面的myNew函数也相当于是一种继承；让我们再看看看还有哪些继承的方式。 原型链继承123456789101112131415function Parent () &#123; this.name = &#x27;xyf&#x27;; this.sayName = function() &#123; return this.name &#125;&#125;Parent.prototype.cry = function () &#123; console.log(&#x27;cry&#x27;)&#125;function Child () &#123;&#125;Child.prototype = new Parent();var child1 = new Child();console.log(child1.sayName())child1.cry() 我们把父类的实例挂载到子类的原型上，那么所有的子类就能访问到父类的属性和方法了，但是由于所有子类共享原型对象，所以会存在以下问题： 问题1：父类引用类型的属性被子类共享，一旦改变，所有子类实例引用的都将改变。 123456789101112131415function Parent () &#123; this.name = [&#x27;xyf1&#x27;, &#x27;xyf2&#x27;];&#125;function Child () &#123;&#125;Child.prototype = new Parent();var child1 = new Child();child1.name.push(&#x27;xyf3&#x27;)//[&quot;xyf1&quot;, &quot;xyf2&quot;, &quot;xyf3&quot;]console.log(child1.name);var child2 = new Child();//[&quot;xyf1&quot;, &quot;xyf2&quot;, &quot;xyf3&quot;]console.log(child2.name); 问题2：创建子类实例的时候，不能向父类传参数。 问题3：不能继承静态方法。 构造函数继承123456789101112131415161718192021function Parent (name) &#123; this.name = name; this.color = [&#x27;red&#x27;,&#x27;yellow&#x27;]&#125;Parent.prototype.cry = function()&#123; console.log(&#x27;cry&#x27;)&#125;function Child (name) &#123; Parent.call(this, name);&#125;var child1 = new Child(&#x27;xyf&#x27;);child1.color.push(&#x27;blue&#x27;);//[&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;blue&#x27;]console.log(child1.color);//undefinedconsole.log(child1.cry)var child2 = new Child(&#x27;corner&#x27;);//[&#x27;red&#x27;,&#x27;yellow&#x27;]console.log(child2.color); 每次创建子类实例的时候调用父类的构造函数，避免了引用类型的属性被所有实例共享，也可以向父类传参数；但是没有继承父类原型上的属性和方法。 组合继承1234567891011function Parent (name) &#123; this.name = name; this.color = [&#x27;red&#x27;,&#x27;yellow&#x27;]&#125;Parent.prototype.cry = function()&#123; console.log(&#x27;cry&#x27;)&#125;function Child (name) &#123; Parent.call(this, name);&#125;Child.prototype = new Parent() 融合了原型链继承和构造函数继承的优点，是JS中常用的继承方式。 ES6继承 ES6新增了class关键词，用来定义一个类，和JAVA中的有种似曾相识的感觉；但是本质上其实是ES5构造函数的语法糖，大多部分功能ES5都能实现： 123456789101112131415161718192021222324class Person&#123; constructor(name)&#123; this.name = name &#125; sayName()&#123; return this.name &#125; static staticSay() &#123; console.log(&#x27;static say&#x27;); &#125;&#125;Person.prototype.cry = function()&#123; console.log(&#x27;cry&#x27;)&#125;//static sayPerson.staticSay()var person1 = new Person(&#x27;corner&#x27;)//cryperson1.cry()//cornerperson1.sayName()//trueperson1.constructor === Person ES6的继承可以通过extends关键词实现，比ES5的修改原型链实现继承要更清晰和方便： 123456789101112131415161718192021222324252627282930313233class Person&#123; constructor(name)&#123; this.name = name &#125; sayName()&#123; return this.name &#125; static staticSay() &#123; console.log(&#x27;static say&#x27;); &#125;&#125;Person.prototype.cry = function()&#123; console.log(&#x27;cry&#x27;)&#125;class Child extends Person&#123; constructor(name,color)&#123; super(name) this.color = color &#125; sayColor()&#123; return &#x27;my color is:&#x27;+ this.color &#125;&#125;var child1 = new Child(&#x27;child1&#x27;, &#x27;black&#x27;)//child1console.log(child1.sayName())//my color is:blackconsole.log(child1.sayColor())//crychild1.cry()//static sayChild.staticSay() 可以很清晰的看出来子类继承了父类本身以及原型上的属性和方法。同时，在ES5中所有的继承我们发现都不支持静态函数的继承，但是在ES6中支持。 参考 从proto和prototype来深入理解JS对象和原型链","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"面试","slug":"Interview","permalink":"http://xieyufei.com/tags/Interview/"}]},{"title":"Vue中组件通信的方式","date":"2020-03-20T03:00:00.000Z","path":"2020/03/20/Vue-Communicate.html","text":"vue是数据驱动视图更新的框架, 所以对于vue来说组件间的数据通信非常重要；我们常用的方式莫过于通过props传值给子组件，但是vue还有其他很多不常用的通信方式，了解他们，也许在以后在写代码的时候能给你带来更多的思路和选择。 prop/$emit 父组件通过prop的方式向子组件传递数据，而通过$emit子组件可以向父组件通信。 123456789101112131415161718192021222324//Parent.vue&lt;template&gt; &lt;div&gt; 当前选中：&#123;&#123; current &#125;&#125; &lt;Child :list=&quot;list&quot; @change=&quot;changeCurrent&quot;&gt;&lt;/Child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Child from &quot;./child&quot;;export default &#123; data() &#123; return &#123; current: 0, list: [&quot;红楼梦&quot;, &quot;水浒传&quot;, &quot;三国演义&quot;, &quot;西游记&quot;] &#125;; &#125;, components: &#123; Child &#125;, methods: &#123; changeCurrent(num) &#123; this.current = num; &#125; &#125;&#125;;&lt;/script&gt; 我们可以通过prop向子组件传递数据；用一个形象的比喻来说，父子组件之间的数据传递相当于自上而下的下水管子，管子中的水就像数据，水只能从上往下流，不能逆流。这也正是Vue的设计理念之单向数据流。而prop正是管道与管道之间的一个衔接口，这样水（数据）才能往下流。 12345678910111213141516171819202122232425//Child.vue&lt;template&gt; &lt;div&gt; &lt;template v-for=&quot;(item, index) in list&quot;&gt; &lt;div @click=&quot;clickItem(index)&quot; :key=&quot;index&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/div&gt; &lt;/template&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; list: &#123; type: Array, default: () =&gt; &#123; return []; &#125; &#125; &#125;, methods: &#123; clickItem(index) &#123; this.$emit(&quot;change&quot;, index); &#125; &#125;&#125;;&lt;/script&gt; 在子组件中我们通过props对象定义了接收父组件值的类型和默认值，然后通过$emit()触发父组件中的自定义事件。prop/$emit传递数据的方式在日常开发中用的非常多，一般涉及到组件开发都是基于通过这种方式；通过父组件中注册子组件，并在子组件标签上绑定对自定义事件的监听。他的优点是传值取值方便简洁明了，但是这种方式的缺点是： 由于数据是单向传递，如果子组件需要改变父组件的props值每次需要给子组件绑定对应的监听事件。 如果父组件需要给孙组件传值，需要子组件进行转发，较为不便。 .sync修饰符 有些情况下，我们希望在子组件能够“直接修改”父组件的prop值，但是双向绑定会带来维护上的问题；vue提供了一种解决方案，通过语法糖.sync修饰符。 .sync修饰符在 vue1.x 的时候曾作为双向绑定功能存在，即子组件可以修改父组件中的值。但是它违反了单向数据流的设计理念，所以在 vue2.0 的时候被干掉了。但是在 vue2.3.0+ 以上版本又重新引入了。但是这次它只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的v-on监听器。说白了就是让我们手动进行更新父组件中的值了，从而使数据改动来源更加的明显。 12345678910111213141516171819202122//Parent.vue&lt;template&gt; &lt;div&gt; &lt;Child :msg.sync=&quot;msg&quot; :num.sync=&quot;num&quot;&gt;&lt;/Child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Child from &quot;./child&quot;;export default &#123; name: &quot;way2&quot;, components: &#123; Child &#125;, data() &#123; return &#123; msg: &quot;hello every guys&quot;, num: 0 &#125;; &#125;&#125;;&lt;/script&gt; 我们在Child组件传值时给每个值添加一个.sync修饰，在编译时会被扩展为如下代码： 1&lt;Child :msg=&quot;msg&quot; @update.msg=&quot;val =&gt; msg = val&quot; :num.sync=&quot;num&quot; @update.num=&quot;val =&gt; num = val&quot;&gt;&lt;/Child&gt; 因此子组件中只需要显示的触发update的更新事件： 1234567891011121314151617181920212223242526272829303132333435363738//Child.vue&lt;template&gt; &lt;div&gt; &lt;div @click=&quot;clickRevert&quot;&gt;点击更新字符串：&#123;&#123; msg &#125;&#125;&lt;/div&gt; &lt;div&gt;当前值：&#123;&#123; num &#125;&#125;&lt;/div&gt; &lt;div @click=&quot;clickOpt(&#x27;add&#x27;)&quot; class=&quot;opt&quot;&gt;+&lt;/div&gt; &lt;div @click=&quot;clickOpt(&#x27;sub&#x27;)&quot; class=&quot;opt&quot;&gt;-&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; msg: &#123; type: String, default: &quot;&quot; &#125;, num: &#123; type: Number, default: 0 &#125; &#125;, methods: &#123; clickRevert() &#123; let &#123; msg &#125; = this; this.$emit(&quot;update:msg&quot;,msg.split(&quot;&quot;).reverse().join(&quot;&quot;)); &#125;, clickOpt(type = &quot;&quot;) &#123; let &#123; num &#125; = this; if (type == &quot;add&quot;) &#123; num++; &#125; else &#123; num--; &#125; this.$emit(&quot;update:num&quot;, num); &#125; &#125;&#125;;&lt;/script&gt; 这种“双向绑定”的操作是不是看着似曾相识？是的，v-model本质上也是一种语法糖，只不过它触发的不是update方法而是input方法；而且v-model没有.sync来的更加灵活，v-model只能绑定一个值。 总结：.sync修饰符优化了父子组件通信的传值方式，不需要在父组件再写多余的函数来修改赋值。 $attrs和$listeners 当需要用到从A到C的跨级通信时，我们会发现prop传值非常麻烦，会有很多冗余繁琐的转发操作；如果C中的状态改变还需要传递给A，使用事件还需要一级一级的向上传递，代码可读性就更差了。 因此vue2.4+版本提供了新的方案：$attrs和$listeners，我们先来看一下官网对$attrs的描述： 包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=”$attrs” 传入内部组件——在创建高级别的组件时非常有用。 这一大段话第一次读非常的绕口，而且晦涩难懂，不过没关系，我们直接上代码： 1234567891011121314151617181920212223242526272829303132//Parent.vue&lt;template&gt; &lt;div&gt; &lt;Child :notUse=&quot;&#x27;not-use&#x27;&quot; :childMsg=&quot;childMsg&quot; :grandChildMsg=&quot;grandChildMsg&quot; @onChildMsg=&quot;onChildMsg&quot; @onGrandChildMsg=&quot;onGrandChildMsg&quot; &gt;&lt;/Child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Child from &quot;./child&quot;;export default &#123; data() &#123; return &#123; childMsg: &quot;hello child&quot;, grandChildMsg: &quot;hello grand child&quot; &#125;; &#125;, components: &#123; Child &#125;, methods: &#123; onChildMsg(msg) &#123; this.childMsg = msg; &#125;, onGrandChildMsg(msg) &#123; this.grandChildMsg = msg; &#125; &#125;&#125;;&lt;/script&gt; 我们首先定义了两个msg，一个给子组件展示，另一个给孙组件展示，首先将这两个数据传递到子组件中，同时将两个改变msg的函数传入。 12345678910111213141516171819202122232425262728//child.vue&lt;template&gt; &lt;div class=&quot;box&quot;&gt; &lt;div @click=&quot;clickMsg&quot;&gt;&#123;&#123; childMsg &#125;&#125;&lt;/div&gt; &lt;div&gt;$attrs: &#123;&#123; $attrs &#125;&#125;&lt;/div&gt; &lt;GrandChild v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;&gt;&lt;/GrandChild&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import GrandChild from &quot;./grand-child&quot;;export default &#123; props: &#123; childMsg: &#123; type: String &#125; &#125;, methods: &#123; clickMsg() &#123; let &#123; childMsg &#125; = this; this.$emit( &quot;onChildMsg&quot;, childMsg.split(&quot;&quot;).reverse().join(&quot;&quot;) ); &#125; &#125;, components: &#123; GrandChild &#125;&#125;;&lt;/script&gt; 在子组件中我们通过props获取子组件所需要的参数，即childMsg；剩余的参数就被归到了$attrs对象中，我们可以在页面中展示出来，然后把它继续往孙组件中传；同时把所有的监听函数归到$listeners，也继续往下传。 12345678910111213141516171819202122//grand-child.vue&lt;template&gt; &lt;div class=&quot;box1&quot; @click=&quot;clickMsg&quot;&gt;grand-child:&#123;&#123; grandChildMsg &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; grandChildMsg: &#123; type: String &#125; &#125;, methods: &#123; clickMsg() &#123; let &#123; grandChildMsg &#125; = this; this.$emit( &quot;onGrandChildMsg&quot;, grandChildMsg.split(&quot;&quot;).reverse().join(&quot;&quot;) ); &#125; &#125;&#125;;&lt;/script&gt; 在孙组件中我们继续取出所需要的数据进行展示或者操作，运行结果如下： 当我们在组件上赋予一个非prop声明时，比如child组件上的notuse和grandchildmsg属性我们没有用到，编译之后的代码会把这个属性当成原始属性对待，添加到html原生标签上，所以我们查看代码是这样的： 这样会很难看，我们可以在组件上加上inheritAttrs属性将它去掉： 1234export default &#123; mounted()&#123;&#125;, inheritAttrs: false,&#125; 总结：$attrs和$listeners很好的解决了跨一级组件传值的问题。 provide和inject 虽然$attrs和$listeners可以很方便的从父组件传值到孙组件，但是如果跨了三四级，并且想要的数据已经被上级组件取出来，这时$attrs就不能解决了。 provide/inject是vue2.2+版本新增的属性，简单来说就是父组件中通过provide来提供变量, 然后再子组件中通过inject来注入变量。这里inject注入的变量不像$attrs，只能向下一层；inject不论子组件嵌套有多深，都能获取到。 123456789101112131415161718192021222324252627282930//Parent.vue&lt;template&gt; &lt;div&gt; &lt;Child&gt;&lt;/Child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Child from &quot;./child&quot;;export default &#123; components: &#123; Child &#125;, data() &#123; return &#123; childmsg: &quot;hello child&quot;, grandmsg: &quot;hello grand child&quot; &#125;; &#125;, provide() &#123; return &#123; childmsg: this.childmsg, grandmsg: this.grandmsg &#125;; &#125;, mounted() &#123; setTimeout(() =&gt; &#123; this.childmsg = &quot;hello new child&quot;; this.grandmsg = &quot;hello new grand child&quot;; &#125;, 2000); &#125;,&#125;;&lt;/script&gt; 我们在父组件通过provide注入了两个变量，并且在两秒之后修改变量的值，然后就在子组件和孙组件取出来。 12345678910111213141516171819202122232425262728//child.vue&lt;template&gt; &lt;div class=&quot;box&quot;&gt; &lt;div&gt;child-msg:&#123;&#123; childmsg &#125;&#125;&lt;/div&gt; &lt;div&gt;grand-msg:&#123;&#123; grandmsg &#125;&#125;&lt;/div&gt; &lt;GrandChild&gt;&lt;/GrandChild&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import GrandChild from &quot;./grand-child&quot;;export default &#123; inject: [&quot;childmsg&quot;, &quot;grandmsg&quot;], components: &#123; GrandChild &#125;,&#125;;&lt;/script&gt;//grand-child.vue&lt;template&gt; &lt;div class=&quot;box&quot;&gt; &lt;div&gt;child-msg:&#123;&#123; childmsg &#125;&#125;&lt;/div&gt; &lt;div&gt;grand-msg:&#123;&#123; grandmsg &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;GrandChild&quot;, inject: [&quot;childmsg&quot;, &quot;grandmsg&quot;],&#125;;&lt;/script&gt; 可以看到子组件和孙组件都能取出值，并且渲染出来。需要注意的是，一旦子组件注入了某个数据，在data中就不能再声明这个数据了。 同时，过了两秒后我们发现childmsg和grandmsg的值并没有按照预期的改变，也就是说子组件并没有响应修改后的值，官网的介绍是这么说的： 提示：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。 vue并没有把provide和inject设计成响应式的，这是vue故意的，但是如果传入了一个可监听的对象，那么就可以响应了： 12345678910111213141516171819202122export default &#123; data() &#123; return &#123; respondData: &#123; name: &quot;hello respond&quot; &#125; &#125;; &#125;, provide() &#123; return &#123; respondData: this.respondData &#125;; &#125;, mounted() &#123; setTimeout(() =&gt; &#123; this.respondData.name = this.respondData.name .split(&quot;&quot;) .reverse() .join(&quot;&quot;); &#125;, 2000); &#125;,&#125; 那么为什么上面的props和$attrs都是响应式的，连破坏“单向数据流”的.sync修饰符都是响应式的，但到了provide/inject就不是响应式的了呢？在网上找了半天的资料也没有找到确切的答案，本文就此结束。 就这么结束了吗？当然没有！在一(zi)个(ji)哥(xue)们(xi)的帮(yuan)助(ma)下，我总算找到了答案。首先我们试想一下，如果有多个子组件同时依赖于一个父组件提供的数据，那么一旦父组件修改了该值，那么所有组件都会受到影响，这是我们不希望看到的；这一方面增加了耦合度，另一方面使得数据变化不可控制。接着看一下vue是怎么来实现provide/inject的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//src/core/instance/inject.js//部分核心源码export function initProvide (vm: Component) &#123; const provide = vm.$options.provide if (provide) &#123; vm._provided = typeof provide === &#x27;function&#x27; ? provide.call(vm) : provide &#125;&#125;export function initInjections (vm: Component) &#123; const result = resolveInject(vm.$options.inject, vm) if (result) &#123; observerState.shouldConvert = false Object.keys(result).forEach(key =&gt; &#123; defineReactive(vm, key, result[key]) &#125;) observerState.shouldConvert = true &#125;&#125;export function resolveInject (inject: any, vm: Component): ?Object &#123; if (inject) &#123; const result = Object.create(null) const keys = hasSymbol ? Reflect.ownKeys(inject).filter(key =&gt; &#123; return Object.getOwnPropertyDescriptor(inject, key).enumerable &#125;) : Object.keys(inject) for (let i = 0; i &lt; keys.length; i++) &#123; const key = keys[i] const provideKey = inject[key].from let source = vm while (source) &#123; if (source._provided &amp;&amp; provideKey in source._provided) &#123; result[key] = source._provided[provideKey] break &#125; source = source.$parent &#125; if (!source) &#123; if (&#x27;default&#x27; in inject[key]) &#123; const provideDefault = inject[key].default result[key] = typeof provideDefault === &#x27;function&#x27; ? provideDefault.call(vm) : provideDefault &#125; &#125; &#125; return result &#125;&#125; 可以看到初始化provide的时候将父组件的provide挂载到_provided，但它不是一个响应式的对象；然后子组件通过$parent向上查找所有父组件的_provided获取第一个有目标属性的值，然后遍历绑定到子组件上；因为只是初始化的时候绑定的，而且_provided也不是响应式的，所以造成了provide/inject的这种特性。 那么provide/inject这么危险，又不是响应式的，它能拿来做什么呢？打开element-ui的源码搜索provide，我们可以看到非常多的组件使用了provide/inject，我们就拿form、form-item和button举个例子。 form和form-item都可以传入一个属性size来控制子组件的尺寸，但是子组件的位置是不固定的，可能会嵌套了好几层el-row或者el-col，如果一层一层的通过props传size下去会很繁琐，这是provide/inject就派上用处了。 123456789101112131415161718192021222324252627//form-item.vueexport default &#123; provide() &#123; return &#123; elFormItem: this &#125;; &#125;,&#125;//button.vueexport default &#123; inject: &#123; elForm: &#123; default: &#x27;&#x27; &#125;, elFormItem: &#123; default: &#x27;&#x27; &#125; &#125;, computed: &#123; _elFormItemSize() &#123; return (this.elFormItem || &#123;&#125;).elFormItemSize; &#125;, buttonSize() &#123; return this.size || this._elFormItemSize || (this.$ELEMENT || &#123;&#125;).size; &#125;, &#125;,&#125; 我们通过父组件将elFormItem本身注入到子组件中，子组件通过inject获取父组件本身然后动态地计算buttonSize。 总结：provide/inject能够解决多层组件嵌套传值的问题，但是是非响应的，即provide与inject之间没有绑定，注入的值是在子组件初始化过程中决定的。 EventBus EventBus我刚开始直接翻译理解为事件车，但比较官方的翻译是事件总线。它的实质就是创建一个vue实例，通过一个空的vue实例作为桥梁实现vue组件间的通信。它是实现非父子组件通信的一种解决方案，所有的组件都可以上下平行地通知其他组件，但也就是太方便所以若使用不慎，就会造成难以维护的“灾难”。 123//utils/event-bus.jsimport Vue from &quot;vue&quot;;export default new Vue(); 首先创造一个空的vue对象并将其导出，他是一个不具备DOM的组件，它具有的仅仅只是它实例方法而已，因此它非常的轻便。 123//main.jsimport bus from &quot;@/utils/event-bus&quot;;Vue.prototype.$bus = bus; 将其挂载到全局，变成全局的事件总线，这样在组件中就能很方便的调用了。 1234567891011121314151617//Parent.vue&lt;template&gt; &lt;div class=&quot;box&quot;&gt; &lt;Child1&gt;&lt;/Child1&gt; &lt;Child2&gt;&lt;/Child2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Child1 from &quot;./child1&quot;;import Child2 from &quot;./child2&quot;;export default &#123; components: &#123; Child1, Child2 &#125;&#125;;&lt;/script&gt; 我们先定义了两个子组件child1和child2，我们希望这两个组件能够直接给对方发送消息。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//child1.vue&lt;template&gt; &lt;div&gt; &lt;div class=&quot;send&quot; @click=&quot;clickSend&quot;&gt;发送消息&lt;/div&gt; &lt;template v-for=&quot;(item, index) in msgList&quot;&gt; &lt;div :key=&quot;index&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/div&gt; &lt;/template&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; msgList: [] &#125;; &#125;, mounted() &#123; this.$bus.$on(&quot;getMsg1&quot;, res =&gt; &#123; this.msgList.push(res); &#125;); &#125;, methods: &#123; clickSend() &#123; this.$bus.$emit(&quot;getMsg2&quot;, &quot;hello from1:&quot; + parseInt(Math.random() * 20)); &#125; &#125;&#125;;&lt;/script&gt;//child2.vue&lt;template&gt; &lt;div&gt; &lt;div class=&quot;send&quot; @click=&quot;clickSend&quot;&gt;发送消息&lt;/div&gt; &lt;template v-for=&quot;(item, index) in msgList&quot;&gt; &lt;div :key=&quot;index&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/div&gt; &lt;/template&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; msgList: [] &#125;; &#125;, mounted() &#123; this.$bus.$on(&quot;getMsg2&quot;, res =&gt; &#123; this.msgList.push(res); &#125;); &#125;, methods: &#123; clickSend() &#123; this.$bus.$emit(&quot;getMsg1&quot;, &quot;hello from2:&quot; + parseInt(Math.random() * 20)); &#125; &#125;&#125;;&lt;/script&gt; 我们初始化时在child1和child2中分别注册了两个接收事件，然后点击按钮时分别触发这两个自定义的事件，并传入数据，最后两个组件分别能接收到对方发送的消息，最后效果如下： 前面也提到过，如果使用不善，EventBus会是一种灾难，到底是什么样的“灾难”了？大家都知道vue是单页应用，如果你在某一个页面刷新了之后，与之相关的EventBus会被移除，这样就导致业务走不下去。还要就是如果业务有反复操作的页面，EventBus在监听的时候就会触发很多次，也是一个非常大的隐患。这时候我们就需要好好处理EventBus在项目中的关系。通常会用到，在页面或组件销毁时，同时移除EventBus事件监听。 12345export default&#123; destroyed()&#123; $EventBus.$off(&#x27;event-name&#x27;) &#125;&#125; 总结：EventBus可以用来很方便的实现兄弟组件和跨级组件的通信，但是使用不当时也会带来很多问题；所以适合逻辑并不复杂的小页面，逻辑复杂时还是建议使用vuex。 vuex 在vue组件开发中，经常会遇到需要将当前组件的状态传递给其他非父子组件组件，或者一个状态需要共享给多个组件，这时采用上面的方式就会非常麻烦。vue提供了另一个库vuex来解决数据传递的问题；刚开始上手会感觉vuex非常的麻烦，很多概念也容易混淆，不过不用担心，本文不深入讲解vuex。 vuex实现了单向的数据流，在全局定义了一个State对象用来存储数据，当组件要修改State中的数据时，必须通过Mutation进行操作。 1234567891011121314151617181920212223242526272829303132//store/count.jsexport default &#123; namespaced: true, state: &#123; num: 1 &#125;, mutations: &#123; ADD_NUM(state) &#123; state.num = state.num + 1; &#125;, SUB_NUM(state) &#123; state.num = state.num - 1; &#125; &#125;, actions: &#123; ADD_SYNC(&#123; commit &#125;) &#123; setTimeout(() =&gt; &#123; commit(&quot;ADD_NUM&quot;); &#125;, 1000); &#125;, SUB_SYNC(&#123; commit &#125;) &#123; setTimeout(() =&gt; &#123; commit(&quot;SUB_NUM&quot;); &#125;, 1000); &#125; &#125;&#125;;//store/index.jsimport count from &quot;./count&quot;;export default new Vuex.Store(&#123; modules: &#123; count &#125;,&#125;); 我们首先在全局定义了count.js模块用来存放数据和修改数据的方法，然后在全局引入。 12345678910111213141516171819202122232425262728293031323334//child.vue&lt;template&gt; &lt;div&gt; &lt;div&gt;当前：&#123;&#123; num &#125;&#125;&lt;/div&gt; &lt;div class=&quot;opt&quot; @click=&quot;clickAdd&quot;&gt;+&lt;/div&gt; &lt;div class=&quot;opt&quot; @click=&quot;clickSub&quot;&gt;-&lt;/div&gt; &lt;div class=&quot;opt&quot; @click=&quot;clickAddSync&quot;&gt;a+&lt;/div&gt; &lt;div class=&quot;opt&quot; @click=&quot;clickSubSync&quot;&gt;a-&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;Child&quot;, computed: &#123; num() &#123; return this.$store.state.count.num; &#125; &#125;, methods: &#123; clickAdd() &#123; this.$store.commit(&quot;count/ADD_NUM&quot;); &#125;, clickSub() &#123; this.$store.commit(&quot;count/SUB_NUM&quot;); &#125;, clickAddSync() &#123; this.$store.dispatch(&quot;count/ADD_SYNC&quot;); &#125;, clickSubSync() &#123; this.$store.dispatch(&quot;count/SUB_SYNC&quot;); &#125; &#125;&#125;;&lt;/script&gt; 我们就可以在任何组件中来调用mutations和actions中的方法操作数据了。vuex在数据传值和操作数据维护起来比较方便，但是有一定的学习成本。 $refs 有时候我们需要在vue中直接来操作DOM元素，比如获取DIV的高度，或者直接调用子组件的一些函数；虽然原生的JS也能获取到，但是vue为我们提供了更方便的一个属性：$refs。如果在普通的DOM元素上使用，获取到的就是DOM元素；如果用在子组件上，获取的就是组件的实例对象。 12345678910111213141516171819//child.vue&lt;template&gt; &lt;div&gt;初始化:&#123;&#123; num &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; num: 0 &#125;; &#125;, methods: &#123; addNum() &#123; this.num += 1; &#125;, subNum() &#123; this.num -= 1; &#125; &#125;&#125;;&lt;/script&gt; 我们首先创建一个简单的子组件，有两个函数用来增减num的值。 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div&gt; &lt;Child ref=&quot;child&quot;&gt;&lt;/Child&gt; &lt;div class=&quot;opt&quot; ref=&quot;opt_add&quot; @click=&quot;clickAddBtn&quot;&gt;+&lt;/div&gt; &lt;div class=&quot;opt&quot; ref=&quot;opt_sub&quot; @click=&quot;clickSubBtn&quot;&gt;-&lt;/div&gt; &lt;div class=&quot;opt&quot; ref=&quot;opt_show&quot; @click=&quot;clickShowBtn&quot;&gt;show&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Child from &quot;./child&quot;;export default &#123; components: &#123; Child &#125;, data() &#123; return &#123;&#125;; &#125;, methods: &#123; clickAddBtn() &#123; this.$refs.child.addNum(); &#125;, clickSubBtn() &#123; this.$refs.child.subNum(); &#125;, clickShowBtn() &#123; console.log(this.$refs.child); console.log(this.$refs.child.num); &#125; &#125;&#125;;&lt;/script&gt; 我们给子组件增加一个ref属性child，然后通过$refs.child来获取子组件的实例，通过实例来调用子组件中的函数。 可以看到我们获取到的是一个VueComponent对象，这个对象包括了子组件的所有数据和函数，可以对子组件进行一些操作。 $parent和$children 如果页面有多个相同的子组件需要操作的话，$refs一个一个操作起来比较繁琐，vue提供了另外的属性：$parent和$children来统一选择。 12345678910111213141516171819202122232425262728293031323334//child.vue&lt;template&gt; &lt;div&gt;child&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; mounted() &#123; console.log(this.$parent.show()); console.log(&quot;Child&quot;, this.$children, this.$parent); &#125;&#125;;&lt;/script&gt;//Parent.vue&lt;template&gt; &lt;div&gt; parent &lt;Child&gt;&lt;/Child&gt; &lt;Child&gt;&lt;/Child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Child from &quot;./child&quot;;export default &#123; components: &#123; Child &#125;, mounted() &#123; console.log(&quot;Parent&quot;, this.$children, this.$parent); &#125;, methods: &#123; show() &#123; return &quot;to child data&quot;; &#125; &#125;&#125;;&lt;/script&gt; 我们在父组件中插入了两个相同的子组件，在子组件中通过$parent调用了父组件的函数，并在父组件通过$children获取子组件实例的数组。 我们在Parent中打印出$parent属性看到是最外层#app的实例。 常见使用场景可以分为三类: 父子组件通信: props; $parent/$children; provide/inject; $ref; $attrs/$listeners 兄弟组件通信: EventBus; Vuex 跨级通信: EventBus; Vuex; provide/inject; $attrs/$listeners","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"Vue","slug":"Vue","permalink":"http://xieyufei.com/tags/Vue/"},{"name":"组件化","slug":"Componentization","permalink":"http://xieyufei.com/tags/Componentization/"}]},{"title":"对JS事件流的理解","date":"2020-03-06T03:00:00.000Z","path":"2020/03/06/Js-Events.html","text":"在JS事件循环中，我们接触了很多JS自己触发的事件。但是当我们在网页上进行某些类型的交互时，也会触发事件，比如在某些内容上的点击、鼠标经过某个特定元素或按下键盘上的某些按键。当一个节点产生一个事件时，该事件会在元素结点与根节点之间按特定的顺序传播，路径所经过的节点都会收到该事件，这个传播过程称为DOM事件流。 什么是事件 JavaScript和HTML之间的交互是通过事件实现的。事件，就是文档或浏览器窗口发生的一些特定的交互瞬间。可以使用监听器（或事件处理程序）来预定事件，以便事件发生时执行相应的代码。通俗的说，这种模型其实就是一个观察者模式。（事件是对象主题，而这一个个的监听器就是一个个观察者） 什么是事件流 事件流描述的就是从页面中接收事件的顺序。而早期的IE和Netscape提出了完全相反的事件流概念，IE事件流是事件冒泡，而Netscape的事件流就是事件捕获。 事件冒泡事件捕获 IE提出的事件流是事件冒泡，即从下至上，从目标触发的元素逐级向上传播，直到window对象。 而Netscape的事件流就是事件捕获，即从document逐级向下传播到目标元素。由于IE低版本浏览器不支持，所以很少使用事件捕获。 后来ECMAScript在DOM2中对事件流进行了进一步规范，基本上就是上述二者的结合。 DOM2级事件规定的事件流包括三个阶段：（1）事件捕获阶段（2）处于目标阶段（3）事件冒泡阶段 DOM事件处理 DOM节点中有了事件，那我们就需要对事件进行处理，而DOM事件处理分为4个级别：DOM0级事件处理，DOM0级事件处理，DOM2级事件处理和DOM3级事件处理。 其中DOM1级事件处理标准中并没有定义相关的内容，所以没有所谓的DOM1事件处理；DOM3级事件在DOM2级事件的基础上添加了更多的事件类型。 DOM0 DOM0级事件具有极好的跨浏览器优势，会以最快的速度绑定。第一种方式是内联模型（行内绑定），将函数名直接作为html标签中属性的属性值。 123456&lt;div onclick=&quot;btnClick()&quot;&gt;click&lt;/div&gt;&lt;script&gt;function btnClick()&#123; console.log(&quot;hello&quot;);&#125;&lt;/script&gt; 内联模型的缺点是不符合w3c中关于内容与行为分离的基本规范。第二种方式是脚本模型（动态绑定），通过在JS中选中某个节点，然后给节点添加onclick属性。 1234567&lt;div id=&quot;btn&quot;&gt;点击&lt;/div&gt;&lt;script&gt;var btn=document.getElementById(&quot;btn&quot;);btn.onclick=function()&#123; console.log(&quot;hello&quot;);&#125;&lt;/script&gt; 点击输出hello，没有问题；如果我们给元素添加两个事件 12345678910&lt;div id=&quot;btn&quot;&gt;点击&lt;/div&gt;&lt;script&gt;var btn=document.getElementById(&quot;btn&quot;);btn.onclick=function()&#123; console.log(&quot;hello&quot;);&#125;btn.onclick=function()&#123; console.log(&quot;hello again&quot;);&#125;&lt;/script&gt; 这时候只有输出hello again，很明显，第一个事件函数被第二个事件函数给覆盖掉，所以脚本模型的缺点是同一个节点只能添加一次同类型事件。让我们把div扩展到3个。 1234567891011121314151617181920212223&lt;div id=&quot;btn3&quot;&gt; btn3 &lt;div id=&quot;btn2&quot;&gt; btn2 &lt;div id=&quot;btn1&quot;&gt; btn1 &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; let btn1 = document.getElementById(&quot;btn1&quot;); let btn2 = document.getElementById(&quot;btn2&quot;); let btn3 = document.getElementById(&quot;btn3&quot;); btn1.onclick=function()&#123; console.log(1) &#125; btn2.onclick=function()&#123; console.log(2) &#125; btn3.onclick=function()&#123; console.log(3) &#125;&lt;/script&gt; 当我们点击btn3的时候输出3，那当我们点击btn1的时候呢？ 我们发现最先触发的是最底层btn1的事件，最后才是顶层btn3的事件，因此很明显是事件冒泡。DOM0级只支持冒泡阶段。 DOM2 进一步规范之后，有了DOM2级事件处理程序，其中定义了两个方法： addEventListener() —添加事件侦听器 removeEventListener() —删除事件侦听器 函数均有3个参数，第一个参数是要处理的事件名第二个参数是作为事件处理程序的函数第三个参数是一个boolean值，默认false表示使用冒泡机制，true表示捕获机制。 12345678910111213&lt;div id=&quot;btn&quot;&gt;点击&lt;/div&gt; &lt;script&gt;var btn=document.getElementById(&quot;btn&quot;);btn.addEventListener(&quot;click&quot;,hello,false);btn.addEventListener(&quot;click&quot;,helloagain,false);function hello()&#123; console.log(&quot;hello&quot;);&#125;function helloagain()&#123; console.log(&quot;hello again&quot;);&#125;&lt;/script&gt; 这时候两个事件处理程序都能够成功触发，说明可以绑定多个事件处理程序，但是注意，如果定义了一摸一样时监听方法，是会发生覆盖的，即同样的事件和事件流机制下相同方法只会触发一次， 12345678910&lt;div id=&quot;btn&quot;&gt;点击&lt;/div&gt; &lt;script&gt;var btn=document.getElementById(&quot;btn&quot;);btn.addEventListener(&quot;click&quot;,hello,false);btn.addEventListener(&quot;click&quot;,hello,false);function hello()&#123; console.log(&quot;hello&quot;);&#125;&lt;/script&gt; 这时候hello只会执行一次；让我们把div扩展到3个。 1234567891011121314151617181920212223&lt;div id=&quot;btn3&quot;&gt; btn3 &lt;div id=&quot;btn2&quot;&gt; btn2 &lt;div id=&quot;btn1&quot;&gt; btn1 &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; let btn1 = document.getElementById(&#x27;btn1&#x27;); let btn2 = document.getElementById(&#x27;btn2&#x27;); let btn3 = document.getElementById(&#x27;btn3&#x27;); btn1.addEventListener(&#x27;click&#x27;,function()&#123; console.log(1) &#125;, true) btn2.addEventListener(&#x27;click&#x27;,function()&#123; console.log(2) &#125;, true) btn3.addEventListener(&#x27;click&#x27;,function()&#123; console.log(3) &#125;, true)&lt;/script&gt; 这时候看到顺序和DOM0中的顺序反过来了，最外层的btn最先触发，因为addEventListener最后一个参数是true，捕获阶段进行处理。 那么冒泡和捕获阶段谁先执行呢？我们给每个元素分别绑定了冒泡和捕获两个事件。 1234567891011121314151617181920btn1.addEventListener(&#x27;click&#x27;,function()&#123; console.log(&#x27;btn1捕获&#x27;)&#125;, true)btn1.addEventListener(&#x27;click&#x27;,function()&#123; console.log(&#x27;btn1冒泡&#x27;)&#125;, false)btn2.addEventListener(&#x27;click&#x27;,function()&#123; console.log(&#x27;btn2捕获&#x27;)&#125;, true)btn2.addEventListener(&#x27;click&#x27;,function()&#123; console.log(&#x27;btn2冒泡&#x27;)&#125;, false)btn3.addEventListener(&#x27;click&#x27;,function()&#123; console.log(&#x27;btn3捕获&#x27;)&#125;, true)btn3.addEventListener(&#x27;click&#x27;,function()&#123; console.log(&#x27;btn2冒泡&#x27;)&#125;, false) 我们看到先执行捕获阶段的处理程序，后执行冒泡阶段的处理程序，我们把顺序换一下再看运行结果： 1234567891011121314151617181920btn1.addEventListener(&#x27;click&#x27;,function()&#123; console.log(&#x27;btn1冒泡&#x27;)&#125;, false)btn1.addEventListener(&#x27;click&#x27;,function()&#123; console.log(&#x27;btn1捕获&#x27;)&#125;, true)btn2.addEventListener(&#x27;click&#x27;,function()&#123; console.log(&#x27;btn2冒泡&#x27;)&#125;, false)btn2.addEventListener(&#x27;click&#x27;,function()&#123; console.log(&#x27;btn2捕获&#x27;)&#125;, true)btn3.addEventListener(&#x27;click&#x27;,function()&#123; console.log(&#x27;btn3冒泡&#x27;)&#125;, false)btn3.addEventListener(&#x27;click&#x27;,function()&#123; console.log(&#x27;btn3捕获&#x27;)&#125;, true) 我们发现在触发的目标元素上不区分冒泡还是捕获，按绑定的顺序来执行。 阻止冒泡 有时候我们需要点击事件不再继续向上冒泡，我们在btn2上加上stopPropagation函数，阻止程序冒泡。 123456789101112131415161718192021btn1.addEventListener(&#x27;click&#x27;,function()&#123; console.log(&#x27;btn1冒泡&#x27;)&#125;, false)btn1.addEventListener(&#x27;click&#x27;,function()&#123; console.log(&#x27;btn1捕获&#x27;)&#125;, true)btn2.addEventListener(&#x27;click&#x27;,function()&#123; console.log(&#x27;btn2冒泡&#x27;)&#125;, false)btn2.addEventListener(&#x27;click&#x27;,function(ev)&#123; ev.stopPropagation(); console.log(&#x27;btn2捕获&#x27;)&#125;, true)btn3.addEventListener(&#x27;click&#x27;,function()&#123; console.log(&#x27;btn3冒泡&#x27;)&#125;, false)btn3.addEventListener(&#x27;click&#x27;,function(e)&#123; console.log(&#x27;btn3捕获&#x27;)&#125;, true) 可以看到btn2捕获阶段执行后不再继续往下执行。 事件委托 如果有多个DOM节点需要监听事件的情况下，给每个DOM绑定监听函数，会极大的影响页面的性能，因为我们通过事件委托来进行优化，事件委托利用的就是冒泡的原理。 123456789101112131415&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; var li_list = document.getElementsByTagName(&#x27;li&#x27;) for(let index = 0;index&lt;li_list.length;index++)&#123; li_list[index].addEventListener(&#x27;click&#x27;, function(ev)&#123; console.log(ev.currentTarget.innerHTML) &#125;) &#125;&lt;/script&gt; 正常情况我们给每一个li都会绑定一个事件，但是如果这时候li是动态渲染的，数据又特别大的时候，每次渲染后（有新增的情况）我们还需要重新来绑定，又繁琐又耗性能；这时候我们可以将绑定事件委托到li的父级元素，即ul。 1234var ul_dom = document.getElementsByTagName(&#x27;ul&#x27;)ul_dom[0].addEventListener(&#x27;click&#x27;, function(ev)&#123; console.log(ev.target.innerHTML)&#125;) 上面代码中我们使用了两种获取目标元素的方式，target和currentTarget，那么他们有什么区别呢： target返回触发事件的元素，不一定是绑定事件的元素 currentTarget返回的是绑定事件的元素 因此我们总结一下事件委托的优点: 提高性能:每一个函数都会占用内存空间，只需添加一个事件处理程序代理所有事件，所占用的内存空间更少。 动态监听:使用事件委托可以自动绑定动态添加的元素，即新增的节点不需要主动添加也可以一样具有和其他元素一样的事件。 参考JS事件流和事件委托你真的理解事件冒泡和事件捕获吗？前端小知识–JavaScript事件流","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"js","slug":"js","permalink":"http://xieyufei.com/tags/js/"}]},{"title":"Vue实例为什么只能有一个根元素？","date":"2020-02-29T03:00:00.000Z","path":"2020/02/29/Vue-One-Root.html","text":"我们在初学Vue时，第一个上手的例子基本都是 new Vue({el:’#app’})，但是为什么Vue实例只能挂载在一个div上呢？同样的当我们开始写第一个Vue页面的时候，我们试图在template标签下写两个div，Vue提醒我们只能写一个元素，但是为什么只能有一个元素呢？很多时候我们都已经习以为常，但是却说不上来为什么。 笔者入坑Vue也有一段时间了，对Vue也算了解，Vuex、Vue-Router也用了不少；但是前几天一看到这个面试问题却感觉一下子回答不上了，想来每次写代码也都是拿来就用，也没有仔细的思考过里面的原因；每每报错了就换一种写法，能用就行，仅此而已。 这个问题要从两个方面来说： new Vue({el:’#app’}) 单文件组件中，template下的元素div Vue实例 当我们实例化Vue的时候，填写一个el选项，来指定我们的SPA入口： 1234let vm = new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; msg: &#x27;Hi boy&#x27; &#125;&#125;) 123&lt;body&gt; &lt;div id=&#x27;app&#x27;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;&lt;/body&gt; 如果我们把代码改造一下，变成两个入口。 1234let vm = new Vue(&#123; el:&#x27;.app&#x27;, data:&#123; msg: &#x27;Hi boy&#x27; &#125;&#125;) 1234&lt;body&gt; &lt;div class=&#x27;app&#x27;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; &lt;div class=&#x27;app&#x27;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;&lt;/body&gt; 这时候会发现只有第一个div被渲染出来，而第二个div还是原封不动。我们简单来看一下Vue的源码是如何实现的 123456789101112131415Vue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; query(el) /* istanbul ignore if */ if (el === document.body || el === document.documentElement) &#123; process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn( `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.` ) return this &#125; //以下省略无关代码 //...&#125; 可以看到挂载函数传了一个el参数，这个参数可以是string类型，也可以是一个element元素，也就是dom节点。最重要的是el = el &amp;&amp; query(el)这一行代码，那就继续看一下query函数是做什么的： 1234567891011121314151617/** * Query an element selector if it&#x27;s not an element already. */export function query (el: string | Element): Element &#123; if (typeof el === &#x27;string&#x27;) &#123; const selected = document.querySelector(el) if (!selected) &#123; process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn( &#x27;Cannot find element: &#x27; + el ) return document.createElement(&#x27;div&#x27;) &#125; return selected &#125; else &#123; return el &#125;&#125; 首先query函数判断是否是string类型，如果是string类型，就通过querySelector函数获取页面中的元素，但是querySelector仅仅返回匹配指定选择器的第一个元素，所以这就解释了为什么第二个div会原封不动。 Vue其实并不知道哪一个才是我们的入口，因为对于一个入口来讲，这个入口就是一个Vue类，Vue需要把这个入口里面的所有东西拿来渲染、处理，最后再重新插入到dom中。如果同时设置了多个入口，那么vue就不知道哪一个才是这个类。 单文件组件 当我们在vue-cli脚手架搭建的vue开发环境下使用单文件组件时，一般会这么写： 12345&lt;template&gt; &lt;div class=&quot;box&quot;&gt; 这里是页面内容 &lt;/div&gt;&lt;/template&gt; 如果我们尝试在template标签下写两个div，那么编辑器会提示我们The template root requires exactly one element。那这里为什么template下也必须有且只能有一个div呢？ 这里我们要先看一看template这个标签，这个标签是HTML5出来的新标签，它有三个特性： 隐藏性：该标签不会显示在页面的任何地方，即便里面有多少内容，它永远都是隐藏的状态； 任意性：该标签可以写在页面的任何地方，甚至是head、body、sciprt标签内； 无效性：该标签里的任何HTML内容都是无效的，不会起任何作用； 但是我们可以通过innerHTML来获取到里面的内容。 知道了这个，我们再来看.vue的单文件组件。其实本质上，一个单文件组件会被各种各样的loader处理成为.js文件（因为当你import一个单文件组件并打印出来的时候，是一个vue实例），通过template的任意性我们知道，template包裹的HTML可以写在任何地方，那么对于一个.vue来讲，这个template里面的内容就是会被vue处理为虚拟dom并渲染的内容，导致结果又回到了开始 ：既然一个.vue单文件组件是一个vue实例，那么这个实例的入口在哪里？ 如果在template下有多个div，那么该如何指定这个vue实例的根入口？为了让组件能够正常的生成一个vue实例，那么这个div会被自然的处理成程序的入口。 通过这个‘根节点’，来递归遍历整个vue‘树’下的所有节点，并处理为vdom，最后再渲染成真正的HTML，插入在正确的位置。","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"Vue","slug":"Vue","permalink":"http://xieyufei.com/tags/Vue/"}]},{"title":"从一道面试题来理解JS事件循环","date":"2019-12-30T03:00:00.000Z","path":"2019/12/30/Quiz-Eventloop.html","text":"上周一个朋友发了某互联网公司的笔试题给我看，其中有一道题比较有意思，考察了对JS事件循环的理解，所以故事的开始让我们从一道复杂的面试题开始。。。 一道面试题 说出下面代码的运行结果，并说明原因： 1234567891011121314151617181920212223242526async function async1()&#123; console.log(&#x27;async1 start&#x27;) await async2() console.log(&#x27;async1 end&#x27;)&#125;async function async2()&#123; console.log(&#x27;async2&#x27;)&#125;console.log(&#x27;script start&#x27;)setTimeout(function()&#123; console.log(&#x27;setTimeOut&#x27;)&#125;, 0)async1()new Promise(function(resolve)&#123; console.log(&#x27;promise1&#x27;) resolve()&#125;).then(function()&#123; console.log(&#x27;promise2&#x27;) &#125;)console.log(&#x27;script end&#x27;) 先贴一下在浏览器里的运行的结果（如果跟你的思路一模一样的话，大佬请直接Ctrl+F4）： 12345678//script start//async1 start//async2//promise1//script end//async1 end//promise2//setTimeOut 如果跟你的思路不一样的话也不用担心，我们从简单的开始一点点剖析这道面试题。 单线程 首先我们都知道，JavaScript是一门单线程的语言，所谓单线程指的是在JavaScript引擎中负责解释和执行代码的线程只有一个，通常称为主线程。那么为什么JavaScript必须是单线程的语言，而不能像他的老大哥Java一样，手动开启多个线程呢？ 因为这是由于JavaScript所运行的浏览器环境决定，他只能是单线程的。试想一下，如果JavaScript能开启多个线程，页面上有一个div，我们同时在多个线程中来改变这个div中的内容，那么最终这个div会变成什么样子谁也确定不了，最后只能听天由命，看哪个线程是最后一个运行结束的。 因此多线程带来了很多的不确定性，为了避免这种问题，JavaScript必须是单线程。 可能有的同学又会说了，JavaScript不是可以通过Web Worker开启多线程么？是的，Web Worker是可以开启另一个线程，但是这个新开线程的功能被限制了，只能做一些消耗CPU的逻辑运算等，数据传输也是通过回调的方式来进行，不会阻塞主线程的执行；而且最最重要的是，Web Worker不能来操作dom，笔者经过尝试发现，在新开的线程中甚至都不能获取到document和window对象。 所以还是没有改变JavaScript是单线程运行这一核心原则。当然，虽然JavaScript是单线程运行的，但是还是存在其他线程的；例如：处理Ajax请求的线程、定时器的线程、读写文件的线程（nodejs中）等。 同步任务和异步任务 因为JavaScript是单线程运行的，所有的任务只能在主线程上排队执行；但是如果某个任务特别耗时，比如Ajax请求一个接口，可能1s返回结果，也可能10s才返回，有很多的不确定因素（网络延迟等）；如果这些任务也放到主线程中去，那么会阻塞浏览器（用户除了等，不能进行其他操作）。 于是，浏览器就把这些任务分派到异步任务队列中去，并且跟他们说：你们自己去后台玩儿，等你们好了再过来通知我！先来看简单的例子来理解一下同步和异步任务： 1234567console.log(&#x27;start&#x27;)setTimeout(function() &#123; console.log(&#x27;setTimeout&#x27;)&#125;, 0)console.log(&#x27;end&#x27;) 当主线程执行到setTimeout的时候，虽然是延迟了0s，但是并不会马上来运行，而是放到异步任务队列中，等下面的同步任务队列执行完了，再来执行异步队列中的任务，所以运行结果是：start、end、setTimeout。 但如果同步任务中有特别耗时的操作，阻塞了setTimeout的定时执行，那么setTimeout就不会按时来完成。来看下面的例子： 12345678910111213console.log(&#x27;start&#x27;)console.time(&#x27;now&#x27;)let list = []setTimeout(function() &#123; console.timeEnd(&#x27;now&#x27;)&#125;, 1000)for(let i = 0;i&lt;9999999;i++)&#123; let now = new Date() list.push(i)&#125; 虽然我们让setTimeout1s后执行，但是for循环占用了太多的线程资源，实际执行会在2s后。所以事件循环的流程大致如下： 所有任务都在主线程上执行，形成一个执行栈。 主线程发现有异步任务，就在“任务队列”之中加入一个任务事件。 一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”（先进先出原则）。那些对应的异步任务，结束等待状态，进入执行栈并开始执行。 主线程不断重复上面的第三步，这样的一个循环称为事件循环。 宏任务与微任务 如果任务队列中有多个异步任务，那么先执行哪个任务呢？于是在异步任务中，也进行了等级划分，分为宏任务（macrotask）和微任务（microtask）；不同的API注册的任务会依次进入自身对应的队列中，然后等待事件循环将它们依次压入执行栈中执行。 宏任务包括： script(整体代码) setTimeout, setInterval, setImmediate, I/O UI rendering 微任务包括： process.nextTick Promise Object.observe(已废弃) MutationObserver(html5新特性) 我们可以把整体的JS代码也看成是一个宏任务，主线程也是从宏任务开始的。我们把上面事件循环的步骤更新一下： 执行一个宏任务 执行过程中如果遇到微任务就加入微任务队列，遇到宏任务就加入宏任务队列 宏任务执行完毕后，检查当前微任务队列，如果有，就依次执行（一轮事件循环结束） 开始下一个宏任务 让我们来看一个例子： 12345678910111213141516console.log(&#x27;start&#x27;)setTimeout(function() &#123; console.log(&#x27;timeout&#x27;);&#125;, 0)new Promise(function(resolve) &#123; console.log(&#x27;promise&#x27;); //注意这边调用resolve //不然then方法不会执行 resolve()&#125;).then(function() &#123; console.log(&#x27;then&#x27;);&#125;)console.log(&#x27;end&#x27;); 分析一下执行流程： 刚开始打印start 遇到setTimeout，放入宏任务中，等待执行 遇到new Promise的回调函数，同步执行，打印promise 当resolve后，then方法会放入微任务，等待执行 打印end，这时整个执行栈清空了，宏任务和微任务队列各有一个回调方法 先执行微任务队列，打印then 执行宏任务，打印timeout 我们把Promise进行一下改变，看一下下面的例子： 12345678910async function async1() &#123; console.log(&#x27;async1 start&#x27;) await async2() console.log(&#x27;async1 end&#x27;)&#125;async function async2() &#123; console.log(&#x27;async2&#x27;)&#125;async1()console.log(&#x27;script end&#x27;) 刚开始我们会想当然的认为执行顺序是：async1 start –&gt; async2 –&gt; async1 end –&gt; script end。但是当真正理解了async函数的本质后，我们知道async函数还是基于Promise的一些封装，而Promise是属于微任务的一种；因此会把await async2()后面的所有代码放到Promise的then回调函数中去，因此，如果把上面代码进行如下改写，会好理解很多： 1234567891011async function async1() &#123; console.log(&#x27;async1 start&#x27;) new Promise(function(resolve)&#123; console.log(&#x27;async2&#x27;) resolve() &#125;).then(function()&#123; console.log(&#x27;async1 end&#x27;) &#125;)&#125;async1()console.log(&#x27;script end&#x27;) 根据上面对微任务的理解，console.log(&#39;async1 end&#39;)会放到微任务队列中，所以实际执行顺序是：async1 start –&gt; async2 –&gt; script end –&gt; async1 end。 最后来看那道面试题，相信已经不难理解了。 第一轮循环开始 打印script start 发现setTimeout，放入宏任务1 打印async1 start 打印async2 把await async2函数后面的回调放入微任务1 打印promise1 把then中的函数放入微任务2 打印script end 调用栈清空，开始执行微任务1，打印async1 end 执行微任务2，打印promise2 微任务执行完，第一轮循环结束 开始宏任务1，打印setTimeOut 结束，完美撒花","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"面试","slug":"Interview","permalink":"http://xieyufei.com/tags/Interview/"}]},{"title":"源码剖析Bullshit文章生成器","date":"2019-12-16T10:56:39.000Z","path":"2019/12/16/Article-Generate.html","text":"前段时间，有一个叫“狗屁不通文章生成器”的项目一下子吸引了大家的兴趣，还引起各大科技媒体；36Kr、新浪专栏IT之家都不约而同的刊文报道。然而，综看整个项目，除去README、LICENSE和gitignore，一共就6个文件，却达到了惊人的11.6k的Star和2.2k的Fork，平均下来每个文件有将近2k的Star。你可能会发出疑问了，这究竟是人性的扭曲还是道德的沦丧？今天就让我们来看一下它究竟有何黑科技能自动生成文章。 事情的起因来源于知乎上的一篇提问，有人提问“学生会退会申请六千字怎么写？”于是乎，各路大神纷纷前来献计献策，有复制粘贴六千字“不干了”的，有复制粘贴六千字《道德经》的，更有提议使用美人计撩学长的；然而其中的一个回答横空出世，答主随手就写了一个开源项目狗屁不通文章生成器；通过该项目，快速生成了一篇相关文章，不仅解决了题主的问题，还得到了广大网友的认同。 文章太长了，这边就不放完整版的了，有兴趣的童鞋可以去知乎观摩一下原文《学生会退会申请六千字怎么写?》，我试了下，果然是滑到底都需要半分钟之久。 该项目一开始为python3版本，后来有网友整理了网页版的，现在我们常用的是由suulnnka修改的在线版本，对页面的样式进行了优化，将生成的主题放入query参数中，使用更加的方便，这里我们随机来生成一篇文章看一下效果： 可以看出整篇文章虽然废话连篇、狗屁不通，但是段段扣题，旁征博引，引用各种名人名言，什么爱迪生曾经提到，什么康德曾经说过，每一段说的貌似都有理有据，令人无法反驳。 那么作者到底是如何来生成这么一长串的长篇大论的呢？最开始我还猜测是不是通过某种神经网络算法来将每一段话拼接起来，但是作者很明确的在README中写道： 鄙人才疏学浅并不会任何自然语言处理相关算法. 而且目前比较偏爱简单有效的方式达到目的方式. 除非撞到了天花板, 否则暂时不会引入任何神经网络等算法. 不过欢迎任何人另开分支实现更复杂, 效果更好的算法. 不过除非效果拔群, 否则鄙人暂时不会融合. 很明显，作者只是通过某种简单有效的方式来实现这个功能的，那让我来深扒一下源码，看看这种到底是怎么样一种简单有效的方式。 首先放在项目开始的是定义的一些论述、名人名言、前后垫话以及用到的公用函数等： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647let 论述 = [ &#x27;现在，解决主题的问题，是非常非常重要的。 所以， &#x27;, &#x27;我们不得不面对一个非常尴尬的事实，那就是， &#x27;, //省略若干论述]let 名人名言 = [ &#x27;伏尔泰曾经说过，不经巨大的困难，不会有伟大的事业。这不禁令我深思&#x27;, &#x27;富勒曾经说过，苦难磨炼一些人，也毁灭另一些人。这不禁令我深思&#x27;, &quot;文森特·皮尔曾经说过，改变你的想法，你就改变了自己的世界。这不禁令我深思&quot;, //省略若干名人名言]let 后面垫话 = [ &quot;这不禁令我深思。 &quot;, &quot;带着这句话，我们还要更加慎重的审视这个问题： &quot;, &quot;这启发了我， &quot;, &quot;我希望诸位也能好好地体会这句话。 &quot;, &quot;这句话语虽然很短，但令我浮想联翩。 &quot;,]let 前面垫话 = [ &quot;曾经说过&quot;, &quot;在不经意间这样说过&quot;,]function 随便取一句(列表)&#123; let 坐标 = Math.floor( Math.random() * 列表.length ); return 列表[坐标];&#125;function 随便取一个数(最小值 = 0,最大值 = 100)&#123; let 数字 = Math.random()*( 最大值 - 最小值 ) + 最小值; return 数字;&#125;function 来点名人名言()&#123; let 名言 = 随便取一句(名人名言) 名言 = 名言.replace(&quot;曾经说过&quot;, 随便取一句(前面垫话) ) 名言 = 名言.replace(&quot;这不禁令我深思&quot;, 随便取一句(后面垫话) ) return 名言&#125;function 来点论述()&#123; let 句子 = 随便取一句(论述); 句子 = 句子.replace(RegExp(&quot;主题&quot;, &quot;g&quot;),主题); return 句子;&#125;function 增加段落(章节)&#123; if(章节[章节.length-1] === &quot; &quot;)&#123; 章节 = 章节.slice(0,-2) &#125; return &quot; &quot; + 章节 + &quot;。 &quot;&#125; 在广大网友的帮助下，整理了一百条的名人名言，整理的格式都是固定的：人名+曾经说过+一段话+这不禁令我深思，然后把曾经说过替换前面垫话，把这不禁令我深思替换成后面垫话。公用函数定义好了，最核心最精彩的部分就是生成文章的代码了： 1234567891011121314151617181920212223242526272829function 生成文章()&#123; 主题 = $(&#x27;input&#x27;).value let 文章 = [] for(let 空 in 主题)&#123; let 章节 = &quot;&quot;; let 章节长度 = 0; while( 章节长度 &lt; 6000 )&#123; let 随机数 = 随便取一个数(); if(随机数 &lt; 5 &amp;&amp; 章节.length &gt; 200)&#123; 章节 = 增加段落(章节); 文章.push(章节); 章节 = &quot;&quot;; &#125;else if(随机数 &lt; 20)&#123; let 句子 = 来点名人名言(); 章节长度 = 章节长度 + 句子.length; 章节 = 章节 + 句子; &#125;else&#123; let 句子 = 来点论述(); 章节长度 = 章节长度 + 句子.length; 章节 = 章节 + 句子; &#125; &#125; 章节 = 增加段落(章节); 文章.push(章节); &#125; let 排版 = &quot;&lt;div&gt;&quot; + 文章.join(&quot;&lt;/div&gt;&lt;div&gt;&quot;) + &quot;&lt;/div&gt;&quot;; $(&quot;#论文&quot;).innerHTML = 排版;&#125; 首先作者的思路是把一篇文章作为一个数组存起来，数组中的每个元素都是一个章节，这里的章节可以理解为一个自然段，是文章的基本组成部分；最后再把整个数组通过div拼接起来。其中，最重要的就是如何来生成一个章节。 刚开始我对for(let 空 in 主题)这个遍历感到十分困惑，主题很好理解是一个字符串，但是将字符串中每一个字符遍历出来有什么作用么？经过多次debug，猜测其实是为了多生成几次章节，凑字数而已；原本6000字，经过多次遍历，实际可能会远超6000字，达到好几万的字数（6000*主题字数）；因此在suulnnka改版后的函数中，也将这段代码优化成了while( 文章长度 &lt; 12000 )，控制整篇文章的字数略大于12000字。 随便取一个数函数用来生成一个0到100的随机数，首先让我们看一下随机数 &lt; 20的情况，也就是15%的概率（20-5）用来在章节中添加一句名人名言；然后80%的概率（100-5-15）用来在章节中添加一句论述；最后我们回到最难理解的随机数 &lt; 5的情况，也就是5%的概率来将这段章节给结束掉，通过把章节最后两个字符截取替换成句号，然后把章节push到文章中，最后把章节变量的内容给清空了。 通过对源码的分析，我们看出作者的方法确实很简单有效，通过预存的名人名言和大段论述来生成文章；也正是因为简单，所以整个生成出来的文章重复率偏高了；因此作者也意识到这个问题，在项目中明确表示下一步计划是防止文章过于内容重复。 广大网友还在此基础上开发了日语版的和嘴臭版的（LOL喷人神器？），更有网友调侃李小璐离婚宣言都是用这个项目生成的。 除此之外，我们还发现项目中的代码使用了大量的中文函数名和中文变量，这也是我第一次知道了编程中还能使用中文变量名，太硬核了。作者也在项目中表示，使用中文变量名只是因为懒得切英文输入法，于是，分支作者还特地帮忙把漏网的英文变量名，也给改成了中文。","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"源码","slug":"SourceCode","permalink":"http://xieyufei.com/tags/SourceCode/"}]},{"title":"面试完50个人后我写下这篇总结","date":"2019-11-08T13:50:00.000Z","path":"2019/11/08/Front-Summary.html","text":"2019年的春节来的似乎格外的早，过完年相信很多童鞋都开始蠢蠢欲动了；笔者总结了多篇教程，结合平时自己的面试经历，整理了这份文档，希望帮助大家来突击一下前端知识的盲区。 一、CSS盒模型 CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距margin，边框border，填充padding，和实际内容content。盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。 box-sizing: content-box（W3C盒模型，又名标准盒模型）：元素的宽高大小表现为内容的大小。 box-sizing: border-box（IE盒模型，又名怪异盒模型）：元素的宽高表现为内容 + 内边距 + 边框的大小。背景会延伸到边框的外沿。 CSS3的新特性 word-wrap 文字换行 text-overflow 超过指定容器的边界时如何显示 text-decoration 文字渲染 text-shadow文字阴影 gradient渐变效果 transition过渡效果 transition-duration：过渡的持续时间 transform拉伸，压缩，旋转，偏移等变换 animation动画 transition和animation的区别： Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from …. to，而animation可以一帧一帧的。 CSS选择器及其优先级 !important 内联样式style=”” ID选择器#id 类选择器/属性选择器/伪类选择器.class.active[href=””] 元素选择器/关系选择器/伪元素选择器html+div&gt;span::after 通配符选择器* BFCBFC（Block Formatting Context）格式化上下文，是Web页面中盒模型布局的CSS渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器。 BFC应用 防止margin重叠 清除内部浮动 自适应两（多）栏布局 防止字体环绕 触发BFC条件 根元素 float的值不为none overflow的值不为visible display的值为inline-block、table-cell、table-caption position的值为absolute、fixed BFC的特性 内部的Box会在垂直方向上一个接一个的放置。 垂直方向上的距离由margin决定 bfc的区域不会与float的元素区域重叠。 计算bfc的高度时，浮动元素也参与计算 bfc就是页面上的一个独立容器，容器里面的子元素不会影响外面元素。 div水平居中 行内元素 123.parent &#123; text-align: center;&#125; 块级元素 123.son &#123; margin: 0 auto;&#125; flex布局 1234.parent &#123; display: flex; justify-content: center;&#125; 绝对定位定宽 123456.son &#123; position: absolute; width: 宽度; left: 50%; margin-left: -0.5*宽度&#125; 绝对定位不定宽 12345.son &#123; position: absolute; left: 50%; transform: translate(-50%, 0);&#125; left/right: 0 1234567.son &#123; position: absolute; width: 宽度; left: 0; right: 0; margin: 0 auto;&#125; div垂直居中 行内元素 123456.parent &#123; height: 高度;&#125;.son &#123; line-height: 高度;&#125; table 1234567.parent &#123; display: table;&#125;.son &#123; display: table-cell; vertical-align: middle;&#125; flex 1234.parent &#123; display: flex; align-items: center;&#125; 绝对定位定高 123456.son &#123; position: absolute; top: 50%; height: 高度; margin-top: -0.5高度;&#125; 绝对定位不定高12345.son &#123; position: absolute; top: 50%; transform: translate( 0, -50%);&#125; top/bottom: 0;1234567.son &#123; position: absolute; height: 高度; top: 0; bottom: 0; margin: auto 0;&#125; 绝对定位和相对定位 absolute 绝对定位 相对于最近的已定位的祖先元素, 有已定位(指position不是static的元素)祖先元素, 以最近的祖先元素为参考标准。如果无已定位祖先元素, 以body元素为偏移参照基准, 完全脱离了标准文档流。 fixed 固定定位的元素会相对于视窗来定位,这意味着即便页面滚动，它还是会停留在相同的位置。一个固定定位元素不会保留它原本在页面应有的空隙。 共同点：改变行内元素的呈现方式，都脱离了文档流；不同点：absolute的”根元素“是可以设置的，fixed的“根元素”固定为浏览器窗口 flex布局采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称“项目”。 父元素属性 属性名 属性值 备注 display flex 定义了一个flex容器，它的直接子元素会接受这个flex环境 flex-direction row,row-reverse,column,column-reverse 决定主轴的方向 flex-wrap nowrap,wrap,wrap-reverse 如果一条轴线排不下，如何换行 flex-flow [flex-direction] , [flex-wrap] 是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap justify-content flex-start,flex-end,center,space-between,space-around 设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式 align-items flex-start,flex-end,center,baseline,stretch 设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式 子元素属性 属性名 属性值 备注 order [int] 默认情况下flex order会按照书写顺序呈现，可以通过order属性改变，数值小的在前面，还可以是负数。 flex-grow [number] 设置或检索弹性盒的扩展比率,根据弹性盒子元素所设置的扩展因子作为比率来分配剩余空间 flex-shrink [number] 设置或检索弹性盒的收缩比率,根据弹性盒子元素所设置的收缩因子作为比率来收缩空间 flex-basis [length], auto 设置或检索弹性盒伸缩基准值 align-self auto,flex-start,flex-end,center,baseline,stretch 设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式，可以覆盖父容器align-items的设置 让元素消失visibility:hidden、display:none、z-index=-1、opacity：0 opacity：0,该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定了一些事件，如click事件也能触发 visibility:hidden,该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件 display:none, 把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删掉 z-index=-1置于其他元素下面 清除浮动 在浮动元素后面添加 clear:both 的空 div 元素， 12345&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;&lt;/div&gt; 给父元素添加 overflow:hidden 或者 auto 样式，触发BFC。 1234&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/div&gt; 123456.container&#123; width: 300px; background-color: #aaa; overflow:hidden; zoom:1; /*IE6*/&#125; 使用伪元素，也是在元素末尾添加一个点并带有 clear: both 属性的元素实现的。 1234&lt;div class=&quot;container clearfix&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/div&gt; 12345678910.clearfix&#123; zoom: 1; /*IE6*/&#125;.clearfix:after&#123; content: &quot;.&quot;; height: 0; clear: both; display: block; visibility: hidden;&#125; 推荐使用第三种方法，不会在页面新增div，文档结构更加清晰。 calc函数calc函数是css3新增的功能，可以使用calc()计算border、margin、pading、font-size和width等属性设置动态值。 123456789#div1 &#123; position: absolute; left: 50px; width: calc( 100% / (100px * 2) ); //兼容写法 width: -moz-calc( 100% / (100px * 2) ); width: -webkit-calc( 100% / (100px * 2) ); border: 1px solid black;&#125; 注意点： 需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px); calc()函数支持 “+”, “-“, “*”, “/“ 运算; 对于不支持 calc() 的浏览器，整个属性值表达式将被忽略。不过我们可以对那些不支持 calc()的浏览器，使用一个固定值作为回退。 移动端remrem官方定义『The font size of the root element』，即根元素的字体大小。rem是一个相对的CSS单位，1rem等于html元素上font-size的大小。所以，我们只要设置html上font-size的大小，就可以改变1rem所代表的大小。 12345678(function () &#123; var html = document.documentElement; function onWindowResize() &#123; html.style.fontSize = html.getBoundingClientRect().width / 20 + &#x27;px&#x27;; &#125; window.addEventListener(&#x27;resize&#x27;, onWindowResize); onWindowResize();&#125;)(); 移动端1px一般来说，在PC端浏览器中，设备像素比（dpr）等于1，1个css像素就代表1个物理像素；但是在retina屏幕中，dpr普遍是2或3，1个css像素不再等于1个物理像素，因此比实际设计稿看起来粗不少。 伪元素+scale 123456789101112131415161718192021&lt;style&gt; .box&#123; width: 100%; height: 1px; margin: 20px 0; position: relative; &#125; .box::after&#123; content: &#x27;&#x27;; position: absolute; bottom: 0; width: 100%; height: 1px; transform: scaleY(0.5); transform-origin: 0 0; background: red; &#125;&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt; border-image 12345div&#123; border-width: 1px 0px; -webkit-border-image: url(border.png) 2 0 stretch; border-image: url(border.png) 2 0 stretch;&#125; 两边宽度固定中间自适应的三栏布局圣杯布局和双飞翼布局是前端工程师需要日常掌握的重要布局方式。两者的功能相同，都是为了实现一个两侧宽度固定，中间宽度自适应的三栏布局。 圣杯布局123456789101112131415161718192021222324252627282930&lt;style&gt;body&#123; min-width: 550px;&#125;#container&#123; padding-left: 200px; padding-right: 150px;&#125;#container .column&#123; float: left;&#125;#center&#123; width: 100%;&#125;#left&#123; width: 200px; margin-left: -100%; position: relative; right: 200px;&#125;#right&#123; width: 150px; margin-right: -150px;&#125;&lt;/style&gt;&lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;center&quot; class=&quot;column&quot;&gt;center&lt;/div&gt; &lt;div id=&quot;left&quot; class=&quot;column&quot;&gt;left&lt;/div&gt; &lt;div id=&quot;right&quot; class=&quot;column&quot;&gt;right&lt;/div&gt;&lt;/div&gt; 双飞翼布局1234567891011121314151617181920212223242526272829&lt;style&gt;body &#123; min-width: 500px;&#125;#container &#123; width: 100%;&#125;.column &#123; float: left;&#125;#center &#123; margin-left: 200px; margin-right: 150px;&#125;#left &#123; width: 200px; margin-left: -100%;&#125;#right &#123; width: 150px; margin-left: -150px;&#125;&lt;/style&gt;&lt;div id=&quot;container&quot; class=&quot;column&quot;&gt; &lt;div id=&quot;center&quot;&gt;center&lt;/div&gt;&lt;/div&gt;&lt;div id=&quot;left&quot; class=&quot;column&quot;&gt;left&lt;/div&gt;&lt;div id=&quot;right&quot; class=&quot;column&quot;&gt;right&lt;/div&gt; 伪类和伪元素css引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素都是用来修饰不在文档树中的部分。 伪类伪类存在的意义是为了通过选择器找到那些不存在DOM树中的信息以及不能被常规CSS选择器获取到的信息。 获取不存在于DOM树中的信息。比如标签的:link、visited等，这些信息不存在于DOM树结构中，只能通过CSS选择器来获取； 获取不能被常规CSS选择器获取的信息。比如：要获取第一个子元素，我们无法用常规的CSS选择器获取，但可以通过 :first-child 来获取到。 伪元素伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过:before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。常见的伪元素有：::before，::after，::first-line，::first-letter，::selection、::placeholder等 因此，伪类与伪元素的区别在于：有没有创建一个文档树之外的元素。 ::after和:after的区别在实际的开发工作中，我们会看到有人把伪元素写成:after，这实际是 CSS2 与 CSS3新旧标准的规定不同而导致的。 CSS2 中的伪元素使用1个冒号，在 CSS3 中，为了区分伪类和伪元素，规定伪元素使用2个冒号。所以，对于 CSS2 标准的老伪元素，比如:first-line，:first-letter，:before，:after，写一个冒号浏览器也能识别，但对于 CSS3 标准的新伪元素，比如::selection，就必须写2个冒号了。 CSS画圆半圆扇形三角梯形12345678910111213141516171819202122232425262728293031div&#123; margin: 50px; width: 100px; height: 100px; background: red;&#125;/* 半圆 */.half-circle&#123; height: 50px; border-radius: 50px 50px 0 0;&#125;/* 扇形 */.sector&#123; border-radius: 100px 0 0;&#125;/* 三角 */.triangle&#123; width: 0px; height: 0px; background: none; border: 50px solid red; border-color: red transparent transparent transparent;&#125;/* 梯形 */.ladder&#123; width: 50px; height: 0px; background: none; border: 50px solid red; border-color: red transparent transparent transparent;&#125; white-space几个属性值的区别css中white-space这个属性，用来设置元素对内容中的空格的处理方式，有几个可选值：normal,nowrap,pre,pre-wrap,pre-line。没有设置white-space属性，则默认为white-space:normal。其他几个属性区别如下： white-space:nowrap不换行 white-space:pre保留空格不换行 white-space:pre-wrap保留空格换行 white-space:pre-line合并空格换行 demo如下： 1234567891011121314151617181920212223242526272829&lt;style&gt;.nowrap-box&#123; white-space: nowrap;&#125;.pre-box&#123; white-space: pre;&#125;.pre-wrap-box&#123; white-space: pre-wrap;&#125;.pre-line-box&#123; white-space: pre-line;&#125;&lt;/style&gt;&lt;div class=&quot;nowrap-box&quot;&gt; 谢小飞前端测试white-space:nowrap属性。分享前端最新技术文章、工具资源，专注前端技术开发。关注我们，每天读壹篇文章，和我们一起学习进步。公众号：前端壹读&lt;/div&gt;&lt;div class=&quot;pre-box&quot;&gt; 谢小飞前端测试white-space:pre属性。 分享前端最新技术文章、工具资源，专注前端技术开发。关注我们，每天读壹篇文章，和我们一起学习进步&lt;br/&gt; 公众号：前端壹读&lt;/div&gt;&lt;div class=&quot;pre-wrap-box&quot;&gt; 谢小飞前端测试white-space:pre-wrap属性。 分享前端最新技术文章、工具资源，专注前端技术开发。关注我们，每天读壹篇文章，和我们一起学习进步&lt;br/&gt; 公众号：前端壹读&lt;/div&gt;&lt;div class=&quot;pre-line-box&quot;&gt; 谢小飞前端测试white-space:pre-line属性。 分享前端最新技术文章、工具资源，专注前端技术开发。关注我们，每天读壹篇文章，和我们一起学习进步&lt;br/&gt; 公众号：前端壹读&lt;/div&gt; 属性名 源码空格 源码换行 br换行 容器边界换行 normal 合并 忽略 换行 换行 nowrap 合并 忽略 换行 不换行 pre 保留 换行 换行 不换行 pre-wrap 保留 换行 换行 换行 pre-line 合并 换行 换行 换行 浏览器解析CSS为什么从右开始CSS选择器的解析是从右向左解析的。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。比如.box .left p,会在页面中找到所有的p标签，然后在p标签中找其父元素有.left类的p元素，再找祖父元素有.box的p标签。 两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。 CSS如何性能优化 避免过度约束 避免后代选择符 避免链式选择符 使用紧凑的语法 避免不必要的命名空间 避免不必要的重复 最好使用表示语义的名字。一个好的类名应该是描述他是什么而不是像什么 避免!important，可以选择其他选择器 尽可能的精简规则，可以合并不同类里的重复规则 二、JSJS数据类型JS基本有5种简单数据类型：String，Number，Boolean，Null，Undefined。引用数据类型：Object，Array，Function。 判断数据类型的方法在写业务逻辑的时候，经常要用到JS数据类型的判断，面试常见的案例深浅拷贝也要用到数据类型的判断。 typeof12345678console.log(typeof 2); // numberconsole.log(typeof true); // booleanconsole.log(typeof &#x27;str&#x27;); // stringconsole.log(typeof undefined); // undefinedconsole.log(typeof []); // object console.log(typeof &#123;&#125;); // objectconsole.log(typeof function()&#123;&#125;); // functionconsole.log(typeof null); // object 优点：能够快速区分基本数据类型缺点：不能将Object、Array和Null区分，都返回object instanceof123456console.log(2 instanceof Number); // falseconsole.log(true instanceof Boolean); // false console.log(&#x27;str&#x27; instanceof String); // false console.log([] instanceof Array); // trueconsole.log(function()&#123;&#125; instanceof Function); // trueconsole.log(&#123;&#125; instanceof Object); // true 优点：能够区分Array、Object和Function，适合用于判断自定义的类实例对象缺点：Number，Boolean，String基本数据类型不能判断 Object.prototype.toString.call()12345678910var toString = Object.prototype.toString; console.log(toString.call(2)); //[object Number]console.log(toString.call(true)); //[object Boolean]console.log(toString.call(&#x27;str&#x27;)); //[object String]console.log(toString.call([])); //[object Array]console.log(toString.call(function()&#123;&#125;)); //[object Function]console.log(toString.call(&#123;&#125;)); //[object Object]console.log(toString.call(undefined)); //[object Undefined]console.log(toString.call(null)); //[object Null] 优点：精准判断数据类型缺点：写法繁琐不容易记，推荐进行封装后使用 var,let,const的区别let 为 ES6 新添加申明变量的命令，它类似于 var，但是有以下不同： var 声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象 let 声明的变量，其作用域为该语句所在的代码块内，不存在变量提升 const声明的变量不允许修改 null和undefined区别Undefined类型只有一个值，即undefined。当声明的变量还未被初始化时，变量的默认值为undefined。用法： 变量被声明了，但没有赋值时，就等于undefined。 调用函数时，应该提供的参数没有提供，该参数等于undefined。 对象没有赋值的属性，该属性的值为undefined。 函数没有返回值时，默认返回undefined。 Null类型也只有一个值，即null。null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。用法 作为函数的参数，表示该函数的参数不是对象。 作为对象原型链的终点。 定义函数的方法 函数声明 12345//ES5function getSum()&#123;&#125;function ()&#123;&#125;//匿名函数//ES6()=&gt;&#123;&#125; 函数表达式 1234//ES5var getSum=function()&#123;&#125;//ES6let getSum=()=&gt;&#123;&#125; 构造函数 1const getSum = new Function(&#x27;a&#x27;, &#x27;b&#x27; , &#x27;return a + b&#x27;) JS作用域的理解 JS中的作用域分为两种：全局作用域和函数作用域。函数作用域中定义的变量，只能在函数中调用，外界无法访问。没有块级作用域导致了if或for这样的逻辑语句中定义的变量可以被外界访问，因此ES6中新增了let和const命令来进行块级作用域的声明。 更多作用域的了解可以看JS作用域 闭包的理解 简单来说闭包就是在函数里面声明函数，本质上说就是在函数内部和函数外部搭建起一座桥梁，使得子函数可以访问父函数中所有的局部变量，但是反之不可以，这只是闭包的作用之一，另一个作用，则是保护变量不受外界污染，使其一直存在内存中，在工作中我们还是少使用闭包的好，因为闭包太消耗内存，不到万不得已的时候尽量不使用。 更多闭包的内容可以看JS闭包 数组去重123456789101112let arr = [1,&#x27;1&#x27;,2,&#x27;2&#x27;,1,2,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;f&#x27;,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;f&#x27;];function unique1(arr)&#123; let result = [arr[0]]; for (let i = 1; i &lt; arr.length; i++) &#123; let item = arr[i]; if(result.indexOf(item) == -1)&#123; result.push(item); &#125; &#125; return result;&#125;console.log(unique1(arr)); 更多JS去重的方法JS数组去重 call,apply和bind区别三个函数的作用都是将函数绑定到上下文中，用来改变函数中this的指向；三者的不同点在于语法的不同。 12fun.call(thisArg[, arg1[, arg2[, ...]]])fun.apply(thisArg, [argsArray]) 所以apply和call的区别是call方法接受的是若干个参数列表，而apply接收的是一个包含多个参数的数组。 而bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。 12var bindFn = fun.bind(thisArg[, arg1[, arg2[, ...]]])bindFn() Demos： 1234567891011121314151617181920212223242526var name = &#x27;window&#x27;;var sayName = function (param) &#123; console.log(&#x27;my name is:&#x27; + this.name + &#x27;,my param is &#x27; + param)&#125;;//my name is:window,my param is window paramsayName(&#x27;window param&#x27;)var callObj = &#123; name: &#x27;call&#x27;&#125;;//my name is:call,my param is call paramsayName.call(callObj, &#x27;call param&#x27;);var applyObj = &#123; name: &#x27;apply&#x27;&#125;;//my name is:apply,my param is apply paramsayName.apply(applyObj, [&#x27;apply param&#x27;]);var bindObj = &#123; name: &#x27;bind&#x27;&#125;var bindFn = sayName.bind(bindObj, &#x27;bind param&#x27;)//my name is:bind,my param is bind parambindFn(); ==和===区别 ==， 两边值类型不同的时候，要先进行类型转换，再比较 ===，不做类型转换，类型不同的一定不等。 ==类型转换过程： 如果类型不同，进行类型转换 判断比较的是否是 null 或者是 undefined, 如果是, 返回 true . 判断两者类型是否为 string 和 number, 如果是, 将字符串转换成 number 判断其中一方是否为 boolean, 如果是, 将 boolean 转为 number 再进行判断 判断其中一方是否为 object 且另一方为 string、number 或者 symbol , 如果是, 将 object 转为原始类型再进行判断 经典面试题：[] == ![] 为什么是true 转化步骤： !运算符优先级最高，![]会被转为为false，因此表达式变成了：[] == false 根据上面第(4)条规则，如果有一方是boolean，就把boolean转为number，因此表达式变成了：[] == 0 根据上面第(5)条规则，把数组转为原始类型，调用数组的toString()方法，[]转为空字符串，因此表达式变成了：&#39;&#39; == 0 根据上面第(3)条规则，两边数据类型为string和number，把空字符串转为0，因此表达式变成了：0 == 0 两边数据类型相同，0==0为true 深拷贝和浅拷贝浅拷贝 1234567function simpleClone(obj) &#123; var result = &#123;&#125;; for (var i in obj) &#123; result[i] = obj[i]; &#125; return result;&#125; 深拷贝，遍历对象中的每一个属性 123456789101112131415161718function deepClone(obj) &#123; let result; if (typeof obj == &#x27;object&#x27;) &#123; result = isArray(obj) ? [] : &#123;&#125; for (let i in obj) &#123; result[i] = isObject(obj[i])||isArray(obj[i])?deepClone(obj[i]):obj[i] &#125; &#125; else &#123; result = obj &#125; return result&#125;function isObject(obj) &#123; return Object.prototype.toString.call(obj) == &quot;[object Object]&quot;&#125;function isArray(obj) &#123; return Object.prototype.toString.call(obj) == &quot;[object Array]&quot;&#125; 防抖和节流 防抖 123456789function debounce(fn, delay) &#123; let timer = null; return function () &#123; if (timer) clearTimeout(timer); timer = setTimeout(() =&gt; &#123; fn.apply(this, arguments); &#125;, delay); &#125;&#125; 节流 123456789101112131415161718function throttle(fn, cycle) &#123; let start = Date.now(); let now; let timer; return function () &#123; now = Date.now(); clearTimeout(timer); if (now - start &gt;= cycle) &#123; fn.apply(this, arguments); start = now; &#125; else &#123; timer = setTimeout(() =&gt; &#123; fn.apply(this, arguments); &#125;, cycle); &#125; &#125;&#125; cookie,sessionStorage和localStorage cookie用来保存登录信息，大小限制为4KB左右 localStorage是Html5新增的，用于本地数据存储，保存的数据没有过期时间，一般浏览器大小限制在5MB sessionStorage接口方法和localStorage类似，但保存的数据的只会在当前会话中保存下来，页面关闭后会被清空。 名称 生命期 大小限制 与服务器通信 cookie 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 4KB 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 localStorage 除非被清除，否则永久保存 5MB 仅在浏览器中保存，不与服务器通信 sessionStorage 仅在当前会话下有效，关闭页面或浏览器后被清除 5MB 仅在浏览器中保存，不与服务器通信 0.1+0.2!=0.3怎么处理把需要计算的数字升级（乘以10的n次幂）成计算机能够精确识别的整数，等计算完成后再进行降级（除以10的n次幂），即： 1(0.1*10 + 0.2*10)/10 == 0.3 //true 更多关于浮点数精度处理请看JS中浮点数精度问题 JS实现继承首先创建一个父类 1234567891011121314// 定义一个动物类function Animal(name, color) &#123; // 属性 this.name = name || &#x27;Animal&#x27;; this.color = color || [&#x27;black&#x27;]; // 实例方法 this.sleep = function () &#123; console.log(this.name + &#x27;正在睡觉！&#x27;); &#125;&#125;// 原型方法Animal.prototype.eat = function (food) &#123; console.log(this.name + &#x27;正在吃：&#x27; + food);&#125;; 原型链继承new了一个空对象，这个空对象指向Animal并且Cat.prototype指向了这个空对象，这种就是基于原型链的继承。 1234567891011121314function Cat(name) &#123; this.name = name || &#x27;tom&#x27;&#125;Cat.prototype = new Animal()var cat = new Cat()cat.color.push(&#x27;red&#x27;)cat.sleep() //tom正在睡觉！cat.eat(&#x27;fish&#x27;) //tom正在吃：fishconsole.log(cat.color) //[&quot;black&quot;, &quot;red&quot;]console.log(cat instanceof Animal) //trueconsole.log(cat instanceof Cat) //truevar new_cat = new Cat()console.log(new_cat.color) //[&quot;black&quot;, &quot;red&quot;] 特点：基于原型链，既是父类的实例，也是子类的实例。 缺点：1.无法实现多继承；2.所有新实例都会共享父类实例的属性。 构造继承12345678910111213function Dog(name) &#123; Animal.call(this) this.name = name || &#x27;mica&#x27;&#125;var dog = new Dog()dog.color.push(&#x27;blue&#x27;)dog.sleep() // mica正在睡觉！dog.eat(&#x27;bone&#x27;) //Uncaught TypeError: dog.eat is not a functionconsole.log(dog.color) //[&quot;black&quot;, &quot;blue&quot;]console.log(dog instanceof Animal) //falseconsole.log(dog instanceof Dog) //truevar new_dog = new Dog()console.log(new_dog.color) //[&quot;black&quot;] 特点：可以实现多继承（call多个），解决了所有实例共享父类实例属性的问题。 缺点：1.只能继承父类实例的属性和方法；2.不能继承原型上的属性和方法。 组合继承123456789101112131415function Mouse(name)&#123; Animal.call(this) this.name = name || &#x27;jerry&#x27;&#125;Mouse.prototype = new Animal()Mouse.prototype.constructor = Mousevar mouse = new Mouse()mouse.color.push(&#x27;yellow)mouse.sleep() //jerry正在睡觉！mouse.eat(&#x27;carrot&#x27;) //jerry正在吃：carrotconsole.log(mouse instanceof Animal)//trueconsole.log(mouse instanceof Mouse)//truevar new_mouse = new Mouse()console.log(new_mouse.color) //[&quot;black&quot;] 特点：可以继承实例属性/方法，也可以继承原型属性/方法 缺点：调用了两次父类构造函数，生成了两份实例 三、vuemvc和mvvm理解MVCMVC即Model View Controller，简单来说就是通过controller的控制去操作model层的数据，并且返回给view层展示。 View 接受用户交互请求 View 将请求转交给Controller处理 Controller 操作Model进行数据更新保存 数据更新保存之后，Model会通知View更新 View 更新变化数据使用户得到反馈 MVVMMVVM即Model-View-ViewModel，将其中的 View 的状态和行为抽象化，让我们可以将UI和业务逻辑分开。MVVM的优点是低耦合、可重用性、独立开发。 View 接收用户交互请求 View 将请求转交给ViewModel ViewModel 操作Model数据更新 Model 更新完数据，通知ViewModel数据发生变化 ViewModel 更新View数据 MVVM模式和MVC有些类似，但有以下不同 ViewModel 替换了 Controller，在UI层之下 ViewModel 向 View 暴露它所需要的数据和指令对象 ViewModel 接收来自 Model 的数据 概括起来，MVVM是由MVC发展而来，通过在Model之上而在View之下增加一个非视觉的组件将来自Model的数据映射到View中。 响应原理vue采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty劫持data属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 生命周期函数 beforeCreate(创建前) vue实例的挂载元素$el和数据对象 data都是undefined, 还未初始化 created(创建后) 完成了 data数据初始化, el还未初始化 beforeMount(载入前) vue实例的$el和data都初始化了, 相关的render函数首次被调用 mounted(载入后) 此过程中进行ajax交互 beforeUpdate(更新前) updated(更新后) beforeDestroy(销毁前) destroyed(销毁后) 组件data为什么返回函数组件中的data写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的data。如果单纯的写成对象形式，就使得所有组件实例共用了一份data，造成了数据污染。 vue给对象新增属性页面没有响应由于Vue会在初始化实例时对属性执行getter/setter转化，所以属性必须在data对象上存在才能让Vue将它转换为响应式的。Vue提供了$set方法用来触发视图更新。 12345678910111213export default &#123; data()&#123; return &#123; obj: &#123; name: &#x27;fei&#x27; &#125; &#125; &#125;, mounted()&#123; this.$set(this.obj, &#x27;sex&#x27;, &#x27;man&#x27;) &#125;&#125; v-if和v-show区别v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。 所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。 v-model双向绑定原理v-model本质上是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件。 text 和 textarea 元素使用 value 属性和 input 事件 checkbox 和 radio 使用 checked 属性和 change 事件 select 字段将 value 作为 prop 并将 change 作为事件 所以我们可以v-model进行如下改写： 123&lt;input v-model=&quot;sth&quot; /&gt;// 等同于&lt;input :value=&quot;sth&quot; @input=&quot;sth = $event.target.value&quot; /&gt; 这个语法糖必须是固定的，也就是说属性必须为value，方法名必须为：input。 知道了v-model的原理，我们可以在自定义组件上实现v-model。 12345678910111213141516171819202122232425//Parent&lt;template&gt; &#123;&#123;num&#125;&#125; &lt;Child v-model=&quot;num&quot;&gt;&lt;/template&gt;export default &#123; data()&#123; return &#123; num: 0 &#125; &#125;&#125;//Child&lt;template&gt; &lt;div @click=&quot;add&quot;&gt;Add&lt;/div&gt;&lt;/template&gt;export default &#123; props: [&#x27;value&#x27;], methods:&#123; add()&#123; this.$emit(&#x27;input&#x27;, this.value + 1) &#125; &#125;&#125; key的作用 让vue精准的追踪到每一个元素，高效的更新虚拟DOM。 触发过渡 123&lt;transition&gt; &lt;span :key=&quot;text&quot;&gt;&#123;&#123; text &#125;&#125;&lt;/span&gt;&lt;/transition&gt; 当text改变时，这个元素的key属性就发生了改变，在渲染更新时，Vue会认为这里新产生了一个元素，而老的元素由于key不存在了，所以会被删除，从而触发了过渡。 scoped属性作用 在Vue文件中的style标签上有一个特殊的属性，scoped。当一个style标签拥有scoped属性时候，它的css样式只能用于当前的Vue组件，可以使组件的样式不相互污染。如果一个项目的所有style标签都加上了scoped属性，相当于实现了样式的模块化。 scoped属性的实现原理是给每一个dom元素添加了一个独一无二的动态属性，给css选择器额外添加一个对应的属性选择器，来选择组件中的dom。 12345678&lt;template&gt; &lt;div class=&quot;box&quot;&gt;dom&lt;/div&gt;&lt;/template&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.box&#123; background:red;&#125;&lt;/style&gt; vue将代码转译成如下： 123456.box[data-v-11c6864c]&#123; background:red;&#125;&lt;template&gt; &lt;div class=&quot;box&quot; data-v-11c6864c&gt;dom&lt;/div&gt;&lt;/template&gt; scoped样式穿透scoped虽然避免了组件间样式污染，但是很多时候我们需要修改组件中的某个样式，但是又不想去除scoped属性。 使用/deep/ 1234567891011121314151617//Parent&lt;template&gt;&lt;div class=&quot;wrap&quot;&gt; &lt;Child /&gt;&lt;/div&gt;&lt;/template&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.wrap /deep/ .box&#123; background: red;&#125;&lt;/style&gt;//Child&lt;template&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/template&gt; 使用两个style标签 1234567891011121314151617181920//Parent&lt;template&gt;&lt;div class=&quot;wrap&quot;&gt; &lt;Child /&gt;&lt;/div&gt;&lt;/template&gt;&lt;style lang=&quot;scss&quot; scoped&gt;//其他样式&lt;/style&gt;&lt;style lang=&quot;scss&quot;&gt;.wrap .box&#123; background: red;&#125;&lt;/style&gt;//Child&lt;template&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/template&gt; ref的作用 获取dom元素this.$refs.box 获取子组件中的datathis.$refs.box.msg 调用子组件中的方法this.$refs.box.open() computed和watch区别1.当页面中有某些数据依赖其他数据进行变动的时候，可以使用计算属性computed。 1234567891011121314&lt;template&gt;&#123;&#123;fullName&#125;&#125;&lt;/template&gt;export default &#123; data()&#123; return &#123; firstName: &#x27;xie&#x27;, lastName: &#x27;yu fei&#x27;, &#125; &#125;, computed:&#123; fullName: function()&#123; return this.firstName + &#x27; &#x27; + this.lastName &#125; &#125;&#125; 2.watch用于观察和监听页面上的vue实例，如果要在数据变化的同时进行异步操作或者是比较大的开销，那么watch为最佳选择。 123456789101112131415161718&lt;template&gt;&#123;&#123;fullName&#125;&#125;&lt;/template&gt;export default &#123; data()&#123; return &#123; firstName: &#x27;xie&#x27;, lastName: &#x27;xiao fei&#x27;, fullName: &#x27;xie xiao fei&#x27; &#125; &#125;, watch:&#123; firstName(val) &#123; this.fullName = val + &#x27; &#x27; + this.lastName &#125;, lastName(val) &#123; this.fullName = this.firstName + &#x27; &#x27; + val &#125; &#125;&#125; vue路由有几种模式 hash模式 即地址栏URL中的#符号，它的特点在于：hash 虽然出现URL中，但不会被包含在HTTP请求中，对后端完全没有影响，不需要后台进行配置，因此改变hash不会重新加载页面。 history模式 利用了HTML5 History Interface 中新增的pushState() 和replaceState() 方法（需要特定浏览器支持）。history模式改变了路由地址，因为需要后台配置地址。 组件之间的传值通信 父组件给子组件传值通过props 子组件给父组件传值通过$emit触发回调 兄弟组件通信，通过实例一个vue实例eventBus作为媒介，要相互通信的兄弟组件之中，都引入eventBus 1234567891011121314151617181920212223//main.jsimport Vue from &#x27;vue&#x27;export const eventBus = new Vue()//brother1.vueimport eventBus from &#x27;@/main.js&#x27;export default&#123; methods: &#123; toBus () &#123; eventBus.$emit(&#x27;greet&#x27;, &#x27;hi brother&#x27;) &#125; &#125;&#125;//brother2import eventBus from &#x27;@/main.js&#x27;export default&#123; mounted()&#123; eventBus.$on(&#x27;greet&#x27;, (msg)=&gt;&#123; this.msg = msg &#125;) &#125;&#125; axios拦截器怎么配12345678910111213141516// 添加请求拦截器axios.interceptors.request.use(function (config) &#123; // 在发送请求之前做些什么 return config;&#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error);&#125;);// 添加响应拦截器axios.interceptors.response.use(function (response) &#123; // 对响应数据做点什么 return response; &#125;, function (error) &#123; // 对响应错误做点什么 return Promise.reject(error); &#125;); 四、浏览器浏览器渲染机制 构建DOM树（parse）：渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node 构建渲染树（construct）：解析对应的CSS样式文件信息 布局渲染树（reflow/layout）：从根节点递归调用，计算每一个元素的大小、位置等，给出每个节点所应该在屏幕上出现的精确坐标； 绘制渲染树（paint/repaint）：遍历渲染树，使用UI后端层来绘制每个节点。 重绘和重排的区别重绘（repaint或redraw）：当盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来之后，浏览器便把这些原色都按照各自的特性绘制一遍，将内容呈现在页面上。重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。 重绘发生在元素的可见的外观被改变，但并没有影响到布局的时候。比如，仅修改DOM元素的字体颜色（只有Repaint，因为不需要调整布局） 重排（重构/回流/reflow）：当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建, 这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。 触发重排的条件：任何页面布局和几何属性的改变都会触发重排： 页面渲染初始化(无法避免) 添加或删除可见的DOM元素 元素位置的改变，或者使用动画 元素尺寸的改变——大小，外边距，边框 浏览器窗口尺寸的变化 填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变 重排必定会引发重绘，但重绘不一定会引发重排。 几种请求方法GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE get和post区别 请求方式 GET POST 参数位置 参数拼接到url的后面 参数在请求体中 参数大小 受限于浏览器url大小，一般不超过32K 1G 服务器数据接收 接收1次 根据数据大小，可分多次接收 适用场景 从服务器端获取数据 向服务器提交数据 安全性 参数携带在url中，安全性低 相对于GET请求，安全性更高 如何解决跨域 CORS jsonp 服务器代理 更多CORS请看彻底读懂前端跨域CORS JSONP原理由于浏览器的同源策略限制，不允许跨域请求；但是页面中的 script、img、iframe标签是例外，不受同源策略限制。 Jsonp 就是利用script标签跨域特性进行请求。 JSONP 的原理就是，先在全局注册一个回调函数，定义回调数据的处理；与服务端约定好一个同名回调函数名，服务端接收到请求后，将返回一段 Javascript，在这段 Javascript 代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网页接收到这段 Javascript 代码后，就会执行这个回调函数。 JSONP缺点：它只支持GET请求，而不支持POST请求等其他类型的HTTP请求。 缓存的理解缓存分为强缓存和协商缓存。强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的状态码是304。两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。 强缓存 Expires cache-control 协商缓存 Last-Modified 和 If-Modified-Since Etag 和 If-None-Match 更多缓存内容请看前端也要懂Http缓存机制 XSS和CSRF区别 跨站脚本攻击（Cross Site Scripting)，为了不和层叠样式表 CSS 混淆，故将跨站脚本攻击缩写为 XSS。恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页之时，嵌入其中 Web 里面的 Script 代码会被执行，从而达到恶意攻击用户的目的。 跨站请求伪造（Cross-site request forgery），是伪造请求，冒充用户在站内的正常操作。我们知道，绝大多数网站是通过 cookie 等方式辨识用户身份，再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 XSS 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。 区别： 原理不同，CSRF是利用网站A本身的漏洞，去请求网站A的api；XSS是向目标网站注入JS代码，然后执行JS里的代码。 CSRF需要用户先登录目标网站获取cookie，而XSS不需要登录 CSRF的目标是用户，XSS的目标是服务器 XSS是利用合法用户获取其信息，而CSRF是伪造成合法用户发起请求 HTTP与HTTPS的区别 HTTP的URL由http://起始且默认使用端口80，而HTTPS的URL由https://起始且默认使用端口443 HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的 SSL 加密传输协议 HTTP的连接很简单，是无状态的，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全 HTTP状态码1xx表示客户端应该继续发送请求 2xx表示成功的请求 200表示OK，正常返回信息 201表示请求成功且服务器创建了新的资源 202表示服务器已经接受了请求，但还未处理 3xx表示重定向 301表示永久重定向，请求的网页已经永久移动到新位置 302表示临时重定向 304表示自从上一次请求以来，页面的内容没有改变过 4xx表示客户端错误 401表示服务器无法理解请求的格式 402表示请求未授权 403表示禁止访问 404表示请求的资源不存在，一般是路径写错了 5xx表示服务器错误 500表示最常见的服务器错误 503表示服务器暂时无法处理请求 五、性能优化 使用CDN gzip压缩 文本压缩 合并请求 雪碧图 图片懒加载 缓存资源 减少DOM操作 六、参考flexCSS清除浮动圣杯布局和双飞翼布局的理解与思考一图秒懂函数防抖和函数节流web前端面试总结公司要求会使用框架vue，面试题会被问及哪些30道Vue面试题总结了17年初到18年初百场前端面试的面试经验面试分享：两年工作经验成功面试阿里P6总结","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"面试","slug":"Interview","permalink":"http://xieyufei.com/tags/Interview/"}]},{"title":"彻底读懂前端跨域CORS","date":"2019-08-29T10:56:39.000Z","path":"2019/08/29/Cors.html","text":"前端小伙伴在使用AJAX的时候，相信对No Access-Control-Allow-Origin header这样的报错提示感到很头疼，怎么请求又跨域了。 文章的开始，让我们从一个小故事开始。。。 一个小故事 在开发中，前端的童鞋们每次看到浏览器下面出现一长串红色的跨域报错就会很恼火，不停的念叨着：那个谁谁谁，又没有给我加跨域头；后端小伙伴又会毫不示弱地反击道：不就是Access-Control-Allow-Origin: *么？已经有了啊！那为什么还会报错？肯定是你没加好！ 于是，一场甩锅大战即将开始… 谁应该了解跨域 说实话，每一个前后端开发都应该要了解跨域的用法。 前端的小伙伴可能会觉得跨域问题应该都是后端接口来处理的，但是如果多了解一些HTTP请求响应头的，能够更快的定位问题，更快的解决接口异常，方便排查调试，所以希望能够耐下心把这篇文章看完。 什么时候会跨域 在MDN中，对跨域是这么解释的： 跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。 简单来说就是当你向不同“域”的服务器发起网络请求的时候，这个请求就跨域了。这里不同“域”指的是不同的协议、域名、端口，有任何一个不同时，浏览器都视为跨域。我们在使用postman、fiddler等一些工具模拟发起http请求的时候，不会遇到跨域的情况；当我们在浏览器中请求不同域名的时候，虽然请求正常发出了，但是浏览器在请求返回时会进行一系列的校验，判断此次请求是否“合法”；如果不合法，返回结果就被浏览器拦截了。 我们在进行POST或其他跨域请求时，会发现只有一个OPTIONS请求，并没有我们想要的请求方法。 神秘的OPTIONS请求 我们没有发送OPTIONS请求，那么它是从哪里来的呢？它的名称叫CORS请求预检，首先来看一下官方对它的定义是： HTTP的OPTIONS方法用于获取目的资源所支持的通信选项。客户端可以对特定的URL使用OPTIONS方法，也可以对整站（通过将 URL 设置为“*”）使用该方法。 选项 是否允许 备注 Request has body No 没有请求体 Successful response has body No 成功的响应有响应体 Safe Yes 安全 Idempotent Yes 密等性，不变性，同一个接口请求多少次都一样 Cacheable No 不能缓存 Allowed in HTML forms No 不能在表单里使用 根据官网的文档，我们发现它没有请求体，不能设置data，也不能直接发起OPTIONS请求。简言之，OPTIONS请求是用于请求服务器对于某些接口等资源的支持情况的，包括各种请求方法、头部的支持情况，仅作查询使用。 让我们详细地看一下OPTIONS请求的真实面目吧，我们首先构造一个POST请求： 1234567891011var instance = axios.create(&#123; baseURL: &#x27;http://192.168.0.100:8081&#x27;&#125;)instance(&#123; url: &#x27;/post&#x27;, method: &#x27;post&#x27;, data:&#123; url: &#x27;xieyufei.com&#x27; &#125;&#125;) 可以看到OPTIONS请求头很简单，都没有请求的body，有两个字段Access-Control-Request-Headers和Access-Control-Request-Method是新出现的，下面会说到这两个字段的用法；那么什么时候会触发OPTIONS请求呢，这里涉及到两种CORS请求。 两种请求 浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request），简单请求不会触发CORS预检请求。 简单请求 只要同时满足以下两大条件，就属于简单请求： 请求方法是以下三种方法之一 HEAD GET POST HTTP的头信息不超出以下几种字段 Accept Accept-Language Content-Language Content-Type 只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain DPR Downlink Save-Data Viewport-Width Viewport-Width 因此我们只要把上面的请求加一个请求头Content-Type，就能不触发OPTIONS请求。 12345678910instance(&#123; url: &#x27;/post&#x27;, method: &#x27;post&#x27;, headers:&#123; &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27; &#125;, data:&#123; url: &#x27;xieyufei.com&#x27; &#125;&#125;) 非简单请求 下面，我们的重点来了，我们在进行ajax请求时，一般都会在请求头加一下自定义的数据，因此大多数请求都是非简单请求。非简单请求涉及以下几个请求和响应的头部的字段： 字段名 位置 用法 备注 Origin 请求头 origin 表明预检请求或实际请求的源站 Access-Control-Request-Method 请求头 method 将实际请求所使用的 HTTP 方法告诉服务器。 Access-Control-Request-Headers 请求头 field-name[, field-name]* 将实际请求所携带的头部字段告诉服务器。 Access-Control-Allow-Origin 响应头 origin or * 对于不需要携带身份凭证的请求，服务器可以指定该字段的值为通配符，表示允许来自所有域的请求 Access-Control-Allow-Methods 响应头 method[, method]* 指明了实际请求所允许使用的 HTTP 方法。 Access-Control-Allow-Headers 响应头 field-name[, field-name]* 指明了实际请求中允许携带的头部字段。 Access-Control-Allow-Credentials 响应头 true 指定了当浏览器的credentials设置为true时是否允许浏览器读取response的内容 Access-Control-Max-Age 响应头 delta-seconds 指定了请求的结果能够被缓存多久 在上面的OPTIONS请求中我们可以发现表格中的三个请求头部都在该次请求中出现了，Access-Control-Request-Method和Access-Control-Request-Headers用来询问服务器，下面我要用POST方法和Content-Type头部来请求，你就说你答不答应吧？ 在服务器端，我们可以这么写来允许请求跨域： 1234567891011121314151617181920const express = require(&#x27;express&#x27;)const app = express()const PORT = 8081let allowCrossDomain = function (req, res, next) &#123; res.header(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;) res.header(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;POST&#x27;) res.header(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;content-type&#x27;) next()&#125;app.use(allowCrossDomain)app.post(&#x27;/post&#x27;, (req, res) =&gt; &#123; res.json(&#123; msg: &#x27;hi post&#x27; &#125;)&#125;)app.listen(PORT) 这里有我们后端小伙伴很熟悉的Access-Control-Allow-Origin: *，用来表明所有的origin都允许跨域，相当于告诉浏览器： 这样我们就能看到我们期待已久的POST请求，同时返回的头部信息中带上了CORS的响应头；同时我们可以看到axios默认的Content-Type是application/json;charset=UTF-8，不在仅限的三个值中，因此会触发OPTIONS请求。 其他头部信息 除了content-type，我们还可以在请求头中添加一些自己定义的信息，比如需要传给后台的token之类的。 12345678910111213141516//浏览器端instance(&#123; url: &#x27;/put&#x27;, method: &#x27;put&#x27;, headers:&#123; &#x27;X-Custom-Header&#x27;: &#x27;xieyufei-head&#x27; &#125;, data:&#123; url: &#x27;xieyufei.com&#x27; &#125;&#125;)//服务器端res.header(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;)res.header(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;POST,PUT&#x27;)res.header(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;content-type, X-Custom-Header&#x27;) 跨域获取Cookie 默认情况下，Cookie是不包括在CORS的请求中，但有时候我们又需要用到Cookie来传输数据，这时候我们的Access-Control-Allow-Credentials字段就派上用处了，另一方面，需要在AJAX请求中打开withCredentials属性；我们再把代码进行如下改造： 12345678910111213141516//服务器端res.header(&#x27;Access-Control-Allow-Credentials&#x27;, &#x27;true&#x27;)//浏览器端instance(&#123; url: &#x27;/put&#x27;, method: &#x27;put&#x27;, //新增withCredentials withCredentials: true, headers:&#123; &#x27;X-Custom-Header&#x27;: &#x27;xieyufei-head&#x27; &#125;, data:&#123; url: &#x27;xieyufei.com&#x27; &#125;&#125;) 当我们满怀期待打开浏览器准备接收Cookie时，却发现又报错了： 经过对错误信息仔细阅读，发现这次报错跟上面的跨域报错不完全一样，大概的意思是当请求的身份凭证包括的时候，Access-Control-Allow-Origin不能是通配符’*’（wildcard）。因此我们大概了解到了错误的原因是在通配符上面，我们对代码再进行一下改造： 1234567891011121314const cookieParser = require(&#x27;cookie-parser&#x27;); app.use(cookieParser())res.header(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;)res.header(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;POST&#x27;)res.header(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;content-type, X-Custom-Header&#x27;)res.header(&#x27;Access-Control-Allow-Credentials&#x27;, &#x27;true&#x27;)app.post(&#x27;/post&#x27;, (req, res) =&gt; &#123; console.log(req.cookies, &#x27;cookie&#x27;) res.json(&#123; msg: &#x27;hi post&#x27; &#125;)&#125;) 这时候就能看到我们想要的Cookie了。 总结 CORS内容其实来说不是很多，也比较简单，但是考验动手实践能力，面试时一般也会问到，因此通过express搭建服务器来加深对CORS知识的了解。","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"跨域","slug":"CrossDomain","permalink":"http://xieyufei.com/tags/CrossDomain/"}]},{"title":"JS的this指向","date":"2019-03-06T13:36:00.000Z","path":"2019/03/06/This-Point.html","text":"js函数中this是面试官最喜欢考察的，整理一下常用的this指向的知识点。 一、全局上下文非严格模式和严格模式中this都是指向顶层对象 12this.myname = &#x27;xyf&#x27;console.log(this) //Window &#123;myname: &#x27;xyf&#x27;, …&#125; 二、函数上下文普通函数在非严格模式下，普通函数的this指向window &#123;.line-numbers&#125;123456var myname = &#x27;xyf&#x27;var sayName = function()&#123; console.log(this === window) // true console.log(this.myname) // &#x27;xyf&#x27;&#125;sayName() 这里的sayName()相当于调用了window.sayName()。在严格模式下，普通函数的this指向undefined 1234567&#x27;use strict&#x27;var myname = &#x27;xyf&#x27;var sayName = function()&#123; console.log(this === window) // false console.log(this.myname) // 报错，因为this是undefined&#125;sayName() 在ES5中，var会给顶层对象中（浏览器是window）添加属性，而使用let则不会。 123456let myname = &#x27;xyf&#x27;let sayName = function()&#123; console.log(this === window) // true console.log(this.myname) // undefined&#125;sayName() 对象中的函数对象中的函数this指向对象本身 12345678910111213141516var myname = &#x27;outside name&#x27;var sayName = function()&#123; console.log(this.myname)&#125;var person = &#123; myname: &#x27;inside name&#x27;, sayName: sayName, other: &#123; myname: &#x27;other name&#x27;, sayName: sayName, &#125;&#125;person.sayName() // &#x27;inside name&#x27;person.other.sayName() // &#x27;other name&#x27; 将对象中的函数赋值成变量，这样又变成普通函数，this指向顶层对象。 12var newSayName = person.sayName;newSayName() // &#x27;outside name&#x27; 所以，通过上面我们可以看出来，函数的定义位置不影响其this指向,this指向只和调用函数的对象有关。 call、apply、bind改变this指向通过call、apply、bind可以改变函数this的指向 语法： 12fun.call(thisArg, arg1, arg2, ...)fun.apply(thisArg, [arg1, arg2, ...]) thisArg是fun函数在运行时指定的this的值。但是指定的this值不一定就是该函数执行时真正的this值。如果这个函数处于非严格模式下，指定为null和undefined的this值会自动指向全局对象（windows中就是window对象）；指定为原始值（数字，字符串，布尔值）的this会指向该原始值的自动包装对象； 123456789101112var sayName = function(name1,name2)&#123; console.log(this, name1, name2) &#125;// Number &#123;1&#125; &#x27;a&#x27; &#x27;b&#x27;sayName.call(1, &#x27;a&#x27;, &#x27;b&#x27;)// Window &#123; … &#125; &#x27;a&#x27; &#x27;b&#x27;sayName.call(null, &#x27;a&#x27;, &#x27;b&#x27;)// Window &#123; … &#125; &#x27;a&#x27; &#x27;b&#x27;sayName.call(undefined, &#x27;a&#x27;, &#x27;b&#x27;) apply和call类似。只是参数不一样。它的参数是数组（或者类数组）。 1sayName.apply(1, [&#x27;a&#x27;, &#x27;b&#x27;]) 严格模式下，指向null和undefined的this值还是指向原来的。 1234567var sayName = function(name1,name2)&#123; &#x27;use strict&#x27; console.log(this, name1, name2) &#125;sayName.call(null, &#x27;a&#x27;, &#x27;b&#x27;)// null &#x27;a&#x27; &#x27;b&#x27; bind和call和apply的调用方式相同，第一个值也是修改this的指向，只不过bind返回一个新的函数。 构造函数调用模式1234567function Dog(name)&#123; this.name = name; console.log(this)&#125;var puppy = new Dog(&#x27;apple&#x27;)// Dog &#123;name: &quot;apple&quot;&#125; 由此可知，new操作符调用时，this指向生成的新对象。 原型链中的调用模式12345678910function Dog(name)&#123; this.name = name;&#125;var puppy = new Dog(&#x27;apple&#x27;)Dog.prototype.bark = function()&#123; console.log(this, this.name)&#125;puppy.bark()//Dog &#123;name: &quot;apple&quot;&#125; &quot;apple&quot; 箭头函数调用模式先看箭头函数和普通函数的重要区别： 没有自己的this、super、arguments和new.target绑定。 不能使用new来调用。 没有原型对象。 不可以改变this的绑定。 形参名称不能重复。 箭头函数中没有this绑定，必须通过查找作用域链来决定其值。 如果箭头函数被非箭头函数包含，则this绑定的是最近一层非箭头函数的this，否则this的值则被设置为全局对象。 比如： 123456789101112131415var name = &#x27;out&#x27;var people = &#123; name: &#x27;xyf&#x27;, sayName: function()&#123; var arrowFun = () =&gt; &#123; console.log(this.name) &#125; arrowFun() &#125;, arrowSayName: () =&gt; &#123; console.log(this.name) &#125;&#125;people.sayName()people.arrowSayName() 总结如果要判断一个运行中函数的 this 绑定， 就需要找到这个函数的直接调用位置。","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"面试","slug":"Interview","permalink":"http://xieyufei.com/tags/Interview/"}]},{"title":"前端也要懂Http缓存机制","date":"2018-08-06T13:00:00.000Z","path":"2018/08/06/Http-Cache.html","text":"最近在看面试题的时候总会看到有一些关于Http缓存的题目，但是总是一知半解，不甚理解；尤其是Http头信息中有一大堆的字段，什么if-modified-since，什么if-none-match，真是令人头疼。后来突然想到，要是能通过自己构建一个服务器，自己添加头信息，然后看实现的效果，不就更好了么。说干就干，在网上各种找资料，然后再使用expressjs添加各种头信息，就能够很好的理解Http缓存了。 Http简介 浏览器和服务器之间通信是通过HTTP协议，HTTP协议永远都是客户端发起请求，服务器回送响应。模型如下： HTTP报文就是浏览器和服务器间通信时发送及响应的数据块。浏览器向服务器请求数据，发送请求(request)报文；服务器向浏览器返回数据，返回响应(response)报文。报文信息主要分为两部分： 报文头部：一些附加信息（cookie，缓存信息等），与缓存相关的规则信息，均包含在头部中 数据主体部分：HTTP请求真正想要传输的数据内容 本文用到的一些报文头如下： 字段名称 字段所属 Pragma 通用头 Expires 响应头 Cache-Control 通用头 Last-Modified 响应头 If-Modified-Sice 请求头 ETag 响应头 If-None-Match 请求头 Http缓存的分类 Http缓存可以分为两大类，强制缓存（也称强缓存）和协商缓存。两类缓存规则不同，强制缓存在缓存数据未失效的情况下，不需要再和服务器发生交互；而协商缓存，顾名思义，需要进行比较判断是否可以使用缓存。 两类缓存规则可以同时存在，强制缓存优先级高于协商缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行协商缓存规则。 原始模型 我们先简单搭建一个Express的服务器，不加任何缓存信息头。 12345678910111213141516171819202122232425262728const express = require(&#x27;express&#x27;);const app = express();const port = 8080;const fs = require(&#x27;fs&#x27;);const path = require(&#x27;path&#x27;);app.get(&#x27;/&#x27;,(req,res) =&gt; &#123; res.send(`&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; Http Cache Demo &lt;script src=&quot;/demo.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt;`)&#125;)app.get(&#x27;/demo.js&#x27;,(req, res)=&gt;&#123; let jsPath = path.resolve(__dirname,&#x27;./static/js/demo.js&#x27;); let cont = fs.readFileSync(jsPath); res.end(cont)&#125;)app.listen(port,()=&gt;&#123; console.log(`listen on $&#123;port&#125;`) &#125;) 我们可以看到请求结果如下： 请求过程如下： 浏览器请求静态资源demo.js 服务器读取磁盘文件demo.js，返给浏览器 浏览器再次请求，服务器又重新读取磁盘文件 a.js，返给浏览器。 循环请求。。 看得出来这种请求方式的流量与请求次数有关，同时，缺点也很明显： 浪费用户流量 浪费服务器资源，服务器要读磁盘文件，然后发送文件到浏览器 浏览器要等待js下载并且执行后才能渲染页面，影响用户体验 接下来我们开始在头信息中添加缓存信息。 一、强制缓存 强制缓存分为两种情况，Expires和Cache-Control。 Expires Expires的值是服务器告诉浏览器的缓存过期时间（值为GMT时间，即格林尼治时间），即下一次请求时，如果浏览器端的当前时间还没有到达过期时间，则直接使用缓存数据。下面通过我们的Express服务器来设置一下Expires响应头信息。 1234567891011121314//其他代码...const moment = require(&#x27;moment&#x27;);app.get(&#x27;/demo.js&#x27;,(req, res)=&gt;&#123; let jsPath = path.resolve(__dirname,&#x27;./static/js/demo.js&#x27;); let cont = fs.readFileSync(jsPath); res.setHeader(&#x27;Expires&#x27;, getGLNZ()) //2分钟 res.end(cont)&#125;)function getGLNZ()&#123; return moment().utc().add(2,&#x27;m&#x27;).format(&#x27;ddd, DD MMM YYYY HH:mm:ss&#x27;)+&#x27; GMT&#x27;;&#125;//其他代码... 我们在demo.js中添加了一个Expires响应头，不过由于是格林尼治时间，所以通过momentjs转换一下。第一次请求的时候还是会向服务器发起请求，同时会把过期时间和文件一起返回给我们；但是当我们刷新的时候，才是见证奇迹的时刻： 可以看出文件是直接从缓存（memory cache）中读取的，并没有发起请求。我们在这边设置过期时间为两分钟，两分钟过后可以刷新一下页面看到浏览器再次发送请求了。 虽然这种方式添加了缓存控制，节省流量，但是还是有以下几个问题的： 由于浏览器时间和服务器时间不同步，如果浏览器设置了一个很后的时间，过期时间一直没有用 缓存过期后，不管文件有没有发生变化，服务器都会再次读取文件返回给浏览器 不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。 Cache-Control 针对浏览器和服务器时间不同步，加入了新的缓存方案；这次服务器不是直接告诉浏览器过期时间，而是告诉一个相对时间Cache-Control=10秒，意思是10秒内，直接使用浏览器缓存。 123456app.get(&#x27;/demo.js&#x27;,(req, res)=&gt;&#123; let jsPath = path.resolve(__dirname,&#x27;./static/js/demo.js&#x27;); let cont = fs.readFileSync(jsPath); res.setHeader(&#x27;Cache-Control&#x27;, &#x27;public,max-age=120&#x27;) //2分钟 res.end(cont)&#125;) 二、协商缓存 强制缓存的弊端很明显，即每次都是根据时间来判断缓存是否过期；但是当到达过期时间后，如果文件没有改动，再次去获取文件就有点浪费服务器的资源了。协商缓存有两组报文结合使用： Last-Modified和If-Modified-Since ETag和If-None-Match Last-Modified 为了节省服务器的资源，再次改进方案。浏览器和服务器协商，服务器每次返回文件的同时，告诉浏览器文件在服务器上最近的修改时间。请求过程如下： 浏览器请求静态资源demo.js 服务器读取磁盘文件demo.js，返给浏览器，同时带上文件上次修改时间 Last-Modified（GMT标准格式） 当浏览器上的缓存文件过期时，浏览器带上请求头If-Modified-Since（等于上一次请求的Last-Modified）请求服务器 服务器比较请求头里的If-Modified-Since和文件的上次修改时间。如果果一致就继续使用本地缓存（304），如果不一致就再次返回文件内容和Last-Modified。 循环请求。。 代码实现过程如下： 12345678910111213141516app.get(&#x27;/demo.js&#x27;,(req, res)=&gt;&#123; let jsPath = path.resolve(__dirname,&#x27;./static/js/demo.js&#x27;) let cont = fs.readFileSync(jsPath); let status = fs.statSync(jsPath) let lastModified = status.mtime.toUTCString() if(lastModified === req.headers[&#x27;if-modified-since&#x27;])&#123; res.writeHead(304, &#x27;Not Modified&#x27;) res.end() &#125; else &#123; res.setHeader(&#x27;Cache-Control&#x27;, &#x27;public,max-age=5&#x27;) res.setHeader(&#x27;Last-Modified&#x27;, lastModified) res.writeHead(200, &#x27;OK&#x27;) res.end(cont) &#125;&#125;) 我们多次刷新页面，可以看到请求结果如下： 虽然这个方案比前面三个方案有了进一步的优化，浏览器检测文件是否有修改，如果没有变化就不再发送文件；但是还是有以下缺点： 由于Last-Modified修改时间是GMT时间，只能精确到秒，如果文件在1秒内有多次改动，服务器并不知道文件有改动，浏览器拿不到最新的文件 如果服务器上文件被多次修改了但是内容却没有发生改变，服务器需要再次重新返回文件。 ETag 为了解决文件修改时间不精确带来的问题，服务器和浏览器再次协商，这次不返回时间，返回文件的唯一标识ETag。只有当文件内容改变时，ETag才改变。请求过程如下： 浏览器请求静态资源demo.js 服务器读取磁盘文件demo.js，返给浏览器，同时带上文件的唯一标识ETag 当浏览器上的缓存文件过期时，浏览器带上请求头If-None-Match（等于上一次请求的ETag）请求服务器 服务器比较请求头里的If-None-Match和文件的ETag。如果一致就继续使用本地缓存（304），如果不一致就再次返回文件内容和ETag。 循环请求。。 12345678910111213141516const md5 = require(&#x27;md5&#x27;);app.get(&#x27;/demo.js&#x27;,(req, res)=&gt;&#123; let jsPath = path.resolve(__dirname,&#x27;./static/js/demo.js&#x27;); let cont = fs.readFileSync(jsPath); let etag = md5(cont); if(req.headers[&#x27;if-none-match&#x27;] === etag)&#123; res.writeHead(304, &#x27;Not Modified&#x27;); res.end(); &#125; else &#123; res.setHeader(&#x27;ETag&#x27;, etag); res.writeHead(200, &#x27;OK&#x27;); res.end(cont); &#125;&#125;) 请求结果如下： 一些额外的东西 在报文头的表格中我们可以看到有一个字段叫Pragma，这是一段尘封的历史…. 在“遥远的”http1.0时代，给客户端设定缓存方式可通过两个字段–Pragma和Expires。虽然这两个字段早可抛弃，但为了做http协议的向下兼容，你还是可以看到很多网站依旧会带上这两个字段。 关于Pragma 当该字段值为no-cache的时候，会告诉浏览器不要对该资源缓存，即每次都得向服务器发一次请求才行。 12res.setHeader(&#x27;Pragma&#x27;, &#x27;no-cache&#x27;) //禁止缓存res.setHeader(&#x27;Cache-Control&#x27;, &#x27;public,max-age=120&#x27;) //2分钟 通过Pragma来禁止缓存，通过Cache-Control设置两分钟缓存，但是重新访问我们会发现浏览器会再次发起一次请求，说明了Pragma的优先级高于Cache-Control 关于Cache-Control 我们看到Cache-Control中有一个属性是public，那么这代表了什么意思呢？其实Cache-Control不光有max-age，它常见的取值private、public、no-cache、max-age，no-store，默认值为private，各个取值的含义如下： private: 客户端可以缓存 public: 客户端和代理服务器都可缓存 max-age=xxx: 缓存的内容将在 xxx 秒后失效 no-cache: 需要使用对比缓存来验证缓存数据 no-store: 所有内容都不会缓存，强制缓存，对比缓存都不会触发 所以我们在刷新页面的时候，如果只按F5只是单纯的发送请求，按Ctrl+F5会发现请求头上多了两个字段Pragma: no-cache和Cache-Control: no-cache。 缓存的优先级 上面我们说过强制缓存的优先级高于协商缓存，Pragma的优先级高于Cache-Control，那么其他缓存的优先级顺序怎么样呢？网上查阅了资料得出以下顺序（PS：有兴趣的童鞋可以验证一下正确性告诉我）： Pragma &gt; Cache-Control &gt; Expires &gt; ETag &gt; Last-Modified 参考资料： http缓存优先级问题彻底弄懂HTTP缓存机制及原理HTTP缓存控制小结浅谈浏览器http的缓存机制通过express框架简单实践几种设置HTTP对缓存的控制","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"浏览器","slug":"Browser","permalink":"http://xieyufei.com/tags/Browser/"}]},{"title":"JS中浮点数精度问题","date":"2018-03-07T12:48:47.000Z","path":"2018/03/07/JS-Decimal-Accuracy.html","text":"最近在做项目的时候，涉及到商品价格的计算，经常会出现计算出现精度问题。刚开始草草了事，直接用toFixed就解决了问题，并没有好好的思考一下这个问题。后来慢慢的，问题越来越多，连toFixed也出现了（允悲），后来经过搜索网上的各种博客和论坛，整理总结了一下。 问题的发现 总结了一下，一共有以下两种问题 浮点数运算后的精度问题 在计算商品价格加减乘除时，偶尔会出现精度问题，一些常见的例子如下： 1234567891011121314151617// 加法 =====================0.1 + 0.2 = 0.300000000000000040.7 + 0.1 = 0.79999999999999990.2 + 0.4 = 0.6000000000000001// 减法 =====================1.5 - 1.2 = 0.300000000000000040.3 - 0.2 = 0.09999999999999998 // 乘法 =====================19.9 * 100 = 1989.99999999999980.8 * 3 = 2.400000000000000435.41 * 100 = 3540.9999999999995// 除法 =====================0.3 / 0.1 = 2.99999999999999960.69 / 10 = 0.06899999999999999 toFixed奇葩问题 在遇到浮点数运算后出现的精度问题时，刚开始我是使用toFixed(2)来解决的，因为在W3school和菜鸟教程（他们均表示这锅不背）上明确写着定义：toFixed()方法可把Number四舍五入为指定小数位数的数字。 但是在chrome下测试结果不太令人满意： 1234561.35.toFixed(1) // 1.4 正确1.335.toFixed(2) // 1.33 错误1.3335.toFixed(3) // 1.333 错误1.33335.toFixed(4) // 1.3334 正确1.333335.toFixed(5) // 1.33333 错误1.3333335.toFixed(6) // 1.333333 错误 使用IETester在IE下面测试的结果却是正确的。 为什么会产生 让我们来看一下为什么0.1+0.2会等于0.30000000000000004，而不是0.3。首先，想要知道为什么会产生这样的问题，让我们回到大学里学的复（ku）杂（zao）的计算机组成原理。虽然已经全部还给大学老师了，但是没关系，我们还有百度嘛。 浮点数的存储 和其它语言如Java和Python不同，JavaScript中所有数字包括整数和小数都只有一种类型 — Number。它的实现遵循 IEEE 754 标准，使用64位固定长度来表示，也就是标准的 double 双精度浮点数（相关的还有float 32位单精度）。 这样的存储结构优点是可以归一化处理整数和小数，节省存储空间。 64位比特又可分为三个部分： 符号位S：第 1 位是正负数符号位（sign），0代表正数，1代表负数 指数位E：中间的 11 位存储指数（exponent），用来表示次方数 尾数位M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零 浮点数的运算 那么JavaScript在计算0.1+0.2时到底发生了什么呢？ 首先，十进制的0.1和0.2会被转换成二进制的，但是由于浮点数用二进制表示时是无穷的： 120.1 -&gt; 0.0001 1001 1001 1001...(1100循环)0.2 -&gt; 0.0011 0011 0011 0011...(0011循环) IEEE 754 标准的 64 位双精度浮点数的小数部分最多支持53位二进制位，所以两者相加之后得到二进制为： 10.0100110011001100110011001100110011001100110011001100 因浮点数小数位的限制而截断的二进制数字，再转换为十进制，就成了0.30000000000000004。所以在进行算术计算时会产生误差。 解决方法 针对以上两个问题，网上搜了一波解决方法，基本都大同小异的，分别来看一下。 解决toFixed 针对toFixed的兼容性问题，我们可以把toFix重写一下来解决，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// toFixed兼容方法Number.prototype.toFixed = function(len)&#123; if(len&gt;20 || len&lt;0)&#123; throw new RangeError(&#x27;toFixed() digits argument must be between 0 and 20&#x27;); &#125; // .123转为0.123 var number = Number(this); if (isNaN(number) || number &gt;= Math.pow(10, 21)) &#123; return number.toString(); &#125; if (typeof (len) == &#x27;undefined&#x27; || len == 0) &#123; return (Math.round(number)).toString(); &#125; var result = number.toString(), numberArr = result.split(&#x27;.&#x27;); if(numberArr.length&lt;2)&#123; //整数的情况 return padNum(result); &#125; var intNum = numberArr[0], //整数部分 deciNum = numberArr[1],//小数部分 lastNum = deciNum.substr(len, 1);//最后一个数字 if(deciNum.length == len)&#123; //需要截取的长度等于当前长度 return result; &#125; if(deciNum.length &lt; len)&#123; //需要截取的长度大于当前长度 1.3.toFixed(2) return padNum(result) &#125; //需要截取的长度小于当前长度，需要判断最后一位数字 result = intNum + &#x27;.&#x27; + deciNum.substr(0, len); if(parseInt(lastNum, 10)&gt;=5)&#123; //最后一位数字大于5，要进位 var times = Math.pow(10, len); //需要放大的倍数 var changedInt = Number(result.replace(&#x27;.&#x27;,&#x27;&#x27;));//截取后转为整数 changedInt++;//整数进位 changedInt /= times;//整数转为小数，注：有可能还是整数 result = padNum(changedInt+&#x27;&#x27;); &#125; return result; //对数字末尾加0 function padNum(num)&#123; var dotPos = num.indexOf(&#x27;.&#x27;); if(dotPos === -1)&#123; //整数的情况 num += &#x27;.&#x27;; for(var i = 0;i&lt;len;i++)&#123; num += &#x27;0&#x27;; &#125; return num; &#125; else &#123; //小数的情况 var need = len - (num.length - dotPos - 1); for(var j = 0;j&lt;need;j++)&#123; num += &#x27;0&#x27;; &#125; return num; &#125; &#125;&#125; 我们通过判断最后一位是否大于等于5来决定需不需要进位，如果需要进位先把小数乘以倍数变为整数，加1之后，再除以倍数变为小数，这样就不用一位一位的进行判断。 解决浮点数运算精度 既然我们发现了浮点数的这个问题，又不能直接让两个浮点数运算，那怎么处理呢？ 我们可以把需要计算的数字升级（乘以10的n次幂）成计算机能够精确识别的整数，等计算完成后再进行降级（除以10的n次幂），这是大部分变成语言处理精度问题常用的方法。例如： 120.1 + 0.2 == 0.3 //false(0.1*10 + 0.2*10)/10 == 0.3 //true 但是这样就能完美解决么？细心的读者可能在上面的例子里已经发现了问题： 135.41 * 100 = 3540.9999999999995 看来进行数字升级也不是完全的可靠啊（允悲）。 但是魔高一尺道高一丈，这样就能难住我们么，我们可以将浮点数toString后indexOf(‘.’)，记录一下小数位的长度，然后将小数点抹掉，完整的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106 /*** method ** * add / subtract / multiply /divide * floatObj.add(0.1, 0.2) &gt;&gt; 0.3 * floatObj.multiply(19.9, 100) &gt;&gt; 1990 * */var floatObj = function() &#123; /* * 判断obj是否为一个整数 */ function isInteger(obj) &#123; return Math.floor(obj) === obj &#125; /* * 将一个浮点数转成整数，返回整数和倍数。如 3.14 &gt;&gt; 314，倍数是 100 * @param floatNum &#123;number&#125; 小数 * @return &#123;object&#125; * &#123;times:100, num: 314&#125; */ function toInteger(floatNum) &#123; var ret = &#123;times: 1, num: 0&#125; if (isInteger(floatNum)) &#123; ret.num = floatNum return ret &#125; var strfi = floatNum + &#x27;&#x27; var dotPos = strfi.indexOf(&#x27;.&#x27;) var len = strfi.substr(dotPos+1).length var times = Math.pow(10, len) var intNum = Number(floatNum.toString().replace(&#x27;.&#x27;,&#x27;&#x27;)) ret.times = times ret.num = intNum return ret &#125; /* * 核心方法，实现加减乘除运算，确保不丢失精度 * 思路：把小数放大为整数（乘），进行算术运算，再缩小为小数（除） * * @param a &#123;number&#125; 运算数1 * @param b &#123;number&#125; 运算数2 * @param digits &#123;number&#125; 精度，保留的小数点数，比如 2, 即保留为两位小数 * @param op &#123;string&#125; 运算类型，有加减乘除（add/subtract/multiply/divide） * */ function operation(a, b, digits, op) &#123; var o1 = toInteger(a) var o2 = toInteger(b) var n1 = o1.num var n2 = o2.num var t1 = o1.times var t2 = o2.times var max = t1 &gt; t2 ? t1 : t2 var result = null switch (op) &#123; case &#x27;add&#x27;: if (t1 === t2) &#123; // 两个小数位数相同 result = n1 + n2 &#125; else if (t1 &gt; t2) &#123; // o1 小数位 大于 o2 result = n1 + n2 * (t1 / t2) &#125; else &#123; // o1 小数位 小于 o2 result = n1 * (t2 / t1) + n2 &#125; return result / max case &#x27;subtract&#x27;: if (t1 === t2) &#123; result = n1 - n2 &#125; else if (t1 &gt; t2) &#123; result = n1 - n2 * (t1 / t2) &#125; else &#123; result = n1 * (t2 / t1) - n2 &#125; return result / max case &#x27;multiply&#x27;: result = (n1 * n2) / (t1 * t2) return result case &#x27;divide&#x27;: result = (n1 / n2) * (t2 / t1) return result &#125; &#125; // 加减乘除的四个接口 function add(a, b, digits) &#123; return operation(a, b, digits, &#x27;add&#x27;) &#125; function subtract(a, b, digits) &#123; return operation(a, b, digits, &#x27;subtract&#x27;) &#125; function multiply(a, b, digits) &#123; return operation(a, b, digits, &#x27;multiply&#x27;) &#125; function divide(a, b, digits) &#123; return operation(a, b, digits, &#x27;divide&#x27;) &#125; // exports return &#123; add: add, subtract: subtract, multiply: multiply, divide: divide &#125;&#125;(); 如果觉得floatObj调用麻烦，我们可以在Number.prototype上添加对应的运算方法。 参考链接： 关于js浮点数计算精度不准确问题的解决办法 js中toFixed精度问题的解决办法 JavaScript 浮点数陷阱及解法","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"js","slug":"js","permalink":"http://xieyufei.com/tags/js/"}]},{"title":"JS时间处理插件MomentJS","date":"2017-12-06T12:48:47.000Z","path":"2017/12/06/JS-Moment.html","text":"笔者在做项目的时候，需要对日期和时间进行一些处理和操作，但是每次都用JS自带的Date对象很不方便，还要写一堆繁琐的代码，后续维护起来也很痛苦。在网上找了一下JS处理日期和时间的插件，发现了MomentJS很好用，学习了一下它的语法，发现十分的简洁易懂，而且可扩展性很强，调用方法灵活。很多的方法调用形式多样，支持多种传参数方式。下面简单的整理了一下使用方式 构造Moment对象 MomentJS将时间封装成一个对象，moment对象，这个对象很多种构造方式，可以支持传入字符串、数组和对象的形式来构造。 当前系统时间 如果什么都不传，就获取当前的系统时间。 1var now = moment() 字符串构造 可以传入字符串，首先会检查字符串的格式是否符合ISO 8601的格式，如果不符合，就调用new Date(string)来构造。 已知格式字符串12345moment(&#x27;2017-01-02&#x27;); //年月日moment(&#x27;2017-01-02 13&#x27;); //年月日 小时moment(&#x27;2017-01-02 13:12&#x27;); //年月日 小时分钟moment(&#x27;2017-01-02 13:12:52&#x27;); //年月日 小时分钟秒moment(&#x27;2017-01-02 13:12:52.123&#x27;); //年月日 小时分钟秒 毫秒 字符串+格式 假如日期的格式不符合ISO 8601的格式，但是你知道输入的字符串的格式，也可以通过这种方式解析，解析的语法有以下四种格式： 1234moment(String, String);moment(String, String, String);moment(String, String, Boolean);moment(String, String, String, Boolean); 第一种已知某个时间的格式，将格式作为第二个参数传入 1moment(&#x27;12-25-1995 12/43/53&#x27;, &#x27;MM-DD-YYYY HH/mm/ss&#x27;) 格式字母代表的含义如下表 Input Example Description YYYY 2014 4位数年份 YY 14 2位数年份 Q 1..4 季度，将月份设置成季度的第一个月 M MM 1..12 月份 MMM MMMM Jan..December 月份名称 D DD 1..31 一个月的第几天 DDD DDDD 1..365 一年的第几天 H HH 0..23 24小时制 h hh 1..12 12小时制 m mm 0..59 分钟 s ss 0..59 秒 第二种，可以将当地区域的关键符作为第三个参数传入。 12moment(&#x27;2012 juillet&#x27;, &#x27;YYYY MMM&#x27;, &#x27;fr&#x27;);moment(&#x27;2012 July&#x27;, &#x27;YYYY MMM&#x27;, &#x27;en&#x27;); MomentJS的匹配模式是十分宽松的，并且可能会导致一些我们不想要的行为。从2.3.0版本开始，我们可以在最后传入一个布尔值来让Moment使用严格模式匹配。严格模式要求输入的字符串和格式要完全相同。 123moment(&#x27;It is 2012-05-25&#x27;, &#x27;YYYY-MM-DD&#x27;).isValid(); // truemoment(&#x27;It is 2012-05-25&#x27;, &#x27;YYYY-MM-DD&#x27;, true).isValid(); // falsemoment(&#x27;2012-05-25&#x27;, &#x27;YYYY-MM-DD&#x27;, true).isValid(); // true 字符串+多格式 假如你不知道输入的字符串确切是用的哪种格式，但是知道是某些格式中的一种，可以将多种格式用数组的形式传入，将会以最先匹配到的格式为输出结果。 1moment(&quot;12-25-1995&quot;, [&quot;MM-DD-YYYY&quot;, &quot;YYYY-MM-DD&quot;]); 对象 我们也可以通过传入一个对象的形式来创建moment对象，传入的对象中包括一些时间单位的属性。 1234moment(&#123; y :2010, M :3, d :5, h :15, m :10, s :3, ms :123&#125;);moment(&#123; year :2010, month :3, day :5, hour :15, minute :10, second :3, millisecond :123&#125;);moment(&#123; years:2010, months:3, days:5, hours:15, minutes:10, seconds:3, milliseconds:123&#125;);moment(&#123; years:2010, months:3, date:5, hours:15, minutes:10, seconds:3, milliseconds:123&#125;); 上面代码中的day和date都表示当前月的第几天。 Date 对象 我们也可以传入JS原生的Date对象来创建moment对象。 12var day = new Date(2011, 9, 16);var dayWrapper = moment(day); 数组 我们可以传入一个数字的数组来创建moment对象，数组中每个每个数字代表的含义如下： 123// [年, 月, 日, 时, 分, 秒, 毫秒]moment([2010, 1, 14, 15, 25, 50, 125]);//2010年2月14日15时25分50秒125毫秒 需要注意的是：数组中的月、时、分、秒、毫秒都是从0开始的，而年和日都是从1开始的。 取值and赋值 MomentJS使用可以重载的get和set方法，跟我们以前在jQuery中的形式很相似。我们可以调用这些方法不传参数作来获取，传入参数作来设置。 自带函数获取或者设置毫秒，设置的范围0到999 1234moment().millisecond(Number);moment().millisecond(); // Numbermoment().milliseconds(Number);moment().milliseconds(); // Number 获取或者设置秒，设置的范围0到59 1234moment().second(Number);moment().second(); // Numbermoment().seconds(Number);moment().seconds(); // Number 获取或者设置分钟，设置的范围0到59 1234moment().minute(Number);moment().minute(); // Numbermoment().minutes(Number);moment().minutes(); // Number 获取或者设置小时，设置的范围0到23 1234moment().hour(Number);moment().hour(); // Numbermoment().hours(Number);moment().hours(); // Number 获取或者设置日期，设置的范围1到31 1234moment().date(Number);moment().date(); // Numbermoment().dates(Number);moment().dates(); // Number 获取或者设置星期，设置的范围0（周日）到6（周六） 1234moment().day(Number|String);moment().day(); // Numbermoment().days(Number|String);moment().days(); // Number 获取或者设置一年中的天数，设置的范围1到366 12moment().dayOfYear(Number);moment().dayOfYear(); // Number 获取或者设置一年中的周 1234moment().week(Number);moment().week(); // Numbermoment().weeks(Number);moment().weeks(); // Number 获取或者设置一年中的月份，设置的范围0到11 1234moment().month(Number|String);moment().month(); // Numbermoment().months(Number|String);moment().months(); // Number 获取或者设置季度，设置的范围1到4 12moment().quarter(); // Numbermoment().quarter(Number); 获取或者设置年，设置的范围-270000到270000 1234moment().year(Number);moment().year(); // Numbermoment().years(Number);moment().years(); // Number 取值and赋值函数 除了上面的这么多函数外，MomentJS还有一个用来统一取值和赋值的函数，get和set。 1234567moment().get(&#x27;year&#x27;);moment().get(&#x27;month&#x27;); // 0 to 11moment().get(&#x27;date&#x27;);moment().get(&#x27;hour&#x27;);moment().get(&#x27;minute&#x27;);moment().get(&#x27;second&#x27;);moment().get(&#x27;millisecond&#x27;); set函数接收单位作为第一个参数，单位的值作为第二个参数。如果要设置多个值的话，也可以通过传入一个对象。 123456789moment().set(&#x27;year&#x27;, 2013);moment().set(&#x27;month&#x27;, 3); //四月moment().set(&#x27;date&#x27;, 1);moment().set(&#x27;hour&#x27;, 13);moment().set(&#x27;minute&#x27;, 20);moment().set(&#x27;second&#x27;, 30);moment().set(&#x27;millisecond&#x27;, 123);moment().set(&#123;&#x27;year&#x27;: 2013, &#x27;month&#x27;: 3&#125;); max/min函数 max函数可以返回给定的moment对象中最大的实例，也就是最靠近未来的实例。 123var a = moment(&#x27;2017-12-01&#x27;);var b = moment(&#x27;2017-12-06&#x27;);moment.max(a, b); // b min函数可以返回给定的moment对象中最小的实例，也就是最靠近过去的实例。 123var a = moment(&#x27;2017-12-01&#x27;);var b = moment(&#x27;2017-12-06&#x27;);moment.min(a, b); // a 操作 有时候，我们需要对时间进行一系列的操作，最常见的就是加减计算。MomentJS提供了很多方法给我们来进行调用。 MomentJS使用的模式跟jQuery相似，都是使用的函数的链式调用，可以让我们将操作链式执行下去，代码如下所示： 1234567moment() .add(7, &#x27;days&#x27;) .subtract(1, &#x27;months&#x27;) .year(2009) .hours(0) .minutes(0) .seconds(0); add加法 add函数让我们把Moment对象的时间往后退，它的语法如下： 123moment().add(Number, String);moment().add(Duration);moment().add(Object); 我们可以传入想要的增加的时间数量和时间单位，比如要往后推迟7天： 1moment().add(7, &#x27;days&#x27;); 当然，add函数也允许我们提供时间单位的缩写： 1moment().add(7, &#x27;d&#x27;); 时间单位 缩写 years y quarters Q months M weeks W days d hours h minutes m seconds s milliseconds ms 如果想要同时增加不同时间单位，可以以对象的形式传入： 12moment().add(7, &#x27;days&#x27;).add(1, &#x27;months&#x27;);moment().add(&#123;days:7,months:1&#125;); 需要注意的是，如果原始日期的天数比新增后的日期的月份的总天数还要多，就变为该月的最后一天： 123456// 01-31moment([2010, 0, 31]); // 02-28 moment([2010, 0, 31]).add(1, &#x27;months&#x27;); //2月份没有31号，自动变为最后一天，即28号 subtract减法 subtract函数的用法和add相似，不同的是把时间往前推。 123moment().subtract(Number, String);moment().subtract(Duration);moment().subtract(Object); startOf开始时间 startOf函数将Moment对象的时间设置为传入单位的开始时间。 12345678910moment() //当前时间2017-12-09moment().startOf(&#x27;year&#x27;); //今年年初2017-01-01moment().startOf(&#x27;month&#x27;); //这个月开始2017-12-01moment().startOf(&#x27;quarter&#x27;);//这个季度开始2017-10-01moment().startOf(&#x27;week&#x27;); //这周开始2017-12-03（周日为开始）moment().startOf(&#x27;isoWeek&#x27;);//这周开始2017-12-04（根据ISO 8601，周一为开始）moment().startOf(&#x27;day&#x27;); //今天的开始时间2017-12-09 00:00:00:000moment().startOf(&#x27;hour&#x27;); //今天当前小时开始2017-12-09 13:00:00:000moment().startOf(&#x27;minute&#x27;); //今天当前分钟开始2017-12-09 13:14:00:000moment().startOf(&#x27;second&#x27;); //今天当前秒钟开始2017-12-09 13:14:15:000 endOf结束时间 endOf函数将Moment对象的时间设置为传入单位的结束时间。使用方式和startOf相似。 1moment().endOf(String); 显示 当我们解析和操作完Moment对象后，我们就需要对最后的结果进行展示。 format格式化 format函数接收token字符串，并且将token替换成对应的值。 123moment().format(); // &quot;2014-09-08T08:02:17-05:00&quot; (ISO 8601)moment().format(&quot;dddd, MMMM Do YYYY, h:mm:ss a&quot;); // &quot;Sunday, February 14th 2010, 3:25:50 pm&quot;moment().format(&quot;ddd, hA&quot;); // &quot;Sun, 3PM&quot; 对应的关系如下表： - Token 输入 月 M 1 2 .. 11 12 Mo 1st 2nd … 11th 12th MM 01 02 … 11 12 MMM Jan Feb … Nov Dec MMMM January February … November December 季度 Q 1 2 3 4 月份中的天 D 1 2 … 30 31 Do 1st 2nd … 30th 31st DD 01 02 … 30 31 年份中的天 DDD 1 2 … 365 366 DDDo st 2nd … 365th 366th DDDD 001 002 … 365 366 星期中的天 d 0 1 … 5 6 do 0th 1st … 5th 6th dd Su Mo … Fr Sa ddd Sun Mon … Fri Sat dddd Sunday Monday … Friday Saturday 年中的星期 w 1 2 … 52 53 wo 1st 2nd … 52nd 53rd ww 01 02 … 52 53 年 YY 70 71 … 29 30 YYYY 1970 1971 … 2029 2030 AM/PM A AM PM a am pm 小时 H 0 1 … 22 23 HH 00 01 … 22 23 h 1 2 … 11 12 hh 01 02 … 11 12 分钟 m 0 1 … 58 59 mm 00 01 … 58 59 秒 s 0 1 … 58 59 ss 00 01 … 58 59 毫秒 ms 000 001 … 998 999 diff时差 语法 123moment().diff(Moment|String|Number|Date|Array);moment().diff(Moment|String|Number|Date|Array, String);moment().diff(Moment|String|Number|Date|Array, String, Boolean); diff函数可以帮我们获取到两个Moment对象的时间差，默认的单位是毫秒。 123var a = moment([2017, 12, 29]);var b = moment([2017, 12, 28]);a.diff(b) // 86400000 除了得到毫秒为单位，diff函数还支持获取其他的时间单位，将其作为第二个参数传入： 123var a = moment([2007, 0, 29]);var b = moment([2007, 0, 28]);a.diff(b, &#x27;days&#x27;) // 1 支持的测量单位有years、months、weeks、days、hours、minutes、seconds和milliseconds。默认返回的数值会向下取舍，去掉小数。假如想要精确一点，得到小数类型的数值，第三个参数传入一个true。 1234var a = moment([2008, 6]);var b = moment([2007, 0]);a.diff(b, &#x27;years&#x27;); // 1a.diff(b, &#x27;years&#x27;, true); // 1.5 daysInMonth获取当前月份的天数 daysInMonth获取当前月的总天数 12moment(&quot;2012-02&quot;, &quot;YYYY-MM&quot;).daysInMonth() // 29moment(&quot;2012-01&quot;, &quot;YYYY-MM&quot;).daysInMonth() // 31 toDate转为Date对象 将Moment对象转为js原生的Date对象 toArray转为数组 返回时间数组，和构造Moment对象时传入的数组代表的含义相同。 1moment().toArray(); // [2017, 12, 9, 13, 40, 16, 154]; toObject 将Moment对象转为包含年月日时分秒毫秒的对象。 123456789moment().toObject() // &#123; // years: 2017 // months: 12 // date: 9, // hours: 13, // minutes: 40, // seconds: 18, // milliseconds: 600 // &#125; 查询 查询操作主要用来判断Moment是否满足某些条件。 isBefore是否之前12moment().isBefore(Moment|String|Number|Date|Array);moment().isBefore(Moment|String|Number|Date|Array, String); isBefore判断一个moment对象是否在某个时间点之前。 1moment(&#x27;2010-10-20&#x27;).isBefore(&#x27;2010-10-21&#x27;); // true 默认的比较单位是毫秒，但是假如我们想要限制到其他的时间单位，我们可以将其作为第二个参数传入。接受的单位和startOf支持的单位一样。 123console.log(moment(&#x27;2017-11-03&#x27;).isBefore(&#x27;2017-11-06&#x27;))console.log(moment(&#x27;2017-11-03&#x27;).isBefore(&#x27;2017-11-06&#x27;, &#x27;year&#x27;))console.log(moment(&#x27;2017-11-03&#x27;).isBefore(&#x27;2018-11-06&#x27;, &#x27;year&#x27;)) isSame是否相同12moment().isSame(Moment|String|Number|Date|Array);moment().isSame(Moment|String|Number|Date|Array, String); isSame判断一个moment对象是否和另一个moment对象相同。 12moment(&#x27;2010-10-20&#x27;).isSame(&#x27;2010-10-20&#x27;); // truemoment(&#x27;2010-10-20&#x27;).isSame(&#x27;2010-10-21&#x27;); // false 同样的，我们如果要将比较的单位改为其他的，也可以作为第二个参数传入。接受的单位和startOf支持的单位一样。 12moment(&#x27;2010-10-20&#x27;).isSame(&#x27;2009-12-31&#x27;, &#x27;year&#x27;); // falsemoment(&#x27;2010-10-20&#x27;).isSame(&#x27;2010-01-01&#x27;, &#x27;year&#x27;); // true 当传入第二个参数时，它会匹配所有相同或者更大的单位。比如传入了月份，将会比较年和月，传入了日期，将会比较年月日 12345// false, 不同的年moment(&#x27;2010-01-01&#x27;).isSame(&#x27;2011-01-01&#x27;, &#x27;month&#x27;);// false, 不同的月moment(&#x27;2010-01-01&#x27;).isSame(&#x27;2010-02-01&#x27;, &#x27;day&#x27;); isAfter是否之后 isBefore判断一个moment对象是否在某个时间点之后。接受的单位和startOf支持的单位一样。 1moment(&#x27;2010-10-20&#x27;).isAfter(&#x27;2010-10-19&#x27;); // true isBetween是否之间123moment().isBetween(moment-like, moment-like);moment().isBetween(moment-like, moment-like, String);//moment-like 表示 Moment|String|Number|Date|Array 判断一个moment对象是否在两个其他时间点之间。 1moment(&#x27;2017-10-20&#x27;).isBetween(&#x27;2017-10-19&#x27;, &#x27;2017-10-25&#x27;); // true 传入第二个参数作为限制的单位。接受的单位和startOf支持的单位一样。 12moment(&#x27;2010-10-20&#x27;).isBetween(&#x27;2010-01-01&#x27;, &#x27;2012-01-01&#x27;, &#x27;year&#x27;); // falsemoment(&#x27;2010-10-20&#x27;).isBetween(&#x27;2009-12-31&#x27;, &#x27;2012-01-01&#x27;, &#x27;year&#x27;); // true isLeapYear是否闰年 是闰年就返回true，不是就返回false。 123moment([2000]).isLeapYear() // truemoment([2001]).isLeapYear() // falsemoment([2100]).isLeapYear() // false isMoment 是否Moment对象 判断是否Moment对象 123moment.isMoment() // falsemoment.isMoment(new Date()) // falsemoment.isMoment(moment()) // true isDate是否Date对象 判断是否Date对象 123moment.isDate(); // falsemoment.isDate(new Date()); // truemoment.isDate(moment()); // false","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"js","slug":"js","permalink":"http://xieyufei.com/tags/js/"}]},{"title":"Nodejs文件上传","date":"2017-09-25T07:17:49.000Z","path":"2017/09/25/Nodejs-File-Upload.html","text":"笔者用nodejs做项目时需要用到文件上传的功能，在网上搜索了很多教程，找到了一个express的中间件，用于处理multipart/form-data类型的表单数据，可以很方便的将表单中的文件数据保存到服务器。 介绍 multer是一个node.js文件上传中间件，它是在 busboy的基础上开发的，上传的表单数据必须是multipart/form-data类型，不然会报错。 简单的用法定义存储器 Multer作为express的一个中间件，我们可以很方便的自定义上传的文件目录以及保存的文件名。先看一个最简单的用法，demo1地址： 1234567891011121314151617var express = require(&#x27;express&#x27;);var multer = require(&#x27;multer&#x27;);var app = express();var upload = multer(&#123; storage: multer.diskStorage(&#123; destination: function (req, file, cb) &#123; cb(null, &#x27;./uploads/&#x27;); &#125;, filename: function (req, file, cb) &#123; //file.originalname上传文件的原始文件名 var changedName = (new Date().getTime())+&#x27;-&#x27;+file.originalname; cb(null, changedName); &#125; &#125;)&#125;); 我们先创建了一个upload对象，这个对象中destination函数用来定义上传文件的存储的文件夹；filename函数用来修改上传文件存储到服务器的文件名称，这里我们我们加上一个时间戳简单区分一下。这两个函数都是通过回调函数来实现的。每次上传的时候这两个函数都会调用一次，如果是多个文件上传，那个这两个函数就调用多次，调用顺序是先调用destination，然后调用filename。 在两个函数中都会有一个file对象，表示当前上传的文件对象，有以下几个属性： fieldname：上传的字段名 originalname：上传的文件名 encoding：文件的编码类型 mimetype：文件的MIME类型 附：一些常用的MIME类型 定义路由回调12345678910111213141516171819202122232425//单个文件上传app.post(&#x27;/upload/single&#x27;,upload.single(&#x27;singleFile&#x27;),(req,res)=&gt;&#123; console.log(req.file); res.json(&#123; code: &#x27;0000&#x27;, type:&#x27;single&#x27;, originalname: req.file.originalname &#125;)&#125;);//多个文件上传app.post(&#x27;/upload/multer&#x27;,upload.array(&#x27;multerFile&#x27;),(req,res)=&gt;&#123; console.log(req.files); let fileList = []; req.files.map((elem)=&gt;&#123; fileList.push(&#123; originalname: elem.originalname &#125;) &#125;); res.json(&#123; code: &#x27;0000&#x27;, type:&#x27;multer&#x27;, fileList:fileList &#125;);&#125;); 在express中定义路由的回调函数时，把定义好了的upload对象作为中间件添加进去。如果是单个文件就用single方法，如果是多个文件就用array方法，这两个方法都需要传一个页面上定义好的字段名。 在路由的回调函数中，request对象已经有了file属性（单个文件上传）或files属性（多个文件上传），files属性是一个数组，数组的每一个对象都有以下属性： fieldname：上传的字段名 originalname：上传的文件名 encoding：文件的编码类型 mimetype：文件的MIME类型 destination：存储的目录（和destination回调函数中的目录名一致） filename：保存的文件名（和filename回调函数中的文件名一致） path：保存的相对路径 size：文件的大小（单位：字节byte） 我们可以发现在路由的回调函数中的file对象比diskStorage中的file对象多了几个属性，这是因为在diskStorage中文件还没有保存，只能知道文件的大致属性；而路由的回调函数文件已经在服务器上保存好了，文件的保存路径以及文件的大小都是已知的。 混合上传 有时候我们可能需要用字段名来对上传的文件进行一下划分，比如说上传多个图片的时候可能有身份证还有头像。虽然可以分开放到两个接口中，但是会产生其他一系列的麻烦事。multer支持对图片进行字段名的划分。demo3地址 1234567891011121314151617181920212223242526272829303132333435//多字段名上传let multipleFields = upload.fields([ &#123;name:&#x27;avatar&#x27;&#125;, &#123;name:&#x27;gallery&#x27;, maxCount:3&#125;,]);app.post(&#x27;/upload/fields&#x27;, (req,res)=&gt;&#123; multipleFields(req,res,(err) =&gt; &#123; console.log(req.files); if(!!err)&#123; console.log(err.message); res.json(&#123; code: &#x27;2000&#x27;, type: &#x27;field&#x27;, msg:err.message &#125;) return; &#125; var fileList = []; for(let item in req.files)&#123; var fieldItem = req.files[item]; fieldItem.map((elem) =&gt; &#123; fileList.push(&#123; fieldname: elem.fieldname, originalname: elem.originalname &#125;) &#125;); &#125; res.json(&#123; code: &#x27;0000&#x27;, type: &#x27;field&#x27;, fileList: fileList, msg:&#x27;&#x27; &#125;) &#125;);&#125;); 在这边也有req.files属性，但是这个属性并不是一个数组，而是一个复杂的对象，这个对象中有多个属性，每个属性名都是一个字段名，每个属性下面又是一个数组，数组下面才是一个个的文件对象，结构大致如下： 123456789101112&#123; &quot;avatar&quot;:[&#123; fieldname: &quot;&quot;, originalname: &quot;&quot; //... &#125;], &quot;gallery&quot;:[&#123; fieldname: &quot;&quot;, originalname: &quot;&quot; //... &#125;]&#125; 过滤文件上传 在文件上传时，有时候会上传一些我们不需要的文件类型，我们需要把一些不需要的文件给过滤掉。demo2地址。 文件类型过滤12345678910var upload = multer(&#123; //...其他代码 fileFilter: function(req, file, cb)&#123; if(file.mimetype == &#x27;image/png&#x27;)&#123; cb(null, true) &#125; else &#123; cb(null, false) &#125; &#125;&#125;); 在定义存储器的时候，新增一个fileFilter函数，用来过滤掉我们不需要的文件，在回调函数中我们传入true/false来代表是否要保存；如果传了false，那么destination函数和filename函数也不会调用了。 文件大小和数量过滤123456789var upload = multer(&#123; //...其他代码 limits:&#123; //限制文件大小10kb fileSize: 10*1000, //限制文件数量 files: 5 &#125;&#125;); 在定义存储器的时候，新增一个limits对象，用来控制上传的一些信息，它有以下一些属性： fieldNameSize：field 名字最大长度，默认值：100 bytes fieldSize：field 值的最大长度，默认值：1MB fields：非文件 field 的最大数量 fileSize：在multipart表单中, 文件最大长度 (字节单位) files：在multipart表单中, 文件最大数量 parts：在multipart表单中, part传输的最大数量(fields + files) 在这边我们把fileSize的值设置得小一点，设为10kb方便测试看效果，但是如果这个时候会发现有报错。因为上传的文件大小很容易就会超过10KB，导致有报错出现，我们就需要在路由回调里对错误的情况进行捕获。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//单个文件上传let singleUpload = upload.single(&#x27;singleFile&#x27;);app.post(&#x27;/upload/single&#x27;,(req,res)=&gt;&#123; singleUpload(req,res,(err)=&gt;&#123; if(!!err)&#123; console.log(err.message) res.json(&#123; code: &#x27;2000&#x27;, type:&#x27;single&#x27;, originalname: &#x27;&#x27;, msg: err.message &#125;) return; &#125; if(!!req.file)&#123; res.json(&#123; code: &#x27;0000&#x27;, type:&#x27;single&#x27;, originalname: req.file.originalname, msg: &#x27;&#x27; &#125;) &#125; else &#123; res.json(&#123; code: &#x27;1000&#x27;, type:&#x27;single&#x27;, originalname: &#x27;&#x27;, msg: &#x27;&#x27; &#125;) &#125; &#125;);&#125;);//多个文件上传let multerUpload = upload.array(&#x27;multerFile&#x27;);app.post(&#x27;/upload/multer&#x27;, (req,res)=&gt;&#123; multerUpload(req,res,(err)=&gt;&#123; if(!!err)&#123; res.json(&#123; code: &#x27;2000&#x27;, type:&#x27;multer&#x27;, fileList:[], msg: err.message &#125;); &#125; let fileList = []; req.files.map((elem)=&gt;&#123; fileList.push(&#123; originalname: elem.originalname &#125;) &#125;); res.json(&#123; code: &#x27;0000&#x27;, type:&#x27;multer&#x27;, fileList:fileList, msg:&#x27;&#x27; &#125;); &#125;);&#125;); 所有的demo代码都在这个仓库里","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"推荐","slug":"Recommend","permalink":"http://xieyufei.com/tags/Recommend/"}]},{"title":"Git学习","date":"2017-09-11T01:48:00.000Z","path":"2017/09/11/Git-Learning.html","text":"对Git的命令和理解进行更深层次的剖析。分支管理是Git的一个特色，同时也是Git的一个难点，但是用好了分支管理对我们的项目开发会有很大的帮助。 一、Git什么是Git。百度百科的解释： 分布式VS集中式那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。 在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。 二、概念理解版本库什么是版本库？版本库又名仓库，英文名repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。git clone命令会把项目的版本库一起克隆到本地，就是.git目录，这个目录是Git来跟踪管理版本的，没事千万不要手动乱改这个目录里面的文件，否则，会把git仓库给破坏了。 工作区和暂存区工作区：就是在电脑里能看到的目录，比如react-stage目录就是一个工作区暂存区：在版本库中。 三、一些常用命令提交修改1234git pull * 从远程仓库拉取git add . * 将文件添加到暂存区git commit -m &#x27;说明&#x27; * 将暂存区的修改提交到当前分支git push * 推送到远程仓库 查看当前状态1git status 用来查看当前工作区和暂存区的状态。可以加-s查看状态的简写形式。 1git status -s 1.颜色区分：红色表示在工作区，绿色表示在暂存区。 2.字符区分： ?? 表示新建的不在版本库中的文件 M 表示修改文件(Modify) A 表示添加文件后追踪了该文件(Add) D 表示删除文件(Delete) 查看修改查看工作区的修改 1git diff [filename] 查看日志查看从近到远的日志信息。 1git log 如果觉得信息太多，可以添加--pretty=oneline查看缩略信息 1git log --pretty=oneline 撤销修改1、撤销工作区修改 1git checkout [filename] 2、撤销分支上的修改 1git reset --hard [LogId] 四、分支管理为了理解Git分支的实现方式，我们需要回顾一下Git是如何储存数据的。Git保存的不是文件差异或者变化量，而只是一系列文件快照。 当使用git commit新建一个提交对象前，Git会先计算每一个子目录（本例中就是项目根目录）的校验和，然后在 Git 仓库中将这些目录保存为树（tree）对象。之后 Git 创建的提交对象，除了包含相关提交信息以外，还包含着指向这个树对象（项目根目录）的指针，如此它就可以在将来需要的时候，重现此次快照的内容了。 Git 中的分支，其实本质上仅仅是个指向 commit 对象的可变指针。Git 会使用 master 作为分支的默认名字。在若干次提交后，你其实已经有了一个指向最后一次提交对象的 master 分支，它在每次提交的时候都会自动向前移动。 创建分支1git branch [branch-name] 通过git branch这种方式创建的分支仅仅是在本地创建了分支，远程仓库是没有这个分支的。因为没有关联，提交的修改是不能push到远程仓库的。 一般都是从远程仓库拉取已有的分支。 1git checkout -b [branch-name] origin/[branch-name] 提交本地分支到远程仓库1git push --set-upstream origin test 或者 1git push origin [branch-name] 切换分支1git checkout [branch-name] 查看分支查看本地所有的分支以及所在的分支 1git branch 查看本地所有的分支以及远程仓库所有的分支 1git branch --all 删除分支删除本地分支 1git branch -d [branch-name] 如果要删除的分支上有提交推送到远程或者merge到其他分支，那么这样删除会失败，可以用强制删除： 1git branch -D [branch-name] 删除远程分支 1git push origin -d [branch-name] 合并分支将其他分支commit的内容合并到当前分支。 1git merge [branch-name] 五、Git最佳实践初始化git流程在clone项目后使用git flow init初始化git流程，选项全部回车默认就行。这个操作只需要在clone后执行一次，以后都不需要了。 123git clone [url]git checkout -b develop origin/developgit flow init 分支说明： master为线上分支。 develop为最新最稳当的开发分支。 feature/xx为当前开发特性的分支。 hotfix为bug修复分支 创建自己的特性分支并提交12git flow feature start [myName]git push origin [feature/myName] 在自己的特性分支开发完成后： 12git checkout developgit merge [feature/myName] 下次开发前： 1234git checkout developgit pullgit checkout [feature/myName]git merge develop","tags":[{"name":"git","slug":"git","permalink":"http://xieyufei.com/tags/git/"}]},{"title":"JS数组去重","date":"2017-09-02T01:58:00.000Z","path":"2017/09/02/JS-Array-Remove-Duplicate.html","text":"笔者在做项目的时候遇到一个问题，需要对数组进行去重操作。在网上找到了各种解决的方法，整理了一下，简单分析一下每种的优缺点。 第一种方法遍历循环 第一种方法也是最一般、最常用的办法，使用数组的indexOf()方法。 1234567891011121314let arr = [1,&#x27;1&#x27;,2,&#x27;2&#x27;,1,2,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;f&#x27;,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;f&#x27;];function unique1(arr)&#123; let result = [arr[0]]; for (let i = 1; i &lt; arr.length; i++) &#123; let item = arr[i]; if(result.indexOf(item) == -1)&#123; result.push(item); &#125; &#125; return result;&#125;console.log(unique1(arr)); 但是indexOf方法内部实现也是去遍历数组知道找到目标为止，如果待去重的数组很长且重复的元素少，则会耗费了大量的时间。 第二种方法存放Hash对象 第二种方法是将数组所有的元素转变成对象的键名，利用对象键名的不可重复的特性来去重。 1234567891011121314151617let arr = [1,&#x27;1&#x27;,2,&#x27;2&#x27;,1,2,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;f&#x27;,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;f&#x27;];function unique2(arr)&#123; let result = []; let obj =&#123;&#125;; for(let i =0;i&lt;arr.length;i++)&#123; let item = arr[i]; if(!obj[item])&#123; result.push(item); obj[item] = 1; &#125; &#125; return result;&#125;console.log(unique2(arr)) 在时间消耗上来看，这种方法比第一种方法要快很多，因为从对象中取属性值消耗的时间几乎可以不计，但是存在以下两个问题： 由于需要存放Hash对象，因此在内存占用上比第一种方法会多占用更多的内存空间，就是所谓的空间换时间。 从上面的排序结果我们会发现一个问题，’12’不在结果中。因为在键名中，String类型的’12’和Number类型的12对于Hash对象来说都是一样的。 第三种方法排序比较 第三种方法利用数组原生的sort()方法，将数组先进行排序，排序后比较相邻两个元素的值。 123456789101112131415let arr = [1,&#x27;1&#x27;,2,&#x27;2&#x27;,1,2,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;f&#x27;,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;f&#x27;];function unique3(arr) &#123; let result = [arr[0]]; arr = arr.sort(); for (let i = 1; i &lt; arr.length; i++) &#123; let item = arr[i]; if (item !== result[result.length - 1]) &#123; result.push(item) &#125; &#125; return result;&#125;console.log(unique3(arr)) 这种方法比indexOf()消耗的时间要短，比存放Hash对象占用的内存要小，算是一种折中两者的方法。但是也存在一个问题，就是去重后的数组的顺序发生了改变。 第四种方法利用Set类型 如果你开发环境支持ES6，这个方法是最简洁的。 1234567let arr = [1,&#x27;1&#x27;,2,&#x27;2&#x27;,1,2,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;f&#x27;,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;f&#x27;];function unique4(arr)&#123; return Array.from(new Set(arr));&#125;console.log(unique4(arr));","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"面试","slug":"Interview","permalink":"http://xieyufei.com/tags/Interview/"}]},{"title":"前端调试告别笨办法","date":"2017-06-13T11:56:39.000Z","path":"2017/06/13/Fiddler-Usage.html","text":"笔者前一阵在做微信站项目的时候在调试的过程中遇到了不少的问题，每次调试接口的时候都需要用console.log将数据打印出来，如果有时候想要修改接口数据还很不方便。针对上面调试的痛点，笔者对Fiddler的用法进行了简单的学习，分享一下学习的心得。 介绍 首先来介绍一下Fiddler。Fiddler是位于客户端和服务器端的HTTP代理，也是目前最常用的http抓包工具之一 。 它能够记录客户端和服务器之间的所有HTTP请求，可以针对特定的HTTP请求，分析请求数据、设置断点、调试web应用、修改请求的数据，甚至可以修改服务器返回的数据，功能非常强大，是web调试的利器。 是的，你没有看错，Fiddler这货居然还能设置断点。不仅如此，Fiddler还能修改请求数据或者修改返回数据。这样在调试的时候可以随意的将服务器的返回数据修改成我们想要的数据了。除此之外，Fiddler还能够拦截手机端的数据，能够看到手机端发送的请求和请求结果，不过要进行一个小小的设置。好了，介绍了这么多，来看一下Fiddler的原理： 既然Fiddler是客户端和服务器端之间的代理，那么客户端所有发起的请求都会经过Fiddler，然后再发送到对应的服务器；同样，服务器所有的响应数据也会经过Fiddler再发送到客户端。 界面 安装完Fiddler，打开界面如下,整个界面可以分为五个部分： 最上面的红色区域是菜单栏，主要有保存/导入请求、自定义规则、设置选项等功能。 中间的蓝色区域是工具栏，针对当前请求的操作，包括清除请求、恢复断点、查找请求。 左侧是请求数据的面板，所有Fiddler捕获到的请求都会在这个面板里，每一个字段的含义如下图所示。 右侧是数据统计的面板，我们可以在这边看到每个请求的详细统计数据（包括请求头、响应头、响应主体、请求时间），还可以设置过滤条件，把我们需要的请求过滤出来。 命令行输入QuickExec可以输入命令进行一些快捷操作。 配置 Fiddler简单介绍完了，下面来看下Fiddler的一些配置。 电脑设置代理 Fiddler打开后会自动更改IE的代理设置，由于Chrome默认代理设置是跟IE关联在一起的，因此Chrome不用进行配置，但是火狐使用独立的代理设置，因此需要单独配置。 首先查看Fiddler的监听端口。在Fiddler中选择Tools =&gt; Fiddler Options =&gt; connections，打开如下界面： 其中的Fiddler Listens on port就是Fiddler的监听端口，我们只要代理到这个端口就可以用Fiddler进行监听了。然后把Allow remote computers to connect这一行前面的勾打上，允许其他电脑来连接。 Firefox手动设置如下，打开工具 =&gt; 选项 =&gt; 高级 =&gt; 网络 =&gt; 设置，然后进行如下设置。 不过上面的手动设置比较麻烦，我们可以安装一个FiddlerHook插件，安装好后启用这个插件就行。 手机端设置代理 Fiddler不仅能够代理电脑的请求，也能够代理手机端的请求，当我们开发微信站或者手机站的时候，就可以很方便我们来进行调试。 IOS设置 IOS选择对应的无线网设置，然后找到HTTP代理，服务器一栏填写电脑的IP地址，端口号是Fiddler端口号，默认8888。 Android设置 在Android中，长按所连接的无线网，然后修改网络，在代理的选项卡里选择手动。同样，服务器一栏填写电脑的IP地址，端口号默认8888. 捕获HTTPS 默认情况下，Fiddler不会捕获HTTPS会话，因此如果不开启HTTPS捕获的话自动应答器是不会替换HTTPS的会话。打开Tools =&gt; Fiddler Options =&gt; HTTPS 弹出框需要安装一个证书，然后全程点Yes就可以了。 功能统计结果 Fiddler的统计选项卡中显示了当前Session的基本信息，在选项卡的最上方显示的是文本信息，最下方是个饼图，按MIME类型显示流量。使用Statistics页签，用户可以通过选择多个会话来得来这几个会话的总的信息统计，比如多个请求和传输的字节数。 选择第一个请求和最后一个请求，可获得整个页面加载所消耗的总体时间。从条形图表中还可以分别出哪些请求耗时最多，从而对页面的访问进行访问速度优化。 查看请求头和响应结果 在左侧请求数据列表中选中一条记录会自动切换到Insprctors面板，这个面板分为上下两个，上面是请求头的一些信息，下面是返回的响应主体。 自动应答器 在日常工作中，有时候脚本样式或者页面有点问题是家常便饭，经常需要对文件进行修改。但是每次都需要发布到测试环境才能看到效果很麻烦，我们希望在自己本机就能看到调试的效果。Fiddler就提供了自动应答器这个功能，能让我们直接看到效果。 打开AutoResponder面板，我们可以添加URL匹配规则，让请求的URL从本地返回文件而不是从服务器。 例如现在需要将线上地址http://xieyufei.com替换为本地的一个HTML文件，首先勾选Enable rules使所有的匹配规则生效，然后勾选Unmatched request passthrough，让没有匹配到的规则通过（如果不勾选这个，打开其他网页会失败）。 然后点Add rules来新增一个匹配规则，在x下面的Rule Editor输入要替换的URL和本地文件的路径，然后Save就添加成功了。 虽然这样添加匹配成功了，但是产生了一个心得问题，由于是匹配URL，所以只要是URL中带有http://xieyufei.com都会被替换掉，所以该域名下所有的脚本、样式以及子页面都会被替换，这样显然不利于我们调试。但是Fiddler提供了另外的四种匹配规则。 前缀为“EXACT:”表示完全匹配（大小写敏感） 前缀为“NOT:”表示发现就不匹配 前缀为“REGEX:”表示使用正则表达式匹配 前缀为“REGEX:(?insx)”表示匹配方式其中： i表示不区分大小写； n表示指定的唯一有效的捕获是显式命名或编号的形式； s表示单行模式； x表示空格说明的； 因此修改一下我们的匹配规则，改为EXACT:http://xieyufei.com就可以了。还有一个小Tips： 将左侧的会话列表中选择一条数据，直接拖拽到AutoResponder面板会直接生成匹配规则。 点击Rule Editor的第二个输入框旁边的小三角找到Find a file可以选择文件路径。 Test...可以测试匹配规则。 在匹配规则上右击会有选项框，你惊不惊喜，意不意外。 构造器 构造器composer用来创建一个HTTP请求然后发送到服务器。可以自己定义一个请求，也可以讲会话列表中拖拽一个已有的请求过来。 Parsed请求 打开Composer面板，第一个就是Parsed选项卡，在表单中我们输入一个HTTP请求，比如对baidu.com发送一个请求。点击Execute按钮，这个请求就发送出去了。这时候在会话列表中就多了一次请求。 Raw请求 第二个选项卡是Raw，也是原始请求，如果熟悉HTTP请求，可以直接手动输入。 ScratchPad暂存 第三个选项卡是ScratchPad，可以同时保存多条原始请求，然后选择性的发送。高亮选中你要发送的请求，然后点击Execute就发送出去了。 Options选项 几个选项说明： Inspector Session：使用同一个 Session 进行连接（同一个域名或者主机的情况下） Fix Content-Length Header： 当你发送 Post 请求时，自动加上或者修正 Header 中的 Content-Length. Follow Redirect：自动根踪 HTTP 状态码为 301 和 302 中返回带 Location 的请求。 Automatically Authenticate：自动进行身份验证。 Tear Off：将 Composer 变成一个浮动窗口。 过滤器 有时候请求刷新一个页面会有很多的请求，看得眼花缭乱，但是绝大多数请求可能并不是我们想要的，这时候我们就需要对请求进行一些过滤。 在Zone Filter中有三个选项，分别过滤以下请求： No Zone Filter：不过滤 Show only Intranet Hosts：仅显示内网的请求 Show only Internet Hosts：仅显示外网的请求 在Host Filter中有四个选项，分别过滤以下请求 No Host Filter：不过滤 Hide the following Hosts：隐藏下面的主机 Show only the following Hosts：仅显示下面的主机 Flag the following Hosts：标记下面的主机 命令行输入 命令行QuickExec允许我们快速的执行一些脚本命令。 select命令 select命令用来选择所有类型为指定类型的HTTP请求，即根据请求的content-type来选择所有同一类型的。常用的select css选择所有的样式请求，select image选择所有的图片请求。 allbut命令 allbut命令用于清除除了指定类型之外的其他HTTP请求，仅保留指定类型。例如allbut image仅保留图片的请求。如果跟一个不存在的类型，执行效果和csl，命令相同，清除所有的请求。 ?text命令 当你在问号后输入一些文本的时候，Fiddler会高亮URL中带有这些文本的所有请求。 &gt;size和&lt;size命令 大于号小于号命令选择响应主体的大小大于（或者小于）指定大小。 =status和=method命令 等号命令用于选择状态码等于指定状态码或者指定请求方法的会话。 @host命令 选择包含指定HOST的全部请求。 bold命令 如果以后的请求的URL中带有指定的字符串，那么将会被加粗显示。bold /bar.aspx表示加粗URL带有bar.aspx。再次执行bold会清除加粗。 bpafter（bpu）、bps、、bpv（bpm） 这几个命令用于批量设置断点。 bpafter和bpu: 中断URL包含指定字符的全部会话 bps: 中断响应状态为指定字符的全部会话 bpv和bpm: 中断指定请求方式的全部会话 cls命令 清除请求列表。 断点调试 虽然bpafter和bpu都是用于中断URL包含指定字符的全部会话，但是打断点的时间是不一样的。bpu是在浏览器发送请求的时候进行断点，可以对请求参数进行修改；而bpafter是在服务器响应的后进行断点，可以对响应结果进行修改。 我们使用用express模拟简单的ajax请求。 12345678910111213var express = require(&#x27;express&#x27;);var path = require(&#x27;path&#x27;);var app = express();var port = process.env.PORT || 8088;app.get(&#x27;/test&#x27;,function(req,res)&#123; var params = req.param(&#x27;name&#x27;) || &#x27;&#x27;; res.json(&#123;name:&#x27;request name is &#x27;+params&#125;);&#125;);var server=app.listen(port,function()&#123; console.log(&#x27;server is listening on port:&#x27;+port);&#125;); 修改请求参数bpu 我们输入命令 bpu /test，然后Fiddler就会进入等待。在浏览器中输入网址，这时候浏览器就会进入等待的状态。在会话列表中选择进入断点状态的请求，然后修改请求参数，修改完后点击Run to Completion结束断点。这时候，浏览器页面也结束等待，出现修改后的结果。 调试完后我们不需要Fiddler再进行断点，可以输入bpu清除所有bpu的断点。 修改响应结果bpafter 同样，我们输入命令 bpafter /test，然后Fiddler就会进入等待。在浏览器中输入网址，这时候浏览器就会进入等待的状态。在会话列表中选择进入断点状态的请求，然后修改响应结果，修改完后点击Run to Completion结束断点。这时候，浏览器页面也结束等待，出现修改后的结果。 调试完后我们不需要Fiddler再进行断点，可以输入bpafter清除所有bpafter的断点。","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"浏览器","slug":"Browser","permalink":"http://xieyufei.com/tags/Browser/"},{"name":"技巧","slug":"Tips","permalink":"http://xieyufei.com/tags/Tips/"}]},{"title":"原生JS发送异步数据请求","date":"2017-06-07T12:47:49.000Z","path":"2017/06/07/Raw-Js-Ajax.html","text":"在做项目的时候，有时候需要用到异步数据请求，但是如果这个时候没有框架的依赖，就需要用到原生JS进行异步数据请求。这时候无非有两种请求方式，一种是AJAX，另一个是JSONP。通过原生JS对异步请求进行简单的封装。 AJAX AJAX是一种数据请求方式，不需要刷新整个页面就能够更新局部页面的数据。AJAX的技术核心是XMLHttpRequest对象，主要请求过程如下： 创建XMLHttpRequest对象(new) 连接服务器(open) 发送请求(send) 接收响应数据(onreadystatechange) 不说话直接贴代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/*** 通过JSON的方式请求* @param &#123;[type]&#125; params [description]* @return &#123;[type]&#125; [description]*/ajaxJSON(params) &#123; params.type = (params.type || &#x27;GET&#x27;).toUpperCase(); params.data = params.data || &#123;&#125;; var formatedParams = this.formateParams(params.data, params.cache); var xhr; //创建XMLHttpRequest对象 if (window.XMLHttpRequest) &#123; //非IE6 xhr = new XMLHttpRequest(); &#125; else &#123; xhr = new ActiveXObject(&#x27;Microsoft.XMLHTTP&#x27;); &#125; //异步状态发生改变，接收响应数据 xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; if (!!params.success) &#123; if (typeof xhr.responseText == &#x27;string&#x27;) &#123; params.success(JSON.parse(xhr.responseText)); &#125; else &#123; params.success(xhr.responseText); &#125; &#125; &#125; else &#123; params.error &amp;&amp; params.error(status); &#125; &#125; if (params.type == &#x27;GET&#x27;) &#123; //连接服务器 xhr.open(&#x27;GET&#x27;, (!!formatedParams ? params.url + &#x27;?&#x27; + formatedParams : params.url), true); //发送请求 xhr.send(); &#125; else &#123; //连接服务器 xhr.open(&#x27;POST&#x27;, params.url, true); xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;); //发送请求 xhr.send(formatedParams); &#125;&#125;,/*** 格式化数据* @param &#123;Obj&#125; data 需要格式化的数据* @param &#123;Boolean&#125; isCache 是否加入随机参数* @return &#123;String&#125; 返回的字符串*/formateParams: function(data, isCache) &#123; var arr = []; for (var name in data) &#123; arr.push(encodeURIComponent(name) + &#x27;=&#x27; + encodeURIComponent(data[name])); &#125; if (isCache) &#123; arr.push(&#x27;v=&#x27; + (new Date()).getTime()); &#125; return arr.join(&#x27;&amp;&#x27;);&#125; IE7及其以上版本中支持原生的 XHR 对象，因此可以直接用：var oAjax = new XMLHttpRequest();。IE6及其之前的版本中，XHR对象是通过MSXML库中的一个ActiveXObject对象实现的。 通过xhr的open函数来连接服务器，主要接收三个参数：请求方式、请求地址和是否异步请求（一般都是异步请求）。请求方式有两种，GET和POST，GET是通过URL将数据提交到服务器的，POST则是通过将数据作为send方法的参数发送到服务器。 给xhr绑定状态改变函数onreadystatechange，主要用来检测xhr的readyState的变化，当异步发送成功后，readyState的数值会由0变成4，同时触发onreadystatechange事件。readyState的属性及对应状态如下： 0 (未初始化) 对象已建立，但是尚未初始化（尚未调用open方法） 1 (初始化) 对象已建立，尚未调用send方法 2 (发送数据) send方法已调用，但是当前的状态及http头未知 3 (数据传送中) 已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误 4 (完成) 数据接收完毕,此时可以通过通过responseBody和responseText获取完整的回应数据 在readystatechange事件中，先判断响应是否接收完成，然后判断服务器是否成功处理请求，xhr.status 是状态码，状态码以2开头的都是成功，304表示从缓存中获取，上面的代码在每次请求的时候都加入了随机数，所以不会从缓存中取值，故该状态不需判断。 JSONP 如果还是用上面的XMLHttpRequest对象来发送需要跨域的请求，虽然调用了send函数，但是xhr的状态一直都是0，也不会触发onreadystatechange事件，这个时候就要用到JSONP的请求方式了。 JSONP(JSON with Padding) 是一种跨域请求方式。主要原理是利用了script标签可以跨域请求的特点，由其src属性发送请求到服务器，服务器返回js代码，网页端接受响应，然后就直接执行了，这和通过script标签引用外部文件的原理是一样的。 JSONP由两部分组成：回调函数和数据，回调函数一般是由网页端控制，作为参数发往服务器端，服务器端把该函数和数据拼成字符串返回。 比如网页端创建一个script标签，并给其src赋值为 http://www.test.com/json/?callback=process， 此时网页端就发起一个请求。服务端将要返回的数据拼作为函数的参数传入，服务端返回的数据格式类似”process({‘name:’xieyufei’})”，网页端接收到了响应值，因为请求者是 script，所以相当于直接调用process方法，并且传入了一个参数。 不说话直接贴代码。 1234567891011121314151617181920212223242526272829303132333435363738394041/*** 通过JSONP的方式请求* @param &#123;[type]&#125; params [description]* @return &#123;[type]&#125; [description]*/ajaxJSONP(params) &#123; params.data = params.data || &#123;&#125;; params.jsonp = params.jsonp || &#x27;callback&#x27;; // 设置传递给后台的回调参数名和参数值 var callbackName = &#x27;jsonp_&#x27; + (new Date()).getTime(); params.data[params.jsonp] = callbackName; var formatedParams = this.formateParams(params.data, params.cache); //创建script标签并插入到页面中 var head = document.getElementsByTagName(&#x27;head&#x27;)[0]; var script = document.createElement(&#x27;script&#x27;); head.appendChild(script); //创建jsonp回调函数 window[callbackName] = function(json) &#123; head.removeChild(script); clearTimeout(script.timer); window[callbackName] = null; params.success &amp;&amp; params.success(json); &#125;; //发送请求 script.src = (!!formatedParams ? params.url + &#x27;?&#x27; + formatedParams : params.url); //为了得知此次请求是否成功，设置超时处理 if (params.time) &#123; script.timer = setTimeout(function() &#123; window[callbackName] = null; head.removeChild(script); params.error &amp;&amp; params.error(&#123; message: &#x27;超时&#x27; &#125;); &#125;, params.time); &#125;&#125; 给script标签设置src属性时浏览器就会去发送请求，但是只能发送一次请求，导致script标签不能复用，因此每次操作完都需要把script标签移除。在浏览器发送请求之前给全局绑定一个回调函数，当数据请求成功时就会调用这个回调函数。 总结 将两种发送异步数据的方式整合起来，根据dataType来进行判断选用哪种方式。贴上完整的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134var xyfAjax = &#123; ajax: function(params) &#123; params = params || &#123;&#125;; params.cache = params.cache || false; if (!params.url) &#123; throw new Error(&#x27;参数不合法&#x27;); &#125; params.dataType = (params.dataType || &#x27;json&#x27;).toLowerCase(); if (params.dataType == &#x27;jsonp&#x27;) &#123; this.ajaxJSONP(params); &#125; else if (params.dataType == &#x27;json&#x27;) &#123; this.ajaxJSON(params); &#125; &#125;, /** * 通过JSONP的方式请求 * @param &#123;[type]&#125; params [description] * @return &#123;[type]&#125; [description] */ ajaxJSONP(params) &#123; params.data = params.data || &#123;&#125;; params.jsonp = params.jsonp || &#x27;callback&#x27;; // 设置传递给后台的回调参数名和参数值 var callbackName = &#x27;jsonp_&#x27; + (new Date()).getTime(); params.data[params.jsonp] = callbackName; var formatedParams = this.formateParams(params.data, params.cache); //创建script标签并插入到页面中 var head = document.getElementsByTagName(&#x27;head&#x27;)[0]; var script = document.createElement(&#x27;script&#x27;); head.appendChild(script); //创建jsonp回调函数 window[callbackName] = function(json) &#123; head.removeChild(script); clearTimeout(script.timer); window[callbackName] = null; params.success &amp;&amp; params.success(json); &#125;; //发送请求 script.src = (!!formatedParams ? params.url + &#x27;?&#x27; + formatedParams : params.url); //为了得知此次请求是否成功，设置超时处理 if (params.time) &#123; script.timer = setTimeout(function() &#123; window[callbackName] = null; head.removeChild(script); params.error &amp;&amp; params.error(&#123; message: &#x27;超时&#x27; &#125;); &#125;, params.time); &#125; &#125;, /** * 通过JSON的方式请求 * @param &#123;[type]&#125; params [description] * @return &#123;[type]&#125; [description] */ ajaxJSON(params) &#123; params.type = (params.type || &#x27;GET&#x27;).toUpperCase(); params.data = params.data || &#123;&#125;; var formatedParams = this.formateParams(params.data, params.cache); var xhr; //创建XMLHttpRequest对象 if (window.XMLHttpRequest) &#123; //非IE6 xhr = new XMLHttpRequest(); &#125; else &#123; xhr = new ActiveXObject(&#x27;Microsoft.XMLHTTP&#x27;); &#125; //异步状态发生改变，接收响应数据 xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; if (!!params.success) &#123; if (typeof xhr.responseText == &#x27;string&#x27;) &#123; params.success(JSON.parse(xhr.responseText)); &#125; else &#123; params.success(xhr.responseText); &#125; &#125; &#125; else &#123; params.error &amp;&amp; params.error(status); &#125; &#125; if (params.type == &#x27;GET&#x27;) &#123; //连接服务器 xhr.open(&#x27;GET&#x27;, (!!formatedParams ? params.url + &#x27;?&#x27; + formatedParams : params.url), true); //发送请求 xhr.send(null); &#125; else &#123; //连接服务器 xhr.open(&#x27;POST&#x27;, params.url, true); xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;); //发送请求 xhr.send(formatedParams); &#125; &#125;, /** * 格式化数据 * @param &#123;Obj&#125; data 需要格式化的数据 * @param &#123;Boolean&#125; isCache 是否加入随机参数 * @return &#123;String&#125; 返回的字符串 */ formateParams: function(data, isCache) &#123; var arr = []; for (var name in data) &#123; arr.push(encodeURIComponent(name) + &#x27;=&#x27; + encodeURIComponent(data[name])); &#125; if (isCache) &#123; arr.push(&#x27;v=&#x27; + (new Date()).getTime()); &#125; return arr.join(&#x27;&amp;&#x27;); &#125;&#125;xyfAjax.ajax(&#123; url:&#x27;http://www.xieyufei.com&#x27;, type:&#x27;get&#x27;, //or post dataType:&#x27;json&#x27;, //or jsonp data:&#123; name:&#x27;xyf&#x27; &#125;, success: function(data)&#123; console.log(data) &#125;&#125;)","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"}]},{"title":"JavaScript深入理解原型和原型链","date":"2017-04-16T04:07:49.000Z","path":"2017/04/16/FrontEnd-JS-Prototype.html","text":"在JavaScript中，原型和闭包是这门语言的两个特点，但同时也是这门语言的两个难点，在js中闭包的用法整理中，简单整理了一下闭包的产生和用法。在面试中，原型也是面试官最喜欢问的一个点。 构造函数创建对象我们先使用构造函数创建一个对象： 12345function Person() &#123;&#125;var person = new Person();person.name = &#x27;name&#x27;;console.log(person.name) // name 在这个例子中，Person就是一个构造函数，我们使用new创建了一个实例对象person。 很简单吧，接下来进入正题： prototype每个函数都有一个prototype属性，就是我们经常在各种例子中看到的那个prototype，比如： 1234567891011function Person() &#123;&#125;// 虽然写在注释里，但是你要注意：// prototype是函数才会有的属性Person.prototype.name = &#x27;name&#x27;;var person1 = new Person();var person2 = new Person();console.log(person1.name) // nameconsole.log(person2.name) // name 那这个函数的prototype属性到底指向的是什么呢？是这个函数的原型吗？ 其实，函数的prototype属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型,也就是这个例子中的person1和person2的原型。 那么什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。 让我们用一张图表示构造函数和实例原型之间的关系： 在这张图中我们用Object.prototype表示实例原型 那么我们该怎么表示实例与实例原型，也就是person和Person.prototype之间的关系呢，这时候我们就要讲到第二个属性： __proto__这是每一个JavaScript对象(除了null)都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。 为了证明这一点,我们可以在火狐或者谷歌中输入： 1234function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ === Person.prototype); //true 于是我们更新下关系图： 既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？ constructor指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：construcotr，每个原型都有一个constructor属性指向关联的构造函数 为了验证这一点，我们可以尝试： 123function Person() &#123;&#125;console.log(Person === Person.prototype.constructor); //true 所以再更新下关系图： 综上我们已经得出： 123456789function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ == Person.prototype) // trueconsole.log(Person.prototype.constructor == Person) // true// 顺便学习一个ES5的方法,可以获得对象的原型console.log(Object.getPrototypeOf(person) === Person.prototype) //true 了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系： 实例与原型当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。 举个例子： 1234567891011function Person() &#123;&#125;Person.prototype.name = &#x27;name&#x27;;var person = new Person();person.name = &#x27;name of this person&#x27;;console.log(person.name) // name of this persondelete person.name;console.log(person.name) // name 在这个例子中，我们设置了person的name属性，所以我们可以读取到为’name of this person’，当我们删除了person的name属性时，读取person.name，从person中找不到就会从person的原型也就是person.__proto__ == Person.prototype中查找，幸运的是我们找到了为’name’，但是万一还没有找到呢？原型的原型又是什么呢？ 在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是 1234var obj = new Object();obj.name = &#x27;name&#x27;console.log(obj.name) // name 所以原型对象是通过Object构造函数生成的，结合之前所讲,实例的__proto__指向构造函数的prototype,所以我们再更新下关系图： 原型链那Object.prototype的原型呢？ null，嗯，就是null,所以查到Object.prototype就可以停止查找了 所以最后一张关系图就是 顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。 补充最后，补充和纠正本文中一些不严谨的地方： 首先是constructor, 12345function Person() &#123;&#125;var person = new Person();console.log(person.constructor === Person); // true 当获取person.constructor时，其实person中并没有constructor属性,当不能读取到constructor属性时，会从person的原型也就是Person.prototype中读取，正好原型中有该属性，所以 1person.constructor === Person.prototype.constructor 其次是__proto__, 绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在与Person.prototype中，实际上，它是来自于Object.prototype，与其说是一个属性，不如说是一个getter/setter，当使用obj.__proto__时，可以理解成返回了Object.getPrototypeOf(obj) 最后是关于继承，前面我们讲到“每一个对象都会从原型”继承”属性”,实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是:继承意味着复制操作，然而JavaScript默认并不会复制对象的属性，相反，JavaScript只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"面试","slug":"Interview","permalink":"http://xieyufei.com/tags/Interview/"}]},{"title":"走进网页虚拟现实WebVR","date":"2017-04-09T12:51:00.000Z","path":"2017/04/09/FrontEnd-Panorama.html","text":"最近几年，虚拟现实VR的概念火了一把，各种VR概念的游戏、设备、视频受到人们的广泛关注。笔者在逛商场的时候也经常会看到有VR设备体验的地方让游人体验一把，各种酷炫的头盔和酷炫的设备着实抓人眼球。但是作为一个前端工作者，我们肯定也希望在我们的网页里也能看到这么酷炫的效果，不经意间在网上发现了一个网页虚拟现实框架A-Frame，分享一下笔者的使用心得。 介绍 A-Frame是Mozilla发布的一个全新的开源框架，旨在帮助开发者开发在浏览器中运行的高性能响应式的VR体验。只需要在页面中引入aFrame.min.js就能够集成支持VR页面所需要的组件了。 优点基于DOM 我们可以使用传统的JavaScript DOM API来操纵A-Frame场景来添加逻辑，行为和功能。同时，A-Frame是基于DOM的，现在一些流行的框架能够基于A-Frame工作，比如React、Vue、jQuery和Angular。 实体组件系统 A-Frame是一个基于three.js的实体组件系统。在A-Frame里一切都是实体，我们插入组件，可以随意撰写外观，行为和功能集成。 丰富的生态系统 A-Frame配备了多个组件，但由于A-Frame在其核心部分是完全可扩展的，社区已经为生态系统填充了许多组件，如物理，粒子系统，音频可视化和Leap Motion控件。这个生态系统是A-Frame的命脉。开发人员可以构建一个组件并发布它，然后其他人可以使用该组件并直接从HTML使用，甚至不必知道任何JavaScript。 强大的可视化检查器 可视化编辑器用于检查和编辑A框架场景的可视化工具。与浏览器的DOM检查器类似，您可以进入任何A-Frame场景，本地或Web上，然后点击ctrl+alt+i键盘。 这将打开视觉检查器，我们可以在其中进行更改。可以在视觉上移动和放置物体，用组件的属性随意的挪动物体，或者围绕相机平移以查看场景的不同视图。 组件 介绍了这么多，让我们来看一下A-Frame是如何来构造组件的。 a-scene 一个场景是由a-scene创建的，是全景渲染的根对象，所有的元素都需要放在a-scene这个组件里。它会处理3D所需的所有设置：设置WebGL、画布、相机、灯光、渲染器、渲染循环以及开启及时的WebVR支持。 a-sky 每一个场景都需要一个背景，a-sky标签用来设置场景的背景，可以直接放置src为全景图片，或者直接渲染color值。 123&lt;a-scene&gt; &lt;a-sky color=&quot;#ccc&quot; src=&quot;images/panorama.jpg&quot;&gt;&lt;/a-sky&gt;&lt;/a-scene&gt; 如果直接渲染了color值，那么整个背景就会变成该颜色；如果设置全景图片，可以左右移动来查看。效果链接戳这里。 a-box 我们通过a-box标签来生成一个长方体，有一下几个重要的属性： width：宽度 height：高度 depth：深度 color：颜色 position：位置 rotation：旋转 scale：缩放 123456789101112&lt;a-scene&gt; &lt;a-sky color=&quot;#f0f0f0&quot;&gt;&lt;/a-sky&gt; &lt;a-box color=&quot;red&quot; depth=&quot;1&quot; height=&quot;1&quot; width=&quot;1&quot; position=&quot;0 2 -5&quot; rotation=&quot;0 45 45&quot; scale=&quot;1 1 1&quot;&gt; &lt;/a-box&gt;&lt;/a-scene&gt; 最后生成一个长1高1深1颜色为红色的长方体： a-assets 但是如果仅仅是红色的外观那么就太单调了。A-Frame允许我们给组件设置纹理图片，虽然可以直接给组件设置src属性，不过不推荐这种做法，推荐通过资源管理系统a-assets。 一般在游戏等视觉体验丰富的场景中，由于有着大量的图片、模型、声音等资源，都会对这些资源进行一个预加载处理，确保在渲染的时候不会出现缺失的现象。 我们把这些资源放到a-assets也是为了进行预加载。我们可以存放以下资源： &lt;a-asset-item&gt;：其他资产，如3D模型和材料 &lt;audio&gt;：声音文件 &lt;img&gt;：图像纹理 &lt;video&gt;：视频纹理 我们通过给资源标志一个唯一的id，然后在组件的src中引用这个id来进行调用。 123456789&lt;a-box src=&quot;#boxTexture&quot; depth=&quot;1&quot; height=&quot;1&quot; width=&quot;1&quot; position=&quot;0 2 -5&quot; rotation=&quot;0 45 45&quot; scale=&quot;1 1 1&quot;&gt;&lt;/a-box&gt; 这样我们的长方体就变成了一个带有图案纹理的长方体。 a-light 我们可以通过使用a-light来改变场景的亮度。默认情况下，如果我们没有指定任何指示灯，A-Frame将添加环境光和定向光。如果A-Frame没有为我们添加灯，场景将是黑色的。一旦我们添加了我们自己的灯，默认的照明设置将被删除，并替换为我们的设置。 我们还会添加一个点光源，点光源就像灯泡; 我们可以将它们放在场景周围，点光源对实体的影响取决于它与实体的距离。 12345678&lt;！ - 红色定向灯从左上方闪烁。 - &gt;&lt;a-light color=&quot;red&quot; position=&quot;-1 1 0&quot;&gt;&lt;/a-light&gt;&lt;！ - 蓝点光，5米空中。 - &gt;&lt;a-light tpye=&quot;point&quot; color=&quot;blue&quot; position=&quot;0 5 0&quot;&gt;&lt;/a-light&gt;&lt;！ - 昏暗环境照明。 - &gt;&lt;a-light type=&quot;ambient&quot; color=&quot;yellow&quot;&gt;&lt;/a-light&gt; 我们给环境一个黄色照明的光源，最后的效果是这样的。 a-animation 我们可以使用A-Frame的内置动画系统&lt;a-animation&gt;向盒子添加动画。我们可以将&lt;a-animation&gt;元素作为实体的子代。让我们把盒子上下摆动来给场景添加一些动作。 12345678910&lt;a-box src=&quot;#boxTexture&quot; depth=&quot;1&quot; height=&quot;1&quot; width=&quot;1&quot; position=&quot;0 2 -5&quot; rotation=&quot;0 45 45&quot; scale=&quot;1 1 1&quot;&gt; &lt;!-- 在box里面添加animation元素 --&gt; &lt;a-animation attribute=&quot;position&quot; to=&quot;0 1 -5&quot; direction=&quot;alternate&quot; dur=&quot;2000&quot; repeat=&quot;indefinite&quot;&gt; &lt;/a-animation&gt;&lt;/a-box&gt; 一些属性说明： attribute：需要把哪个属性作为动画 to：属性到某个值 direction：方向，alternate表示来回 dur：时间间隔 repeat：重复次数 a-text 在A-Frame中还可以添加文本组件&lt;a-text&gt;。 12345&lt;a-text value=&quot;Hello, A-Frame!&quot; color=&quot;#0abef0&quot; position=&quot;-0.9 0.2 -3&quot; scale=&quot;1.5 1.5 1.5&quot;&gt;&lt;/a-text&gt; 最后添加文字的效果，效果链接戳这里。 a-cylinder 圆筒原型是多功能的，可用于创建不同种类的形状： 12345678&lt;!-- 基本圆筒。 -- &gt;&lt;a-cylinder color=&quot;crimson&quot; height=&quot;3&quot; radius=&quot;1.5&quot;&gt;&lt;/a-cylinder&gt;&lt;!-- 六角形。 -- &gt;&lt;a-cylinder color=&quot;cyan&quot; segments-radial=&quot;8&quot;&gt;&lt;/a-cylinder&gt;&lt;!-- 吃豆人。 -- &gt;&lt;a-cylinder color=&quot;yellow&quot; theta-start=&quot;50&quot; theta-length=&quot;280&quot; side=&quot;double&quot;&gt;&lt;/a-cylinder &gt;&lt;!-- 绿色管道。 --&gt;&lt;a-cylinder color=&quot;green&quot; open-ended=&quot;true&quot;&gt;&lt;/a-cylinder&gt; a-cone 用于创造一个椎体。 1&lt;a-cone position=&quot;0 0 -20&quot; rotation=&quot;35 45 30&quot; height=&quot;10&quot; radius-top=&quot;2&quot; radius-bottom=&quot;10&quot; color=&quot;#F3BA8D&quot;&gt;&lt;/a-cone&gt; 使用JS和DOM 在A-Frame中也有DOM元素，通过querySelector()和querySelectorAll()方法来提供元素的遍历，查询，查找和选择。这个很像jQuery中的选择器。 querySelector 如果我们想抓住一个元素，我们使用querySelector()返回那一个元素。比如我们来抓住场景元素： 12var scene = document.querySelector(&#x27;a-scene&#x27;);console.log(scene); 如果元素具有ID，则可以使用ID选择器（即，#）。我们来抓住一个有一个ID的红色框。之前我们在整个文档上做了一个查询选择器。在这里，我们将在场景范围内做一个查询选择器。使用查询选择器，我们可以将查询的范围限制在任何元素内： 12var scene = document.querySelector(&#x27;a-scene&#x27;);console.log(scene.querySelector(&#x27;#mybox&#x27;)); querySelectorAll 如果我们要抓取一组元素，我们使用querySelector()哪个返回一个元素数组。我们可以查询元素名称、类名、属性名： 12345678910// 查询元素名称console.log(document.querySelectorAll(&#x27;a-box&#x27;));// 查询类名console.log(document.querySelectorAll(&#x27;.mybox&#x27;));// [// &lt;a-entity light=&quot;type:ambient&quot;&gt;&lt;/a-entity&gt;// &lt;a-entity light=&quot;type:directional&quot;&gt;&lt;/a-entity&gt;//]// 查询属性名console.log(document.querySelectorAll(&#x27;[light]&#x27;)); 如果我们抓住了一组使用的实体querySelectorAll()，我们可以循环使用它们for。我们围绕场景中的每个元素循环遍历。 1234var els = document.querySelectorAll(&#x27;a-box&#x27;);for(var i = 0; i &lt; els.length; i++)&#123; console.log(els[i]);&#125; createElement 要创建一个实体，我们可以使用document.createElement。这将给我们一个空白的实体： 1var el = document .createElement(&#x27;a-entity&#x27;); 但是，在将实体附加到我们的场景之前，该实体将不会被初始化或者成为场景的一部分。 appendChild 要向DOM添加实体，我们可以使用.appendChild(element)。具体来说，我们想把它添加到我们的场景中。我们抓住现场，创建实体，并将实体附加到我们的场景。 123var sceneEl = document .querySelector(&#x27;a-scene&#x27;);var entityEl = document .createElement(&#x27;a-entity&#x27;);sceneEl.appendChild(entityEl); 请注意，这appendChild()方法是浏览器中的异步操作。在实体完成附加到DOM之前，我们不能对实体执行许多操作（如调用.getAttribute()）。如果我们需要查询刚被追加的实体上的一个属性，我们可以监听loaded该实体上的事件，或者将逻辑放在A-Frame组件中，以便一旦它被准备好就执行： removeChild 要从DOM中移除实体，因此从场景中删除一个实体，我们removeChild(element)从父元素调用。如果我们有一个实体，我们必须要用它的parent(parentNode)去除实体。 1entityEl.parentNode.removeChild(entityEl); setAttribute 要更新组件，我们可以使用setAttribute()方法。更新组件需要几种形式。如果组件是单属性组件，则setAttribute其行为与通常情况相同： 1entity.setAttribute(&#x27;visible&#x27;,false); 但是如果是单属性，它可以处理该值的特殊解析。例如，position组件是单属性组件，但其属性类型解析器允许它占用一个对象： 1entity.setAttribute(&#x27;position&#x27;,&#123;x:1,y:2,z:3&#125;); 要设置或替换多属性组件的组件数据，我们可以传递注册组件的属性名称，并将属性对象传递为value： 12345entity.setAttribute(&#x27;light&#x27;, &#123; type: &#x27;spot&#x27;, distance: 30, intensity: 2.0&#125;); removeAttribute 从DOM中删除属性或者分离组件，调用组件的remove生命周期方法。 12entity.removeAttribute(&#x27;goemetry&#x27;); //分离几何组件。entity.removeAttribute(&#x27;sound&#x27;); //分离声音组件。","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"游戏","slug":"Game","permalink":"http://xieyufei.com/tags/Game/"}]},{"title":"记一次项目总结","date":"2017-03-29T09:06:49.000Z","path":"2017/03/29/Project-Summary.html","text":"这一个月来一直在做项目，在做项目的时候遇到了不少的问题和坑，归纳了一下，主要是文件上传、停止Promise链式调用和chrome自动填充，整理总结了一下解决方法。 一、文件上传选择文件 在选择文件之前，我们需要对文件类型进行一些过滤的操作。 文件类型 通过input:file来选择我们需要的文件类型，有两个属性值是我们需要的： accept:表示可以选择的文件MIME类型，多个MIME类型用英文逗号分开，常用的MIME类型见下表。 multiple:是否可以选择多个文件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849后缀名 MIME名称*.3gpp audio/3gpp, video/3gpp*.ac3 audio/ac3*.asf allpication/vnd.ms-asf*.au audio/basic*.css text/css*.csv text/csv*.doc application/msword *.dot application/msword *.dtd application/xml-dtd *.dwg image/vnd.dwg *.dxf image/vnd.dxf*.gif image/gif *.htm text/html *.html text/html *.jp2 image/jp2 *.jpe image/jpeg*.jpeg image/jpeg*.jpg image/jpeg *.js text/javascript, application/javascript *.json application/json *.mp2 audio/mpeg, video/mpeg *.mp3 audio/mpeg *.mp4 audio/mp4, video/mp4 *.mpeg video/mpeg *.mpg video/mpeg *.mpp application/vnd.ms-project *.ogg application/ogg, audio/ogg *.pdf application/pdf *.png image/png *.pot application/vnd.ms-powerpoint *.pps application/vnd.ms-powerpoint *.ppt application/vnd.ms-powerpoint *.rtf application/rtf, text/rtf *.svf image/vnd.svf *.tif image/tiff *.tiff image/tiff *.txt text/plain *.wdb application/vnd.ms-works *.wps application/vnd.ms-works *.xhtml application/xhtml+xml *.xlc application/vnd.ms-excel *.xlm application/vnd.ms-excel *.xls application/vnd.ms-excel *.xlt application/vnd.ms-excel *.xlw application/vnd.ms-excel *.xml text/xml, application/xml *.zip aplication/zip *.xlsx application/vnd.openxmlformats-officedocument.spreadsheetml.sheet 但是在开发时，我们习惯把accept设置为image/*来过滤所有非图片的文件。虽然这种方式简单粗暴，但是在新版本的chrome中，会出现点击input之后，文件选择框弹出非常慢的问题。将accept=&quot;image/*&quot;改为指定的图片格式，比如指定几种常用格式，就能解决这个问题。 1&lt;input type=&quot;file&quot; name=&quot;file&quot; accept=&quot;image/jpg,image/jpeg,image/png,image/gif&quot;&gt; 文件读取 在input选取文件后，我们可以监听chang事件来获取所选取的文件。 12345$(&#x27;input&#x27;).on(&#x27;change&#x27;,function()&#123; if(this.files &amp;&amp; this.files.length&gt;0)&#123; console.log(this.files); &#125;&#125;); 这里获取到的this.files是一个FileList对象，也是一个类数组对象，可以通过this.files[index]来获取每一个文件。 这个数组对象中的每个对象有以下几个属性： lastModified:上次修改时间的时间戳 lastModifiedDate:上次修改时间的日期 name:文件名称 size:文件大小 type:文件类型 webkitRelativePath: 在获取到文件后，我们可以根据type和size对文件的类型和大小进行过滤匹配。匹配后需要对文件的内容进行读取。HTML5定义了一个FileReader对象用来读取文件。FileReader使用方式也非常简单，需要创建FileReader对象并调用方法。 123if(window.FileReader)&#123; var fileReader = new FileReader();&#125; FileReader的实例对象有4个方法，三个方法是用来读取文件的，还有一个方法用来中断读取。 方法 参数 描述 abort none 中断读取 readAsBinaryString file 将文件读取为二进制码 readAsDataURL file 将文件读取为 DataURL readAsText file, [encoding] 将文件读取为文本 readAsText主要用来读取文本文件的内容，readAsDataURL用来读取文件并将其转为DataUrl格式。FileReader还有一系列完整的事件函数，用来捕获读取文件时的状态。 事件 描述 onabort 中断时触发 onerror 出错时触发 onload 文件读取成功完成时触发 onloadend 读取完成触发，无论成功或失败 onloadstart 读取开始时触发 onprogress 读取中 文件一旦开始读取，无论成功或失败，实例的result属性都会被填充。如果读取失败，则result的值为 null，否则即是读取的结果，绝大多数的程序都会在成功读取文件的时候，抓取这个值。 12345var fileReader = new FileReader();fileReader.readAsDataURL(imgFile);reader.onload = function(event) &#123; console.log(this.result);&#125; 通过readAsDataURL来读取图片变成DataUrl格式。将其字符串嵌入到页面中，我们可以看到读取后的图片，通过这种方式实现选取图片后的预览效果。 123456 &lt;img src=&quot;data:image/gif;base64,R0lGODlhMwAxAIAAAAAAAP///yH5BAAAAAAALAAAAAAzADEAAAK8jI+pBr0PowytzotTtbm/DTqQ6C3hGXElcraA9jIr66ozVpM3nseUvYP1UEHF0FUUHkNJxhLZfEJNvol06tzwrgdLbXsFZYmSMPnHLB+zNJFbq15+SOf50+6rG7lKOjwV1ibGdhHYRVYVJ9Wnk2HWtLdIWMSH9lfyODZoZTb4xdnpxQSEF9oyOWIqp6gaI9pI1Qo7BijbFZkoaAtEeiiLeKn72xM7vMZofJy8zJys2UxsCT3kO229LH1tXAAAOw==&quot;&gt; base64方式上传 在通过readAsDataURL方法读取到文件的DataUrl后，我们可以将这么长的字符串直接放到ajax中作为string类型发送到后台解析（建议使用post方式）。不过会有一定的局限性，就是如果文件很大，服务器可能会拒绝接受这么长的字符串。 FormData方式上传 FormData对象是HTML5新增的一个对象，目前一些主流的浏览器都已经兼容了，我们可以通过FormData来向服务器传递数据。 1234567891011var formData = new FormData();formData.append(&#x27;username&#x27;,&#x27;corner&#x27;);formData.append(&#x27;pwd&#x27;,&#x27;corner&#x27;);$.ajax(&#123; url:&#x27;this is your url&#x27;, type:&#x27;get&#x27;, data:formData, success: function(data)&#123; console.log(data); &#125;&#125;); 但是如果这样直接把FormData对象作为data数据来发送，浏览器会报一个非法调用的错误。 在发送FormData对象时，还需要给ajax加上另外两个属性： 12345678910$.ajax(&#123; url:&#x27;this is your url&#x27;, type:&#x27;get&#x27;, data:formData, processData:false, contentType:false, success: function(data)&#123; console.log(data); &#125;&#125;); jQuery在发送异步请求的时候会自动将data数据进行序列化处理，转化成key/value格式的字符串，加上processData:false说明禁止对数据进行序列化处理。contentType用来指定发送至服务器时的内容编码类型。 如果每个表单数据都需要使用append来添加就比较麻烦，FormData还支持直接从html中的表单生成数据，就是在html页面中已经有数据了，然后FormData可以直接把这个表单的数据写入这个对象，然后直接提交给后台。 12345&lt;form id=&quot;form&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;img&quot; accept=&quot;image/jpeg,image/jpg,image/png,image/gif&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt; &lt;input type=&quot;button&quot; class=&quot;submit&quot; value=&quot;submit&quot;/&gt;&lt;/form&gt; 我们定义了一个form表单，有text类型和file类型的input。 123456789101112$(&#x27;.submit&#x27;).on(&#x27;click&#x27;,function()&#123; var formData = new FormData($(&#x27;#form&#x27;)[0]); $.ajax(&#123; url:&#x27;this is your url&#x27;, type:&#x27;post&#x27;, data:formData, processData:false, contentType:false, success: function(data)&#123; console.log(data); &#125; &#125;); FormData还支持异步的上传文件，以前我们上传文件，需要写一个表单直接刷新提交，现在可以使用FormData，在构造这个对象的时候，把表单的对象，作为一个参数放进去，就可以了，然后FormData，就会得到这个表单对象里面的所有的参数，甚至我们在表单中，都不需要声明enctype =&quot;multipart/form-data&quot;，就可以直接提交。 使用FormData的优点，第一是在提交表单的时候，不需要写大量的js来获得表单数据，直接把表单对象构造就行了。第二就是可以直接异步上传文件。 二、停止Promise链式调用 Promise的链式调用虽然方便我们不用再写恶心的嵌套回调，但是有一个问题，就是如果第一个异步没有发送成功，进入了reject函数，后面的链式调用的resolve函数的data都是undefined，对后面的then调用造成了很大的问题。 第一个解决方法 在每个then方法中对data进行非空判断。 第二个解决方法 如果当前的Promise进入reject函数，对后面的Promise都进行abort操作，该方法适用于jQuery的Promise操作。 1234567891011121314getAsync1().then(function(data)&#123; return getAsync2();&#125;,function(err)&#123; return getAsync2().abort();&#125;).then(function(data)&#123; return getAsync3();&#125;,function(err)&#123; if(err.statusText != &#x27;abort&#x27;)&#123; // ...不是通过上一个Promise的abort进入 &#125; return getAsync3().abort();&#125;); 三、chrome禁止自动填充 chrome保存密码并且自动填充的功能确实能够方便我们在浏览网站的时候登录进去，但是有时候chrome会莫名其妙的抽风，在我们不想要填充的地方自动给input填充上账号，为了不让chrome自动填充，我们采用下面的方式禁止自动填充： 12&lt;input type=&quot;text&quot; style=&quot;display:none&quot;/&gt;&lt;input type=&quot;password&quot; id=&quot;pwd&quot; autocomplete=&quot;off&quot;/&gt; 我们在我们需要的input#pwd上面加一个display:none隐藏的div，然后给input#pwd加上一个autocomplete=”off”的属性，这样，这个input#pwd就不会自动填充了。 四、文件下载 刚开始，笔者在页面上用jQuery的$.post方法发送一个请求给服务器，然后服务器根据这个参数再生成相应的一个文件流返回给客户端。但是，在$.post方法的回调函数中，只能处理xml, json, script, or html类型，对返回的文件流却没办法弹出对话框让用户下载了。经过百度，看到了很多人采用隐藏form提交的方式，再用response来推就可以。 123456789101112131415function exportRecord(ajaxData) &#123; var form = $(&quot;&lt;form&gt;&quot;); form.attr(&#x27;style&#x27;, &#x27;display:none&#x27;); form.attr(&#x27;target&#x27;, &#x27;&#x27;); form.attr(&#x27;method&#x27;, ajaxData.method); //请求方式 form.attr(&#x27;action&#x27;, ajaxData.url);//请求地址 var input1 = $(&#x27;&lt;input&gt;&#x27;);//将你请求的数据模仿成一个input表单 input1.attr(&#x27;type&#x27;, &#x27;hidden&#x27;); input1.attr(&#x27;name&#x27;, &#x27;&#x27;);//该输入框的name input1.attr(&#x27;value&#x27;, &#x27;&#x27;);//该输入框的值value $(&#x27;body&#x27;).append(form); form.append(input1); form.submit(); form.remove();&#125; 这种方法发出的请求格式类似于username=username&amp;password=password. 代码中的name就是请求中的key，代码中的value就是请求数据中的value","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"推荐","slug":"Recommend","permalink":"http://xieyufei.com/tags/Recommend/"}]},{"title":"jQuery实现贪吃蛇游戏","date":"2017-02-28T13:45:10.000Z","path":"2017/02/28/jQuery-Realize-Snake.html","text":"贪吃蛇的游戏相信大家都玩过。在那个水果机还没有流行，人手一部诺基亚的时代，贪吃蛇是手机中的必备游戏。笔者闲的无聊的时候就拿出手机来玩上几局，挑战一下自己的记录。 后来上大学了，用c语言做过贪吃蛇的游戏，不过主要是通过函数来控制（PS：现在让我看代码都看不懂(⊙﹏⊙)）。现在学习前端框架之后，通过jQuery来实现一个贪吃蛇的游戏效果，虽然游戏界面比（bu）较（ren）简（zhi）陋（shi），但是主要学习一下游戏中面向对象和由局部到整体的思想。 设计思想 在开始写代码前首先让我们来构思一下整体游戏的实现过程： 需要的对象 首先既然是贪吃蛇，那么游戏中肯定要涉及到两个对象，一个是蛇的对象，另一个是食物的对象。食物对象肯定要有一个属性就是食物的坐标点，蛇对象有一个属性是一个数组，用来存放蛇身体所有的坐标点。 如何移动 另外全局需要有一个定时器来周期性的移动蛇的身体。由于蛇的身体弯弯曲曲有各种不同的形状，因此我们只处理蛇的头部和尾部，每次移动都根据移动的方向的不同来添加新的头部，再把尾部擦去，看起来就像蛇在向前爬行一样。 方向控制 由于蛇有移动的方向，因此我们也需要在全局定义一个方向对象，对象中有上下左右所代表的值。同时，在蛇对象的属性中我们也需要定义一个方向属性，用来表示当前蛇所移动的方向。 碰撞检测 在蛇向前爬行的过程中，会遇到三种不同的情况，需要进行不同的判断检测。第一种情况是吃到了食物，这时候就需要向蛇的数组中添加食物的坐标点；第二种情况是碰到了自己的身体，第三种是碰到了边界，这两种情况都导致游戏结束；如果不是上面的三种情况，蛇就可以正常的移动。 开始编程 整体构思有了，下面就开始写代码了。 搭建幕布 首先整个游戏需要一个搭建活动的场景，我们通过一个表格布局来作为整个游戏的背景。 1234567891011121314151617181920212223242526272829&lt;style type=&quot;text/css&quot;&gt;#pannel table&#123; border-collapse:collapse;&#125;#pannel td&#123; width: 10px; height: 10px; border: 1px solid #000;&#125;#pannel td.food&#123; background: green;&#125;#pannel td.body&#123; background: #f60;&#125;&lt;/style&gt;&lt;div id=&quot;pannel&quot;&gt;&lt;/div&gt;&lt;select name=&quot;&quot; id=&quot;palSize&quot;&gt; &lt;option value=&quot;10&quot;&gt;10*10&lt;/option&gt; &lt;option value=&quot;20&quot;&gt;20*20&lt;/option&gt; &lt;option value=&quot;40&quot;&gt;30*30&lt;/option&gt;&lt;/select&gt;&lt;select name=&quot;&quot; id=&quot;palSpeed&quot;&gt; &lt;option value=&quot;500&quot;&gt;速度-慢&lt;/option&gt; &lt;option value=&quot;250&quot;&gt;速度-正常&lt;/option&gt; &lt;option value=&quot;100&quot;&gt;速度-快&lt;/option&gt;&lt;/select&gt;&lt;button id=&quot;startBtn&quot;&gt;开始&lt;/button&gt; pannel就是我们的幕布，我们在这个里面用td标签来画上一个个的“像素点”。我们用两种样式来表现不同的对象，.body表示蛇的身体的样式，.food表示食物的样式。 12345678910111213141516171819202122var settings = &#123; // pannel面板的长度 pannelSize: 10, // 贪吃蛇移动的速度 speed: 500, // 贪吃蛇工作线程 workThread: null,&#125;;function setPannel(size)&#123; var content = []; content.push(&#x27;&lt;table&gt;&#x27;); for(let i=0;i&lt;size;i++)&#123; content.push(&#x27;&lt;tr&gt;&#x27;); for(let j=0;j&lt;size;j++)&#123; content.push(&#x27;&lt;td class=&quot;td_&#x27;+i+&#x27;_&#x27;+j+&#x27;&quot;&gt;&lt;/td&gt;&#x27;); &#125; content.push(&#x27;&lt;/tr&gt;&#x27;); &#125; content.push(&#x27;&lt;/table&gt;&#x27;); $(&#x27;#pannel&#x27;).html(content.join(&#x27;&#x27;));&#125;setPannel(settings.pannelSize); 我们定义了一个全局的settings用来存放全局性的变量，比如幕布的大小、蛇移动的速度和工作的线程。然后通过一个函数把幕布画了出来，最后的效果就是这样： 方向和定位 既然我们的“舞台”已经搭建完了，怎么来定义我们“演员”的位置和移动的方向呢。首先定义一个全局的方向变量，对应的数值就是我们的上下左右方向键所代表的keyCode。 123456var Direction = &#123; UP: 38, DOWN: 40, LEFT: 37, RIGHT: 39,&#125;; 我们在上面画幕布的时候通过两次遍历画出了一个类似于中学里学的坐标系，有X轴和Y轴。如果每次都用&#123;x:x,y:y&#125;来表示会很（mei）麻（bi）烦（ge），我们可以定义一个坐标点对象。 123456function Position(x,y)&#123; // 距离X轴长度，取值范围0~pannelSize-1 this.X = x || 0; // 距离Y轴长度，取值范围0~pannelSize-1 this.Y = y || 0;&#125; 副咖–食物 既然定义好了坐标点对象，那么可以先来看一下简单的对象，就是我们的食物（Food）对象，上面说了，它有一个重要的属性就是它的坐标点。 12345678910111213141516171819202122232425262728function Food()&#123; this.pos = null; // 随机产生Food坐标点，避开蛇身 this.Create = function()&#123; if(this.pos)&#123; this.handleDot(false, this.pos, &#x27;food&#x27;); &#125; let isOk = true; while(isOk)&#123; let x = parseInt(Math.random()*settings.pannelSize), y = parseInt(Math.random()*settings.pannelSize); if(!$(&#x27;.td_&#x27;+x+&#x27;_&#x27;+y).hasClass(&#x27;body&#x27;))&#123; isOk = false; let pos = new Position(x, y); this.handleDot(true, pos, &#x27;food&#x27;); this.pos = pos; &#125; &#125; &#125;; // 画点 this.handleDot = function(flag, dot, className)&#123; if(flag)&#123; $(&#x27;.td_&#x27;+dot.X+&#x27;_&#x27;+dot.Y).addClass(className); &#125; else &#123; $(&#x27;.td_&#x27;+dot.X+&#x27;_&#x27;+dot.Y).removeClass(className); &#125; &#125;;&#125; 既然食物有了坐标点这个属性，那么我们什么时候给他赋值呢？我们知道Food是随机产生的，因此我们定义了一个Create函数用来产生Food的坐标点。但是产生的坐标点又不能在蛇的身体上，所以通过一个while循环来产生坐标点，如果坐标点正确了，就终止循环。此外为了方便我们统一处理坐标点的样式，因此定义了一个handleDot函数。 主咖–蛇 终于到了我们的主咖，蛇。首先定义一下蛇基本的属性，最重要的肯定是蛇的body属性，每次移动时，都需要对这个数组进行一些操作。其次是蛇的方向，我们给它一个默认向下的方向。然后是食物，在蛇的构造函数中我们传入食物对象，在后续移动时需要判断是否吃到食物。 123456789101112131415161718192021222324252627282930function Snake(myFood)&#123; // 蛇的身体 this.body = []; // 蛇的方向 this.dir = Direction.DOWN; // 蛇的食物 this.food = myFood; // 创造蛇身 this.Create = function()&#123; let isOk = true; while(isOk)&#123; let x = parseInt(Math.random()*(settings.pannelSize-2))+1, y = parseInt(Math.random()*(settings.pannelSize-2))+1; console.log(x,y) if(!$(&#x27;.td_&#x27;+x+&#x27;_&#x27;+y).hasClass(&#x27;food&#x27;))&#123; isOk = false; let pos = new Position(x, y); this.handleDot(true, pos, &#x27;body&#x27;) this.body.push(pos); &#125; &#125; &#125;; this.handleDot = function(flag, dot, className)&#123; if(flag)&#123; $(&#x27;.td_&#x27;+dot.X+&#x27;_&#x27;+dot.Y).addClass(className); &#125; else &#123; $(&#x27;.td_&#x27;+dot.X+&#x27;_&#x27;+dot.Y).removeClass(className); &#125; &#125;;&#125; 移动函数处理 下面对蛇移动的过程进行处理，由于我们每次都采用添头去尾的方式移动，因此我们每次只需要关注蛇的头和尾。我们约定数组的第一个元素是头，最后一个元素是尾。 12345678910111213141516171819202122232425this.Move = function()&#123; let oldHead = Object.assign(new Position(), this.body[0]), oldTail = Object.assign(new Position(), this.body[this.body.length - 1]), newHead = Object.assign(new Position(), oldHead); switch(this.dir)&#123; case Direction.UP: newHead.X = newHead.X - 1; break; case Direction.DOWN: newHead.X = newHead.X + 1; break; case Direction.LEFT: newHead.Y = newHead.Y - 1; break; case Direction.RIGHT: newHead.Y = newHead.Y + 1; break; default: break; &#125; // 数组添头 this.body.unshift(newHead); // 数组去尾 this.body.pop();&#125;; 检测函数处理 这样我们对蛇身数组就处理完了。但是我们还需要对新的头（newHead）进行一些碰撞检测，判断新头部的位置上是否有其他东西（碰撞检测）。 12345678910111213141516171819202122232425262728293031323334// 食物检测this.eatFood = function()&#123; let newHead = this.body[0]; if(newHead.X == this.food.pos.X&amp;&amp;newHead.Y == this.food.pos.Y)&#123; return true; &#125; else &#123; return false; &#125;&#125;;// 边界检测this.konckWall = function()&#123; let newHead = this.body[0]; if(newHead.X == -1 || newHead.Y == -1 || newHead.X == settings.pannelSize || newHead.Y == settings.pannelSize )&#123; return true; &#125; else &#123; return false; &#125;&#125;;// 蛇身检测this.konckBody = function()&#123; let newHead = this.body[0], flag = false; this.body.map(function(elem, index)&#123; if(index == 0) return; if(elem.X == newHead.X &amp;&amp; elem.Y == newHead.Y)&#123; flag = true; &#125; &#125;); return flag;&#125;; 重新绘制 因此我们需要对Move函数进行一些扩充： 123456789101112131415161718192021222324252627this.Move = function()&#123; // ...数组操作 if(this.eatFood())&#123; this.body.push(oldTail); this.food.Create(); this.rePaint(true, newHead, oldTail); &#125; else if(this.konckWall() || this.konckBody()) &#123; this.Over(); &#125; else &#123; this.rePaint(false, newHead, oldTail); &#125;&#125;;this.Over = function()&#123; clearInterval(settings.workThread); console.log(&#x27;Game Over&#x27;);&#125;;this.rePaint = function(isEatFood, newHead, oldTail)&#123; if(isEatFood)&#123; // 加头 this.handleDot(true, newHead, &#x27;body&#x27;); &#125; else &#123; // 加头 this.handleDot(true, newHead, &#x27;body&#x27;); // 去尾 this.handleDot(false, oldTail, &#x27;body&#x27;); &#125;&#125;; 因为在Move函数处理数组的后我们的蛇身还没有重新绘制，因此我们很巧妙地判断如果是吃到食物的情况，在数组中就把原来的尾部添加上，这样就达到了吃食物的效果。同时我们定义一个rePaint函数进行页面的重绘。 游戏控制器 我们的“幕布”、“演员”和“动作指导”都已经到位，那么，我们现在就需要一个“摄影机”进行拍摄，让它们都开始“干活”。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869function Control()&#123; this.snake = null; // 按钮的事件绑定 this.bindClick = function()&#123; var that = this; $(document).on(&#x27;keydown&#x27;, function(e)&#123; if(!that.snake) return; var canChangrDir = true; switch(e.keyCode)&#123; case Direction.DOWN: if(that.snake.dir == Direction.UP)&#123; canChangrDir = false; &#125; break; case Direction.UP: if(that.snake.dir == Direction.DOWN)&#123; canChangrDir = false; &#125; break; case Direction.LEFT: if(that.snake.dir == Direction.RIGHT)&#123; canChangrDir = false; &#125; break; case Direction.RIGHT: if(that.snake.dir == Direction.LEFT)&#123; canChangrDir = false; &#125; break; default: canChangrDir = false; break; &#125; if(canChangrDir)&#123; that.snake.dir = e.keyCode; &#125; &#125;); $(&#x27;#palSize&#x27;).on(&#x27;change&#x27;,function()&#123; settings.pannelSize = $(this).val(); setPannel(settings.pannelSize); &#125;); $(&#x27;#palSpeed&#x27;).on(&#x27;change&#x27;,function()&#123; settings.speed = $(this).val(); &#125;); $(&#x27;#startBtn&#x27;).on(&#x27;click&#x27;,function()&#123; $(&#x27;.food&#x27;).removeClass(&#x27;food&#x27;); $(&#x27;.body&#x27;).removeClass(&#x27;body&#x27;); that.startGame(); &#125;); &#125;; // 初始化 this.init = function()&#123; this.bindClick(); setPannel(settings.pannelSize); &#125;; // 开始游戏 this.startGame = function()&#123; var food = new Food(); food.Create(); var snake = new Snake(food); snake.Create(); this.snake =snake; settings.workThread = setInterval(function()&#123; snake.Move(); &#125;,settings.speed); &#125; this.init();&#125; 我们给document绑定一个keydown事件，当触发按键时改变蛇的移动方向，但是如果和当前蛇移动方向相反时就直接return。最后的效果如下：可以戳这里查看实现效果 总结 实现了贪吃蛇的一些基本功能，比如移动、吃点、控制速度等，页面也比较的简单，就一个table、select和button。后期可以添加一些其他的功能，比如有计分、关卡等，也可以添加多个点，有的点吃完直接GameOver等等。","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"游戏","slug":"Game","permalink":"http://xieyufei.com/tags/Game/"}]},{"title":"精巧快速的前端模板引擎doT","date":"2017-02-21T13:33:49.000Z","path":"2017/02/21/Dotjs-Usage.html","text":"在没有接触模板引擎之前，我们接受后台传来的json数据后需要将其拼接成字符串，然后将其插入到DOM中去，如果有一些复杂的业务逻辑，拼接代码会变得更加的繁琐，而且后期维护起来也十分的不方便。后来在项目中接触到一款十分强大的模板引擎，就是我们的doT，被它强大的功能深深的吸引住了。尤其在1.0.0版本后还新增了局部模板的功能，可扩展性非常的强大。刚开始看官方的文档时对局部模板这个功能还不是很懂，后来在网上搜寻了各种资料，才豁然开朗，分享一下自己的心得体会。 介绍 doT模板引擎是一个最快速最简洁的JavaScript模板引擎，在浏览器端和Nodejs端都适用。它小巧快速并且没有任何依赖，所有代码才一百多行，压缩后才4k，非常的轻量。 配置 在doT文件中有一个templateSettings属性用来配置doT的定界符（官方文档这么称呼，我们可以理解为模板的语法），我们也可以手动修改使用自己的定界符，但是建议使用默认的： 12345678910111213141516171819templateSettings: &#123; evaluate: /\\&#123;\\&#123;([\\s\\S]+?(\\&#125;?)+)\\&#125;\\&#125;/g, interpolate: /\\&#123;\\&#123;=([\\s\\S]+?)\\&#125;\\&#125;/g, encode: /\\&#123;\\&#123;!([\\s\\S]+?)\\&#125;\\&#125;/g, use: /\\&#123;\\&#123;#([\\s\\S]+?)\\&#125;\\&#125;/g, useParams: /(^|[^\\w$])def(?:\\.|\\[[\\&#x27;\\&quot;])([\\w$\\.]+)(?:[\\&#x27;\\&quot;]\\])?\\s*\\:\\s*([\\w$\\.]+|\\&quot;[^\\&quot;]+\\&quot;|\\&#x27;[^\\&#x27;]+\\&#x27;|\\&#123;[^\\&#125;]+\\&#125;)/g, define: /\\&#123;\\&#123;##\\s*([\\w\\.$]+)\\s*(\\:|=)([\\s\\S]+?)#\\&#125;\\&#125;/g, defineParams:/^\\s*([\\w$]+):([\\s\\S]+)/, conditional: /\\&#123;\\&#123;\\?(\\?)?\\s*([\\s\\S]*?)\\s*\\&#125;\\&#125;/g, iterate: /\\&#123;\\&#123;~\\s*(?:\\&#125;\\&#125;|([\\s\\S]+?)\\s*\\:\\s*([\\w$]+)\\s*(?:\\:\\s*([\\w$]+))?\\s*\\&#125;\\&#125;)/g, varname: &quot;it&quot;, // 控制空白字符，true - 全部去掉，false - 保留 strip: true, // 性能优化设置，通过它调整性能，append 设置成 false，可能会产生更好的效果 append: true, // 如果 &#x27;selfcontained&#x27; 为 true，doT 将毫无依赖的产生函数 selfcontained: false, doNotSkipEncoded: false&#125;, 在配置中有一个属性是varname，它的值是it，代表了在模板中传入对象所使用的变量名。 用法 首先介绍一下doT模板中常用的定界符代表的使用和含义： 1234567&#123;&#123;= &#125;&#125; 用于插值(interpolation)&#123;&#123; &#125;&#125; 用于求值(evaluation)&#123;&#123;? &#125;&#125; 条件语句&#123;&#123;~ &#125;&#125; 数组迭代&#123;&#123;! &#125;&#125; 用于编码求值&#123;&#123;# &#125;&#125; 用于编译时求值/引入和局部模板&#123;&#123;## #&#125;&#125; 用于编译时定义 赋值定界符 首先定义要赋值的模板，注意模板的type要写成text/x-dot-template。 1234&lt;script id=&quot;templ1&quot; type=&quot;text/x-dot-template&quot;&gt; &lt;div&gt;Hi &#123;&#123;=it.name&#125;&#125;!&lt;/div&gt; &lt;div&gt;Your age is &#123;&#123;=it.age || &#x27;&#x27;&#125;&#125;&lt;/div&gt;&lt;/script&gt; 在这里我们使用了的赋值定界符，用于在模板中进行赋值操作。这里使用的it就是我们在上面配置中定义好的varname变量。然后在JS中调用模板渲染到页面上去： 1234var person = &#123;&#x27;name&#x27;:&#x27;ace&#x27;,&#x27;age&#x27;:20&#125;, person1 = &#123;&#x27;name&#x27;:&#x27;john&#x27;,&#x27;age&#x27;:21&#125;;var doTemplate = doT.template($(&#x27;#templ1&#x27;).html());$(&#x27;body&#x27;).html(doTemplate(person)+doTemplate(person1)); 在这里我们获取到了模板函数doTemplate，然后将定义好的对象传入函数中，最后返回我们所需要的字符串插入到DOM中。这里我们对doTemplate函数进行了一次复用，定义了两个属性相同字面量传入。 求值定界符 如果传入到模板中的是一个对象，我们还可以通过求值定界符遍历输入对象中的属性： 12345&lt;script id=&quot;templ2&quot; type=&quot;text/x-dot-template&quot;&gt;&#123;&#123; for(var prop in it) &#123; &#125;&#125;&lt;div&gt;key:&#123;&#123;= prop &#125;&#125; --- value:&#123;&#123;= it[prop] &#125;&#125;&lt;/div&gt;&#123;&#123; &#125; &#125;&#125;&lt;/script&gt; 在求值定界符中，我们可以写类似于js的语法。 123var dataEval = &#123;&quot;name&quot;:&quot;ace&quot;,&quot;age&quot;:20,&quot;interests&quot;:&quot;basketball&quot;,&quot;email&quot;:&quot;ace@ly.com&quot;,&quot;phone&quot;:&quot;110&quot;&#125;;var evalText = doT.template($(&quot;#templ2&quot;).html());$(&#x27;body&#x27;).html(evalText(dataEval)); 迭代定界符 有时候我们需要遍历对象中的数组，通过迭代定界符来遍历。但是要在但是需要在后面加上:value:index表示数组中的每个元素和索引值。 12345&lt;script id=&quot;templ3&quot; type=&quot;text/x-dot-template&quot;&gt;&#123;&#123;~it.array:value:index&#125;&#125; &lt;div&gt;index:&#123;&#123;= index+1 &#125;&#125;--value:&#123;&#123;= value &#125;&#125;!&lt;/div&gt;&#123;&#123;~&#125;&#125;&lt;/script&gt; 在这里我们传入的是一个对象，所以需要用~it.array来遍历我们的数组。 123var dataArr = &#123;&quot;array&quot;:[&quot;banana&quot;,&quot;apple&quot;,&quot;orange&quot;]&#125;;var arrText = doT.template($(&quot;#templ3&quot;).html());$(&#x27;body&#x27;).html(arrText(dataArr)); 我们可以直接传入一个数组，遍历的时候就需要用~it直接来遍历数组值。 条件定界符 在模板中有时候我们需要对数据进行判断，进行不同的展示，这时我们就需要用到条件定界符。 1234567891011121314151617&lt;script id=&quot;templ4&quot; type=&quot;text/x-dot-template&quot;&gt; &lt;div&gt;姓名：&#123;&#123;=it.name&#125;&#125;&lt;/div&gt; &lt;div&gt;成绩：&#123;&#123;=it.score&#125;&#125;&lt;/div&gt; &#123;&#123;? it.score&lt;60&#125;&#125; &lt;div&gt;等级：不及格&lt;/div&gt; &#123;&#123;?? it.score&lt;70&#125;&#125; &lt;div&gt;等级：及格&lt;/div&gt; &#123;&#123;?? it.score&lt;80&#125;&#125; &lt;div&gt;等级：良好&lt;/div&gt; &#123;&#123;?? it.score&lt;90&#125;&#125; &lt;div&gt;等级：优秀&lt;/div&gt; &#123;&#123;?? it.score&lt;100&#125;&#125; &lt;div&gt;等级：棒极了&lt;/div&gt; &#123;&#123;??&#125;&#125; &lt;div&gt;等级：数据有误&lt;/div&gt; &#123;&#123;?&#125;&#125;&lt;/script&gt; 条件模板前后都用单问号包裹，中间的双问号表示else。 123var student = &#123;&#x27;name&#x27;:&#x27;ace&#x27;,&#x27;score&#x27;:82&#125;var conditionText = doT.template($(&#x27;#templ4&#x27;).html());$(&#x27;body&#x27;).html(conditionText(student)) 对于条件判断，我们还可以使用求值定界符，对上面的进行如下改写： 1234567891011121314151617&lt;script id=&quot;templ4&quot; type=&quot;text/x-dot-template&quot;&gt; &lt;div&gt;姓名：&#123;&#123;=it.name&#125;&#125;&lt;/div&gt; &lt;div&gt;成绩：&#123;&#123;=it.score&#125;&#125;&lt;/div&gt; &#123;&#123; if(it.score&lt;60) &#123; &#125;&#125; &lt;div&gt;等级：不及格&lt;/div&gt; &#123;&#123; &#125; else if(it.score&lt;70) &#123; &#125;&#125; &lt;div&gt;等级：及格&lt;/div&gt; &#123;&#123; &#125; else if(it.score&lt;80) &#123; &#125;&#125; &lt;div&gt;等级：良好&lt;/div&gt; &#123;&#123; &#125; else if(it.score&lt;90) &#123; &#125;&#125; &lt;div&gt;等级：优秀&lt;/div&gt; &#123;&#123; &#125; else if(it.score&lt;100) &#123; &#125;&#125; &lt;div&gt;等级：棒极了&lt;/div&gt; &#123;&#123; &#125; else &#123; &#125;&#125; &lt;div&gt;等级：数据有误&lt;/div&gt; &#123;&#123; &#125; &#125;&#125;&lt;/script&gt; 模板定界符（doT新增功能） 在1.0.0之后的版本，doT加入的局部模板的功能，我们在模板中还可以定义一个局部模板。在主模板和子模板中我们都可以通过it变量引用到传入的对象。 1234567891011&lt;script id=&quot;templ6&quot; type=&quot;text/x-dot-template&quot;&gt;// 定义主模板&#123;&#123;##def.father: &lt;div&gt;主模板：&#123;&#123;=it.name&#125;&#125;&lt;/div&gt; 子模板1：&#123;&#123;#def.child1&#125;&#125; 子模板2：&#123;&#123;#def.child2&#125;&#125;#&#125;&#125;// 编译时输入主模板&#123;&#123;#def.father&#125;&#125;&#123;&#123;=it.html&#125;&#125;&lt;/script&gt; 首先通过两个#定义一个编译的需要引入局部模板的主模板def.father，在它里面定义了两个子模板def.child1和def.child2，然后通过一个#在编译时输入我们的主模板。如果没有这段输入代码，那么最后在编译时doT不会帮我们输出主模板的。 1234567891011var dataPart = &#123; &quot;name&quot;:&quot;Corner&quot;, &quot;age&quot;:31, &quot;html&quot;:&quot;&lt;div style=&#x27;background: #f00; height: 30px; line-height: 30px;&#x27;&gt;html元素&lt;/div&gt;&quot;&#125;;var defPart = &#123; &quot;child1&quot;:&quot;&lt;div&gt;&#123;&#123;=it.name&#125;&#125; who?&lt;/div&gt;&quot;, &quot;child2&quot;:&quot;&lt;div&gt;&#123;&#123;=it.name&#125;&#125; how?&lt;/div&gt;&quot;&#125;;var partText = doT.template($(&quot;#templ6&quot;).html(), undefined, defPart);$(&quot;body&quot;).html(partText(dataPart)); 在JS中我们首先定义需要传入的数据，然后定义一个子模板的对象。这个对象中包含了我们在模板中定义的两个子模板的名称和内容，在子模板内容中，我们还是通过it变量引用到传入的对象。然后在生成模板函数时我们将子模板的对象一起传给template。","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"推荐","slug":"Recommend","permalink":"http://xieyufei.com/tags/Recommend/"}]},{"title":"理解JS模块化","date":"2017-02-19T11:33:22.000Z","path":"2017/02/19/JS-Standard.html","text":"模块化在项目中十分的重要，一个复杂的项目肯定有很多相似的功能模块，如果每次都需要重新编写模块肯定既费时又耗力。但是引用别人编写模块的前提是要有统一的“打开姿势”，如果每个人有各自的写法，那么肯定会乱套，下面介绍几种JS的模块化的规范。 模块化进程一：script标签 这是最原始的 JavaScript 文件加载方式，如果把每一个文件看做是一个模块，那么他们的接口通常是暴露在全局作用域下，也就是定义在 window 对象中，不同模块的接口调用都是一个作用域中，一些复杂的框架，会使用命名空间的概念来组织这些模块的接口。 缺点:1、污染全局作用域2、开发人员必须主观解决模块和代码库的依赖关系3、文件只能按照script标签的书写顺序进行加载4、在大型项目中各种资源难以管理，长期积累的问题导致代码库混乱不堪 模块化进程二：CommonJS规范 该规范的核心思想是允许模块通过require方法来同步加载所要依赖的其他模块，然后通过exports或module.exports来导出需要暴露的接口。 1234require(&quot;module&quot;);require(&quot;../file.js&quot;);exports.doStuff = function() &#123;&#125;;module.exports = someValue; 优点：1、简单并容易使用2、服务器端模块便于重用 缺点:1、同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的2、不能非阻塞的并行加载多个模块 module.exports与exports的区别1、exports 是指向的 module.exports 的引用2、module.exports 初始值为一个空对象 {}，所以 exports 初始值也是 {}3、require() 返回的是 module.exports 而不是 exports exports示例： 12345678// app.jsvar circle = require(&#x27;./circle&#x27;);console.log(circle.area(4));// circle.jsexports.area = function(r) &#123; return r * r * Math.PI;&#125; module.exports示例： 12345678// app.jsvar area = require(&#x27;./area&#x27;);console.log(area(4));// area.jsmodule.exports = function(r) &#123; return r * r * Math.PI;&#125; 错误的情况： 12345678// app.jsvar area = require(&#x27;./area&#x27;);console.log(area(4));// area.jsexports = function(r) &#123; return r * r * Math.PI;&#125; 其实是对 exports 进行了覆盖，也就是说 exports 指向了一块新的内存（内容为一个计算圆面积的函数），也就是说 exports 和 module.exports 不再指向同一块内存，也就是说此时 exports 和 module.exports 毫无联系，也就是说 module.exports 指向的那块内存并没有做任何改变，仍然为一个空对象{}，也就是说area.js导出了一个空对象，所以我们在 app.js 中调用 area(4) 会报 TypeError: object is not a function 的错误。 总结：当我们想让模块导出的是一个对象时， exports 和 module.exports 均可使用（但 exports 也不能重新覆盖为一个新的对象），而当我们想导出非对象接口时，就必须也只能覆盖 module.exports 。 模块化进程三：AMD规范 由于浏览器端的模块不能采用同步的方式加载，会影响后续模块的加载执行，因此AMD(Asynchronous Module Definition异步模块定义)规范诞生了。 AMD标准中定义了以下两个API1、require([module], callback);2、define(id, [depends], callback);require接口用来加载一系列模块，define接口用来定义并暴露一个模块。 示例： 1234define(&quot;module&quot;, [&quot;dep1&quot;, &quot;dep2&quot;], function(d1, d2) &#123; return someExportedValue;&#125;);require([&quot;module&quot;, &quot;../file&quot;], function(module, file) &#123; /* ... */ &#125;); 优点：1、适合在浏览器环境中异步加载模块2、可以并行加载多个模块 缺点：1、提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不顺畅2、不符合通用的模块化思维方式，是一种妥协的实现 模块化进程四：CMD规范 CMD(Common Module Definition)规范和AMD很相似，尽量保持简单，并与CommonJS和Node.js的 Modules 规范保持了很大的兼容性。在CMD规范中，一个模块就是一个文件。 示例： 123456define(function(require, exports, module) &#123; var $ = require(&#x27;jquery&#x27;); var Spinning = require(&#x27;./spinning&#x27;); exports.doSomething = ... module.exports = ...&#125;) 优点：1、依赖就近，延迟执行2、可以很容易在 Node.js 中运行 缺点：1、依赖 SPM 打包，模块的加载逻辑偏重 AMD和CMD的区别 AMD和CMD起来很相似，但是还是有一些细微的差别，让我们来看一下他们的区别在哪里：1、对于依赖的模块，AMD是提前执行，CMD是延迟执行。2、AMD推崇依赖前置；CMD推崇依赖就近，只有在用到某个模块的时候再去require。看代码： 123456789101112131415161718// AMDdefine([&#x27;./a&#x27;, &#x27;./b&#x27;], function(a, b) &#123; // 依赖必须一开始就写好 a.doSomething() // 此处略去 100 行 b.doSomething() ...&#125;);// CMDdefine(function(require, exports, module) &#123; var a = require(&#x27;./a&#x27;) a.doSomething() // 此处略去 100 行 var b = require(&#x27;./b&#x27;) // 依赖可以就近书写 b.doSomething() // ... &#125;); 3、AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。 模块化进程五：ES6模块化 EcmaScript6标准增加了JavaScript语言层面的模块体系定义。ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。 在 ES6 中，我们使用export关键字来导出模块，使用import关键字引用模块。需要说明的是，ES6的这套标准和目前的标准没有直接关系，目前也很少有JS引擎能直接支持。因此Babel的做法实际上是将不被支持的import翻译成目前已被支持的require。 尽管目前使用import和require的区别不大(本质上是一回事)，但依然强烈推荐使用import关键字，因为一旦JS引擎能够解析ES6的import关键字，整个实现方式就会和目前发生比较大的变化。如果目前就开始使用import关键字，将来代码的改动会非常小。 示例： 123import &quot;jquery&quot;;export function doStuff() &#123;&#125;module &quot;localModule&quot; &#123;&#125; 优点：1、容易进行静态分析2、面向未来的 EcmaScript 标准 优点：1、原生浏览器端还没有实现该标准2、全新的命令字，新版的 Node.js才支持","tags":[{"name":"面试","slug":"Interview","permalink":"http://xieyufei.com/tags/Interview/"},{"name":"模块化","slug":"Modularization","permalink":"http://xieyufei.com/tags/Modularization/"}]},{"title":"对程序员的一个Promise（二）","date":"2017-01-28T07:47:12.000Z","path":"2017/01/28/FrontEnd-Promise-jQuery.html","text":"在上一篇文章《对程序员的一个Promise（一）》中，分享了一下了ES6中Promise的用法，但是需要浏览器支持Promise。在jQuery中也有Promise，就让我来看看jQuery中的Promise是怎么用的。 jQuery中的Promise 在jQuery中，首先要通过Deferred方法获取到Deferred对象，让我们来打印出来看看它有什么方法。 12var d = $.Deferred();console.log(d); 最后输出如下： 我们可以看到$.Deferred()返回是一个对象（Deferred对象），也有resolve、then、reject等一些我们熟悉的方法，让我们来看看它是怎么用的。 基本用法12345678910111213function getPromise1()&#123; var d = $.Deferred(); setTimeout(() =&gt; &#123; console.log(&#x27;异步1结束&#x27;); d.resolve(&#x27;异步1数据&#x27;); &#125;, 200); return d;&#125;var def = getPromise1();def.then((data) =&gt; &#123; console.log(data);&#125;); 感觉跟ES6中Promise的用法很相似。我们首先通过$.Deferred()获取到了Deferred对象，然后在异步成功后返回数据，然后在then方法中对异步数据进行处理。 但是跟ES6中不一样的是，异步没有放到Promise的构造函数中，在异步成功后，调用了Deferred对象的resolve方法。then方法处理回调数据还是一样的。 发现问题 既然Deferred对象上有resolve()方法，那么是不是在外部就能够调用resolve()方法就能够修改Promise的状态呢。把上面的代码进行如下改写： 12345678910111213function getPromise1()&#123; var d = $.Deferred(); setTimeout(() =&gt; &#123; console.log(&#x27;异步1结束&#x27;); d.resolve(&#x27;异步1数据&#x27;); &#125;, 300); return d;&#125;var def = getPromise1();def.then((data) =&gt; &#123; console.log(data);&#125;);def.resolve(&#x27;外部数据1&#x27;); 输出结果如下： 可以看到我们在函数的外面调用了resolve()方法提前让异步结束并且返回了数据。这样Promise的状态就能够被随意的改变，肯定是不行的。 解决问题 将代码进行如下改进，在返回的对象上多加一个promise()方法： 12345678910111213function getPromise1()&#123; var d = $.Deferred(); setTimeout(() =&gt; &#123; console.log(&#x27;异步1结束&#x27;); d.resolve(&#x27;异步1数据&#x27;); &#125;, 300); return d.promise();&#125;var def = getPromise1();def.then((data) =&gt; &#123; console.log(data);&#125;);def.resolve(&#x27;外部数据1&#x27;); 输出结果如下： 这时候，如果在函数的外部调用resolve()方法会报错，告诉我们resolve()方法不存在，异步也会“如期”执行完成。如果我们将def对象打印出来看的话会发现并没有resolve()方法。 成功和失败的回调 和ES6中的Promise相似，then也支持接收两个参数，分别是执行成功的回调和执行失败的回调。 123456789101112131415161718192021222324function getPromise1()&#123; var d = $.Deferred(); setTimeout(() =&gt; &#123; var number = Math.round(Math.random()*10); if(number %2 == 0) &#123; d.resolve(&#x27;成功数据&#x27;); &#125; else &#123; d.reject(&#x27;失败数据&#x27;); &#125; &#125;, 300); return d.promise();&#125;var def = getPromise1();def.then( (data) =&gt; &#123; console.log(&#x27;成功回调&#x27;); console.log(data); &#125;, (data) =&gt; &#123; console.log(&#x27;失败回调&#x27;); console.log(data); &#125;) 除此之外，jQuery还新增了两个函数，done()和fail()分别用来指定成功的回调和失败的回调。因此，上面的代码和下面的代码是等价的： 123456789var def = getPromise1();def.done((data) =&gt; &#123; console.log(&#x27;成功回调&#x27;); console.log(data);&#125;);def.fail((data) =&gt; &#123; console.log(&#x27;失败回调&#x27;); console.log(data);&#125;); 链式调用 既然是Promise，那么then()肯定也支持链式调用的，这边也不在赘述，跟ES6中是一样的用法，不太熟悉的可以戳这边《对程序员的一个Promise（一）》 扩展函数 jQuery中没有all和race方法，但是扩展了一些其他的方法。 always方法 always方法就是不管执行成功或者失败，都会执行的，有点类似ajax的complete方法。 123456789101112var def = getPromise1();def.done((data) =&gt; &#123; console.log(&#x27;成功回调&#x27;); console.log(data);&#125;);def.fail((data) =&gt; &#123; console.log(&#x27;失败回调&#x27;); console.log(data);&#125;);def.always(() =&gt; &#123; console.log(&#x27;总是执行&#x27;)&#125;) when方法 when方法和ES6中的all方法功能一样，都是并行执行异步，所有异步执行完成后才执行回调函数。不过when方法是挂载在全局中的方法，而且，它接受的参数也是多个对象。 1234567891011121314151617181920212223242526function getPromise1()&#123; var d = $.Deferred(); setTimeout(() =&gt; &#123; d.resolve(&#x27;成功数据1&#x27;); &#125;, 100); return d.promise();&#125;function getPromise2()&#123; var d = $.Deferred(); setTimeout(() =&gt; &#123; d.resolve(&#x27;成功数据2&#x27;); &#125;, 200); return d.promise();&#125;function getPromise3()&#123; var d = $.Deferred(); setTimeout(() =&gt; &#123; d.resolve(&#x27;成功数据3&#x27;); &#125;, 300); return d.promise();&#125;$.when(getPromise1(), getPromise2(), getPromise3()).then((data1,data2,data3) =&gt; &#123; console.log(&#x27;执行完成&#x27;); console.log(data1, data2, data3);&#125;) 理解ajax的本质 平时我们都是这么请求ajax异步的： 123456789$.ajax(&#123; url:&#x27;test.json&#x27;, success:function(data)&#123; // ... &#125;, error:function(data)&#123; // ... &#125;&#125;); 上面的代码，平时的工作中我们肯定也写了无数遍了，已经很熟悉了，但是这个ajax()方法返回的是什么呢，让我们打印出来看下: 难道是巧合么？我们看到了熟悉的always()、done()、fail()、promise()、then()等方法。没错，ajax返回的也是一个Deferred对象，既然是Deferred对象，那么肯定也支持链式调用了。 那么将ajax方法进行如下改写： 12345678function getAjax1()&#123; var def = $.ajax(&#123;url:&#x27;test.json&#x27;&#125;); return def.promise();&#125;var def1 = getAjax1();def1.then((data) =&gt; &#123; console.log(data);&#125;); 既然是Deferred对象，那么done()、fail()、$.when()这些方法也能使用，这里就不再赘述了。","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"推荐","slug":"Recommend","permalink":"http://xieyufei.com/tags/Recommend/"},{"name":"Promise","slug":"Promise","permalink":"http://xieyufei.com/tags/Promise/"}]},{"title":"对程序员的一个Promise（一）","date":"2017-01-20T18:26:42.000Z","path":"2017/01/21/FrontEnd-Promise.html","text":"在日常的工作中经常会遇到需要请求多次异步的情况，但是由于异步返回时间的不确定性，因此有时候会给我们带来很多的问题和麻烦。在我们被异步嵌套的头昏脑胀的时候，我们是多么希望JS能够像JAVA一样是同步执行的。带着这样解决问题的信念，笔者学习了一下Promise，发现还挺好用的，写一下笔者的使用心得。 Promise在英文中的解释就是承诺，在爱情中时常用来表示比较罗曼蒂克的憧憬，但是在JS中没有这么浪漫，只是单纯地表示无论操作成功或者失败,一定会给出一个“反馈”。 就好比媳妇喊你去街上打酱油，最后只有两种可能性，一种可能性是你成功的打到了酱油，回来给她了；另一种可能性就是酱油卖光或者其他原因，然后你没有打到酱油，但是你还是会跑去跟你媳妇汇报，然后你媳妇就会在心里默默的想下面这张图： ES6中的Promise 咳咳，有点扯远了，那么首先让我们用console来揭开Promise的真正面目吧。 什么是Promise 通过控制台打印出来，我们看到原来Promise其实是一个构造函数，它的构造函数上有resolve和reject等其他几个方法，原型上也有then、catch等方法。既然是构造函数，那么肯定是能够通过new来创建一个对象的。 Promise的特点 介绍了Promise，那么来说一下它的两个特点吧。 对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成）和 Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。 说了这么多，相信笔者也迫不及待了，先来构建一个Promise看看吧。 构建一个Promise1234567891011function getPromise1() &#123; var p = new Promise((resolve, reject) =&gt; &#123; // 这里放一些异步操作 setTimeout(() =&gt; &#123; console.log(&#x27;异步1执行完成&#x27;); resolve(&#x27;异步1返回数据&#x27;); &#125;, 1000); &#125;); return p;&#125;getPromise1(); 看到这里读者肯定觉得跟以前比没有很大的变化，而且有很多的困惑，比如： 为什么Promise外层要包一个函数把它return出去，直接创建对象不就行了么。 Promise的构造函数传入一个函数，这个函数接受两个参数，这两个参数有什么用。 运行上面的代码，控制台就会打印”异步1执行完成”。我们只是构造了一个Promise的对象，并没有调用它里面的方法，就已经执行了，所以这就是为什么要将Promise放到函数中调用获取的原因。同时，使用一个函数返回对象更加符合函数式编程的思想。这边的resolve方法的作用就是将Promise对象从Pending状态置为Resolved状态。 异步数据处理12345getPromise1().then((data) =&gt; &#123; // 一些业务逻辑处理 console.log(data);&#125;); getPromise1方法获取到的就是我们上面返回的Promise对象，直接调用then方法，表示在异步结束后调用此方法。它接受一个参数，是一个函数，这个函数默认会传入一个参数，这个参数就是我们在Promise构造函数中所调用的resolve所传入的异步数据。 感情绕了一大圈，其实就是把原有在异步完成后的业务逻辑单独抽离出一个方法么？其实Promise还能做更多。 我有多个异步 如果这个时候来了一个需求，这个异步的数据不够，还需要发另外一个异步。如果按照以前的逻辑肯定是在then回调方法的继续来发异步，然后就陷入了恶(e)性(xin)的嵌套，如果业务逻辑很复杂，而且还需要发异步，那么这个函数里面代码也会越来越庞大，后期维护起来会非常的麻烦。但是Promise的出现拯救了这一切。 Promise的优势在于能够进行链式的调用，将原来嵌套调用转为线性调用。在then方法中继续返回一个新的Promise对象，然后能够继续调用then方法。 123456789101112131415161718192021222324252627282930313233getPromise1().then((data) =&gt; &#123; console.log(data); return getPromise2();&#125;).then((data) =&gt; &#123; console.log(data); return getPromise3();&#125;).then((data) =&gt; &#123; console.log(data);&#125;);function getPromise2() &#123; var p = new Promise((resolve, reject) =&gt; &#123; // 这里放一些异步操作 setTimeout(() =&gt; &#123; console.log(&#x27;异步2执行完成&#x27;); resolve(&#x27;异步2返回数据&#x27;); &#125;, 2000); &#125;); return p;&#125;function getPromise3() &#123; var p = new Promise((resolve, reject) =&gt; &#123; // 这里放一些异步操作 setTimeout(() =&gt; &#123; console.log(&#x27;异步3执行完成&#x27;); resolve(&#x27;异步3返回数据&#x27;); &#125;, 3000); &#125;); return p;&#125; 我们会看到每隔一秒、两秒、三秒就会打印一组“执行完成n和返回数据n”。在then方法中也可以不返回一个Promise对象，直接返回数据。将上面的代码如下改写： 123456789101112getPromise1().then((data) =&gt; &#123; console.log(data); return data;&#125;).then((data) =&gt; &#123; console.log(data); return data;&#125;).then((data) =&gt; &#123; console.log(data);&#125;); 最后可以看到，一秒之后打印了一次执行完成1和三次返回数据1。这样的then方法没有什么意义。 reject方法 细心的读者可能发现了，在Promise的构造方法中还有一个reject方法还没有被用到。既然是异步，那么肯定有成功也有失败的时候，reject方法的作用是将Promise对象的状态置为Rejected状态，在then方法中执行失败情况的回调函数。 12345678910111213141516171819202122function getPromise4() &#123; var p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; var number = Math.round(Math.random()*10); if(number %2 == 0) &#123; resolve(&#x27;成功数据&#x27;); &#125; else &#123; reject(&#x27;失败数据&#x27;) &#125; &#125;, 100); &#125;); return p;&#125;getPromise4().then( (data) =&gt; &#123; console.log(&#x27;成功回调：&#x27; + data); &#125;, (data) =&gt; &#123; console.log(&#x27;失败回调：&#x27; + data); &#125;) 我们首先获取一个随机数，判断这个随机数是否是偶数，如果是偶数的话就进入成功的回调方法；如果失败了就进入失败的回调方法。在then方法中我们发现多传入了一个方法，第一个方法还是成功情况的回调，第二个方法就是失败情况的回调，可以不传，不传的话就默认只有成功的回调。 但是需要注意的是，如果不传失败的回调函数，但是同时你还调用了reject方法，这时候Promise内部会报错。 进阶方法 在Promise对象上还有一些其他方法。 catch方法 在Promise的原型上还有一个catch方法，我们知道try/catch方法是用来捕捉异常的，Promise中的catch方法也可以做同样的事情。将上面的方法进行如下改写： 1234567891011121314getPromise4().then( (data) =&gt; &#123; console.log(&#x27;成功回调：&#x27; + data); console.log(temp); &#125;, (data) =&gt; &#123; console.log(&#x27;失败回调：&#x27; + data); console.log(temp); &#125;).catch((err)=&gt;&#123; console.log(&#x27;捕获异常&#x27;,err);&#125;) 在执行Promise的回调方法时可能会进入到第一个成功的回调函数中也可能会进入到第二个失败的回调函数中，如果回调函数中有抛出异常，并不会因为这个异常而卡死程序，就会进入到catch方法中捕捉到异常。最终运行的效果有以下两种可能性： all方法 Promise中还有一个all方法，all是全部的意思，因此我们能猜测，就是等所有的异步都执行完毕。all方法让Promise有并行执行异步的能力，等所有并行异步执行完成后才执行回调。 1234Promise.all([getPromise1(),getPromise2(),getPromise3()]).then((results) =&gt; &#123; console.log(&#x27;所有异步结束&#x27;, results)&#125;); 可以看到all接受一个Promise的数组，数组中是三个Promise对象。在第一个和第二个异步执行完成后都没有进入then方法，而是等最后一个最慢的异步执行完了才进入then方法。最终，所有异步操作的结果都通过then方法的参数以数组的形式传递进来。最终运行效果如下： 但是问题来了，如果多个异步中有一个异步执行失败了呢？如果这个异步失败是通过reject方法抛出的，那么此时其他Pending中的异步还是会继续去运行，但是这个时候就会提前进入then方法的第二个参数函数中去，这个函数的默认参数也只是这个失败异步reject所发送的数据（不一定还是数组），等其他异步执行完成也不会再去执行then方法了。 race方法 all方法执行的效果是等大家都结束了再运行，但是race是赛跑、竞争的意思，那么就很明显了，就是谁跑的快就有肉吃。将上面的代码进行改写： 1234Promise.race([getPromise1(),getPromise2(),getPromise3()]).then((results) =&gt; &#123; console.log(&#x27;results&#x27;, results)&#125;); 这三个异步同样是并行执行的，但是race的then方法优先执行先完成的异步。第一个异步getPromise1先执行完，因此先进入then方法。此时getPromise2和getPromise3还没有执行完，还会继续执行，但是不会再去执行then方法了。最后执行结果如下： 总结 本文中介绍的所有异步操作均以setTimeout作为例子，如果有不正确的地方欢迎指正。","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"推荐","slug":"Recommend","permalink":"http://xieyufei.com/tags/Recommend/"},{"name":"Promise","slug":"Promise","permalink":"http://xieyufei.com/tags/Promise/"}]},{"title":"服务器开启GZIP","date":"2017-01-08T02:25:00.000Z","path":"2017/01/08/SERVER-OPEN-GZIP.html","text":"开始接触GZIP压缩是在工作中上传lodash脚本文件到服务器上。本来压缩版的脚本也有七十几KB，但是笔者的同事说上传到服务器上只有二十多KB，笔者半信半疑，怎么会有这么大的差距，服务器压缩的幅度也太大了。后来网上找了很多资料，发现GZIP确实能够节省传输过程中很多的流量。 GZIP介绍 什么是GZIP gzip是GNUzip的缩写，是一个GUN自由软件的文件压缩程序。刚开始用于UNIX系统的文件压缩。熟悉Linux系统的读者应该了解有一种文件的后缀是.gz，这种文件就是GZIP格式的文件。现在GZIP已经成为网上使用非常普遍的一种数据压缩格式。 工作原理 既然GIZP是一种数据压缩格式，那么它是如何在浏览器和服务器之间进行数据传输的呢。通过下面一张图片能够很清晰的看出它的工作方式： 首先浏览器发出一个请求给服务器，在请求头上标明自己可以接收GZIP格式的数据。 然后服务器根据请求头，将数据经过压缩后返回给浏览器，同时在响应头上标明返回的数据是GZIP格式的数据。 最后浏览器将返回的数据解压后渲染。 浏览器中查看 笔者模拟了一个GZIP数据请求： 可以看到Request Headers（请求头）中有一个Accept-Encoding属性，里面有一个gzip，表示浏览器能够接受的数据格式有：gzip、deflate、sdch和br。然后在Response Headers（响应头）中有一个Content-Encoding属性，表示返回的数据格式的编码，我们看到只有一种编码，就是gzip。 优势 减小网络传输的数据量，提高网页响应速度。 服务器中如何开启GZIPTomcat 经过在网上找了很多资料，找到目录下的conf/server.xml文件，将Connector进行如下改写： 123456789&lt;Connector port=&quot;8088&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; URIEcoding=&quot;UTF-8&quot; compression=&quot;on&quot; //打开压缩功能 compressionMinSize=&quot;2048&quot; //启用压缩的输出内容大小，这里面默认为2KB noCompressionUserAgents=&quot;gozilla, traviata&quot; //对于以下的浏览器，不启用压缩 compressableMimeType=&quot;text/html,text/xml,text/javascript,text/css,text/plain,image/png,image/jpg,image/gif&quot; //压缩类型 /&gt; 问题出现 但是。。。当笔者配置完后，满心欢喜的打开服务器以为有效时，发现自己太天真了。很遗憾的是，脚本并没有被压缩。我以为是服务器没有配置成功，又多次重启，但是并没有用，网上查了很多资料，也没有解决。 解决问题 笔者发现同样是CSS却是有效的，为什么脚本不行呢？但是脚本占了网络流量的很大一部分。 当笔者再次仔细查看Response Headers的时候，发现Content-Type这个属性竟然是application/javascript，但是在我们的代码中配置的却是text/javascript，会不会是这个问题呢。 笔者抱着试一下的态度，在compressableMimeType属性中添加了application/javascript。最后再次启动服务器，OK，问题解决了。 Nodejs Nodejs中笔者常用的库就是express，就用express作为demo。如果你的express的4.0以下的版本，只需要在代码中添加以下代码： 1app.use(express.compress()); 在express 4.0以上的版本中不再集成GZIP功能，需要单独安装中间件，先通过npm i compression安装compression，然后在项目中引用： 12var compress = require(&#x27;compression&#x27;);app.use(compress()); NGINX 修改nginx安装目录下的conf/nginx.conf配置文件，添加以下代码： 12345678910111213#开启gzipgzip on;#压缩阀值，小于1k不压缩gzip_min_length 1k;gzip_buffers 4 16k;#gzip_http_version 1.0;#压缩级别gzip_comp_level 2;#压缩的文件类型gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png application/javascript;gzip_vary off;#IE6对Gzip不怎么友好，禁止IE6进行压缩gzip_disable &quot;MSIE [1-6]\\.&quot;;","tags":[{"name":"技巧","slug":"Tips","permalink":"http://xieyufei.com/tags/Tips/"},{"name":"服务器","slug":"Server","permalink":"http://xieyufei.com/tags/Server/"}]},{"title":"Nodejs学习：查询MySQL数据库","date":"2016-12-05T14:33:55.000Z","path":"2016/12/05/Nodejs-Query-Mysql.html","text":"在上一篇文章《Nodejs学习：连接MySQL数据库》中学习了Nodejs连接MySQL数据库的几种方法，数据库连接上了之后就需要对数据库进行查询。本篇文章介绍一下查询MySQL数据库的方法。 查询方式 上一篇文章中，我们用到了一种查询数据库的最基本的方法：connection.query(sqlString, callback)。 第一个参数是一个SQL语句，可以是任意的数据库语句，而第二个参数是一个回调函数，查询结果通过回调参数的方式返回。 123456connection.query( &#x27;select * from book where author = &quot;xyf&quot; and country = &quot;china&quot;&#x27;, function(err, result) &#123; console.log(result); &#125;); 这是最简单的查询方式，但是存在着两个问题，一个是需要拼接字符串，比较繁琐；另一个是容易被sql注入攻击，因此我们有了第二种查询方式。 占位符注入查询 第二种查询方式是采用了占位符的形式connection.query(sqlString, values, callback)，这样就不需要进行恶心的字符串的拼接了。 1234567connection.query( &#x27;select * from book where author = ? and country = ?&#x27;, [&#x27;xyf&#x27;, &#x27;china&#x27;], function(err, result) &#123; console.log(result); &#125;); 使用对象查询方式 第三种查询方式我们将查询语句和查询值组合成一个对象来进行查询。它的形式是这样的：connection.query(object, callback)。 12345678910connection.query( &#123; sql: &#x27;select * from book where author = ? and country = ?&#x27;, values: [&#x27;xyf&#x27;, &#x27;china&#x27;], // 作为对象的属性 timeout: 40000, &#125;, function(err, result) &#123; console.log(result); &#125;); 组合查询方式 将第二种和第三种方式可以结合起来使用，查询值作为query方法的一个参数，而不是作为对象中的一个属性。 1234567891011connection.query( &#123; sql: &#x27;select * from book where author = ? and country = ?&#x27;, timeout: 40000, // [&#x27;corner&#x27;, &#x27;us&#x27;] // 如果同时设置，那么此时不会生效 &#125;, [&#x27;xyf&#x27;, &#x27;china&#x27;], // 作为query函数的一个参数 function(err, result) &#123; console.log(result); &#125;); 需要注意的是，如果我们既将查询值作为对象的属性，又将其作为query函数的参数，这个时候函数中的参数将会覆盖对象的属性，也就是说此时只有参数的值生效。 解析查询值 在进行数据库查询时，有一个重要的原则就是永远不要相信用户的输入。为什么不能相信用户的输入呢，首先让我们来了解一下SQL注入攻击。 SQL注入攻击 所谓的SQL注入攻击，就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。由于笔者并不是从事数据库方面的工作，也不是数据库方面的砖家，所以只能通过一个简单的DEMO来演示一下SQL注入攻击。 假如我们拼接的SQL语句是这样的 12var username = &#x27;xyf&#x27;;var sql = &#x27;select * from book where author = &quot;&#x27;+username+&#x27;&quot;&#x27;; 这里我们期待用户输入的username是Jack或者LiLi之类的，但是用户说我偏不，我就输入一串恶意代码： 12var username = &#x27;&quot;1 or 1=1&#x27;;var sql = &#x27;select * from book where author = &quot;&#x27;+username+&#x27;&quot;&#x27;; 最后我们拼接的查询语句就变成了下面这样的： 1select * from book where author = &quot;&quot; or 1=1 如果读者对SQL语句有一些基本了解，就会知道如果把这段查询语句放到数据库中进行查询，那么所有用户的信息都被查出来了，但是这并不是我们想要看到的结果。 避免SQL注入攻击 那么怎么才能避免SQL注入攻击呢？mysql提供了两种方法给我们，第一种方法就是每次查询时都把用户输入的数据都用escape()函数解析一下，有点类似预处理语句。 123456789var authorname = &#x27;user input&#x27;;connection.escape(authorname);// 或者使用mysql.escape(authorname);connection.query( &#x27;select * from book where author = &quot;&#x27;+authorname+&#x27;&quot;&#x27;, function(err, result) &#123; console.log(result); &#125;); 第二种方法就是在查询时通过上面说到的占位符注入查询的查询方式来进行查询。但它内部的实现也是通过上面所说的escape()方法将用户输入解析了一下。推荐使用第二种方法来得简单快捷。 多语句查询 mysql还支持多语句查询，但是由于某些安全原因（官方解释是因为如果值没有正确解析会导致SQL注入攻击）默认是被禁止的。那么让我们来打开这个“潘多拉魔盒”把。 在创建数据库连接时首先把这个功能开启。 1234let connection = mysql.createConnection(&#123; // 其他配置 multipleStatements: true,&#125;); 然后我们就可以使用多语句查询了。 1234567891011connection.query( &#123; sql: `select * from book where username = ?; select * from book where username = ?;`, &#125;, [&#x27;ace&#x27;,&#x27;xyf&#x27;], function(err, rows, fields) &#123; if (err) throw err; console.log(&#x27;The solution is: &#x27;, rows); &#125;); 查询结果 通过查询语句返回的结果以数组的形式返回，如果是单语句查询，数组就是一个纯对象数组[obj1,obj2,...]，数组中的每一个对象都是数据库中每一行的数据，只是以对象的方式返回。如果没有查询到数据，那么数组的长度就为0。 但是如果是多语句(m条语句)的方式查询，虽然返回也是一个数组，但是数组中嵌套有n个数组，n的取值取决于你查询语句的条数m(即n=m)。 总结 由于官方文档比较零碎，因此整理得不是很到位，有问题的地方希望大家指正。","tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://xieyufei.com/tags/Nodejs/"},{"name":"Mysql","slug":"Mysql","permalink":"http://xieyufei.com/tags/Mysql/"},{"name":"数据库","slug":"DataBase","permalink":"http://xieyufei.com/tags/DataBase/"}]},{"title":"Nodejs学习：连接MySQL数据库","date":"2016-11-15T14:33:55.000Z","path":"2016/11/15/Nodejs-Connect-Mysql.html","text":"前一阵在做项目的时候，需要通过nodejs连接到MySQL数据库，于是简单地学习了一下MySQL这个库，分享一些学习心得给大家，希望对大家有帮助。 介绍 首先说来介绍一下MySQL（非广告）。MySQL是由瑞典的MySQL AB公司开发，后来被甲骨文公司收购。和Oracle一样，MySQL是一个典型的关系型数据库，在百度百科中，把MySQL称为是最好的关系数据库管理系统的之一。 什么是关系型数据库和非关系型数据库 说到关系型数据库，大家肯定就会想到另一个词与之对应，非关系型数据库，那么这两者有什么样的区别呢？ 关系型数据库是指采用了关系模型（指的是二维表格模型）来组织数据的数据库，有稳定的表结构；而非关系型数据库中的数据没有关系模型，以对象的形式存放到数据库中，对象之间的关系是通过每个对象的属性来决定的，有点类似于一长串json对象。典型的非关系型数据库有MongoDB和Redis。 谢小飞博客专用防爬虫链接，想要看最新的前端博客请点这里 MySQL的优缺点 我在项目中使用MySQL作为数据库主要是因为它体积小，速度快，安装完才几百兆，相比于Oracle好几个G它确实“轻”了不少。而且核心程序采用多线程编程，线程也是轻量级的进程，不会占用太多的系统资源，因此一般的中小型网站都选择MySQL数据库，而且最重要的是MySQL几乎是免费的。 但是也正是由于它的轻量级，因此它也“砍掉”了一些功能，比如存储过程等。 使用 这边不再赘述MySQL的安装过程，有需要的读者可以自行百度安装教程。在我们的项目中通过npm install mysql --save来安装依赖。 谢小飞博客专用防爬虫链接，想要看最新的前端博客请点这里 一个简单的Demo 首先，通过一个小的Demo来测试我们的环境是否已经搭建完毕了： 1234567891011121314151617181920212223var mysql = require(&#x27;mysql&#x27;);// 连接数据库的配置var connection = mysql.createConnection(&#123; // 主机名称，一般是本机 host: &#x27;localhost&#x27;, // 数据库的端口号，如果不设置，默认是3306 port: 3306 // 创建数据库时设置用户名 user: &#x27;xyf&#x27;, // 创建数据库时设置的密码 password: &#x27;xyf&#x27;, // 创建的数据库 database: &#x27;xyf_db&#x27;&#125;);// 与数据库建立连接connection.connect();// 查询数据库connection.query(&#x27;SELECT 1 + 1 AS solution&#x27;, function(err, rows, fields) &#123; if (err) throw err; console.log(&#x27;The solution is: &#x27;, rows[0].solution);&#125;);// 关闭连接connection.end(); 运行程序，如果显示“The solution is: 2”，那么整个连接查询是成功的；如果不成功，读者可以根据打印的错误信息提示来修改。 在查询完数据库后，需要通过end()函数将连接关闭。如果连接一直打开，首先会浪费不必要的系统资源；其次，数据库的连接数量有限制，如果达到上限时，会出现后续连接不上报错的情况。 建立数据库连接 要想查询数据库，首先就要跟数据库建立连接，上面的Demo给出了一种建立连接的方式。官方文档还给出了另外两种建立连接的方式。 隐式建立连接1234567var mysql = require(&#x27;mysql&#x27;);var connection = mysql.createConnection(...);connection.query(&#x27;SELECT 1 + 1 AS solution&#x27;, function(err, rows, fields) &#123; if (err) throw err; console.log(&#x27;The solution is: &#x27;, rows[0].solution);&#125;);connection.end(); 我们并没有像Demo中一样使用connect()函数建立连接，而且直接进行了查询，这时候建立连接将会被隐式地调用。 连接回调查询 上面两种连接方式并没有对连接出错的情况进行处理，一旦连接出现错误将带来连锁的多米诺骨牌效应，查询也将会失败，整个程序也会崩溃，为了避免出现这样的情况，我们将查询和关闭连接放到回调函数中。 123456789101112131415161718var mysql = require(&#x27;mysql&#x27;);var connection = mysql.createConnection(...);connection.connect(function(err)&#123; if(err)&#123; // 连接失败时的错误处理 console.log(err); return; &#125; connection.query(&#x27;SELECT 1 + 1 AS solution&#x27;, function(err, rows, fields) &#123; if(err)&#123; // 查询失败时的错误处理 console.log(err); return err; &#125; console.log(&#x27;The solution is: &#x27;, rows[0].solution); &#125;); connection.end();&#125;); 注：上面的三种建立连接的方式都是可以的，取决于笔者怎么处理连接错误。 谢小飞博客专用防爬虫链接，想要看最新的前端博客请点这里 关闭连接 打开了数据库的连接我们也需要关闭连接，有两种关闭连接的方式，一种就是我们上面用的end()方法来关闭连接，它可以接收一个回调函数。 123connection.end(function(err) &#123; // 这时连接已经被关闭了&#125;); 通过end()函数关闭连接不会影响队列中的查询。还有一种方式是调用destroy()函数。 1connection.destroy(); destroy()函数确保了没有更多的时间和回调会触发连接。同时destroy()函数也没有回调函数。 使用数据库连接池 数据库连接是一种关键的、有限的、昂贵的资源。 —百度百科 通过上面的数据库连接方式我们会发现直接创建一个数据库连接比较“危险”，因为有很多种可能性导致连接的失败。而且如果我们的程序中随意都可以和数据库建立连接的话，我们的程序就比较得混乱，不能很有效的管理数据库连接。mysql库提供了另一种数据库连接方式给我们。 什么是数据库连接池 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个。这项技术能明显提高对数据库操作的性能。 用一个很生动的例子来形容数据库连接池的工作：以前我们存取钱都需要去银行的柜台交易，银行的柜台数量是有限的，人多的时候还需要排队；现在我们把钱都存在了支付宝上，每次需要用钱的时候都直接跟支付宝“要”，不需要再跑到银行去了，所有和银行“打交道”的业务都交给了支付宝帮我们来管理。 数据库连接池在初始化的时候将一定数量（数量受最小连接数制约）的数据库连接存放到数据库连接池中，不管这些数据库连接是否被使用，连接池一直要存放这么多的连接数量。连接池的最大数据库连接数量限制了连接池最多能同时拥有的连接数，如果超过最大连接数时，请求将会被添加到等待队列中去。 创建连接池 下面就开始创建一个数据库连接池。 123456789101112131415161718192021222324var mysql = require(&#x27;mysql&#x27;);var pool=mysql.createPool(&#123; host: &#x27;localhost&#x27;, user: &#x27;xyf&#x27;, password: &#x27;xyf&#x27;, port: &#x27;3306&#x27;, database: &#x27;xyf_db&#x27;, // 最大连接数，默认为10 connectionLimit: 10,&#125;)pool.getConnection(function(err,connection)&#123; if(err)&#123; console.log(err); return; &#125; connection.query(&#x27;SELECT 1 + 1 AS solution&#x27;,function(err,result)&#123; connection.release(); if(err)&#123; console.log(err); return; &#125; console.log(&#x27;The solution is: &#x27;, result[0].solution); &#125;)&#125;) 首先我们通过createPool()方法创建了一个数据库连接池，它的配置参数和上面的配置基本差不多，只是多了一个最大连接数。每次我们需要和数据库建立连接的时候不再是直接建立连接，而是去连接池中通过pool.getConnection()方法“捞取”已有的连接。这个方法有一个回调，数据库连接作为回调参数返回给我们使用。 每次查询完数据库是都要使用release()方法释放数据库连接，这样数据库连接又回到了连接池中。释放后如果再使用connection将会报错。 谢小飞博客专用防爬虫链接，想要看最新的前端博客请点这里 关闭连接池 一般数据库连接池不需要关闭，但是如果使用完连接池需要将所有的连接关闭，我们可以使用pool.end()方法将其关闭。 123pool.end(function (err) &#123; // 所有连接池中的数据库连接将会被关闭&#125;); end()方法提供一个回调方法，以便在所有连接关闭时进行一些操作。关闭连接池前所有队列中的查询任然会执行完成，所以每次关闭的时间都不一样。一旦end()方法被调用了，getConnection和其他一些获取连接池中连接的方法不会再被执行。 总结 本篇文章主要学习了nodejs连接mysql数据库的一些两种连接方式，直接连接和通过数据库连接池的方式进行连接。直接创建连接的方式比较“危险”，推荐使用连接池，把所有的连接集中管理，既方便又安全。","tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://xieyufei.com/tags/Nodejs/"},{"name":"Mysql","slug":"Mysql","permalink":"http://xieyufei.com/tags/Mysql/"},{"name":"数据库","slug":"DataBase","permalink":"http://xieyufei.com/tags/DataBase/"}]},{"title":"打造自己的聊天机器人Hubot","date":"2016-11-12T02:24:29.000Z","path":"2016/11/12/Hubot-Chat-Machine.html","text":"记得以前看钢铁侠的时候，看到有一个小罗伯特有一个私人的语音智能系统贾维斯，协助钢铁侠处理各种事务、计算各种数据和信息，相当的方便，让我欣羡不已。于是我就想着有一个自己的机器人帮我处理事情，正好在网上看到GitHub的一个开源聊天机器人Hubot，学习着用了一下，虽然没有贾维斯那么狂拽酷眩，但是毕竟是属于自己的Hubot。 一、介绍Hubot Hubot是GitHub的开源聊天机器人，前身主要是GitHub用来完成一些自动化的任务，比如部署站点、自动处理任务(别问我，笔者也不知道是什么任务)等。随着使用Hubot使用越来越频繁，它也变得更健壮更智能。为了帮助更多的人，GitHub将它重写并且开源。 Hubot采用CoffeeScript语言开发，这是一套类似于JavaScript的语言，但是更加的简洁，很容易就能够读懂。目前Hubot原生带有一些功能，比如搜索图片、翻译、地图服务，还可以自定义插件脚本，同时还能使用别人开发好的插件。Hubot插件库中大概有一百多个插件。 要运行Hubot，需要对nodejs和npm有一些了解，最好还装有redis服务。推荐使用Git工具进行以下操作。 二、安装Hubot 下面就开始在电脑上安装我们的Hubot，默认读者们把nodejs和npm都安装好了。 一些准备工作 由于官方支持使用CoffeeScript语言编写代码，所以先安装脚本编译器和Hubot的框架 1npm install yo generator-hubot coffee-script -g 接着创建项目目录，这里的目录名建议跟Hubot的名称保持一致，这里我的Hubot叫jarvis 12mkdir jarviscd jarvis 开始安装 在git命令行中输入如下命令，开始我们的安装过程。 1yo hubot 出现了如下安装提示界面，输入我们的所有者、Hubot名称和描述等。 输好后会根据你输入的创建对应的配置文件，然后进行处理，并且安装一些模块文件等。等待安装完成就可以使用了。 配置文件 安装完后启动Hubot，在命令行输入bin/hubot，看到有报错： 出现这个报错是因为没有配置heroku和redis服务没有开启。可以忽略，也可以在external-script.json中把hubot-heroku-keepalive和hubot-redis-brain注释掉。 然后把/scripts目录下的example.coffee打开，将下面两行代码中的#删除： 12# robot.hear /badger/i, (res) -&gt;# res.send &quot;Badgers? BADGERS? WE DON&#x27;T NEED NO STINKIN BADGERS&quot; 然后再次启动，这时候就能看到我们的jarvis正常启动。在命令行里输入jarvis ping，如果能看到jarvis回复pong，Hubot就安装完成了。 三、脚本 首先查看一下我们可以使用哪些命令。在命令行里输入jarvis help，可以看到所有可以使用的命令以及描述，比如map、pug、time、image命令等。在安装过其他插件后可以使用同样的命令查看新增加的命令。 需要注意的是，这里的jarvis help中的jarvis是笔者的自定义机器人名称，读者需要替换成自己的机器人名称，比如myhubot help。 自定义脚本 Hubot是基于事件监听机制的，我们可以为他自定义事件发生时的回调，当触发这个事件时执行回调。 在项目目录下有一个/scripts目录，存放的就是我们自己定义的脚本，像之前的example.coffee就是一个小的demo。 我们新建一个greet.coffee，输入一下代码： 123module.exports = (robot) -&gt; robot.hear /greet/i, (res) -&gt; res.send &quot;Hello,My Master&quot; 每个自定义的脚本都需要导出一个函数function，默认有一个robot的参数。这里的module.exports = (robot) -&gt;就相当于JavaScript中的module.exports = function(rebot){}。 这里的robot的hear方法相当于一个监听事件，它有两个参数，第一个是一个正则表达式，只要匹配了这个正则表达式就执行下面的回调函数，回调函数中我们通过send方法返回一个字符串。 再次重启我们的Hubot，输入jarvis greet，会看到Hubot跟我们打招呼了。 添加命令到help中 但是这时候使用help命令，没有看到可以使用greet命令的提示，怎么样将我们自定义的greet命令添加到help中去呢？如下修改我们的greet.coffee脚本，添加头部注释说明。 1234567# Description:# Greet To Master# Commands:# hubot greet - Greet To Mastermodule.exports = (robot) -&gt; robot.hear /greet/i, (res) -&gt; res.send &quot;Hello,My Master&quot; 添加路由地址 Hubot不仅能通过命令行监听命令，还能够通过路由监听地址。 我们新建一个文件router.coffee。 123module.exports = (robot) -&gt; robot.router.get &quot;/foo&quot;, (req, res) -&gt; res.end &quot;bar&quot; 这时候我们打开浏览器输入http://localhost:8080/foo就能看到输出bar。这里的端口默认识8080，如果需要更改端口可以在启动Hubot的时候通过PORT=8888 bin/hubot命令设置端口号 自定义脚本发送异步 Hubot不仅可以静态的设置要回复的内容，还能够动态地通过异步数据返回对应的内容，比如这里我们通过Hubot来查询城市的天气。 我们新建一个weather.coffee脚本(需要申请openweathermap.org的APPID)。 12345678910111213141516171819202122232425# Description:# Tells the weather## Configuration:# HUBOT_WEATHER_API_URL - Optional openweathermap.org API endpoint to use## Commands:# weather in &lt;location&gt; - Tells about the weather in given location## Author:# Cornerprocess.env.HUBOT_WEATHER_API_URL ||= &#x27;http://openweathermap.org/data/2.5/weather?units=imperial&amp;appid=[your appid]&amp;q=&#x27;module.exports = (robot) -&gt; robot.hear /weather in (\\w+)/i, (msg) -&gt; city = msg.match[1] url = process.env.HUBOT_WEATHER_API_URL + city msg.robot.http(url).get() (err, res, body) -&gt; data = JSON.parse(body) weather = [ &quot;#&#123;Math.round(data.main.temp)&#125; degrees&quot; ] for w in data.weather weather.push w.description msg.send &quot;It&#x27;s #&#123;weather.join(&#x27;, &#x27;)&#125; in #&#123;data.name&#125;, #&#123;data.sys.country&#125;&quot; process.env允许我们设置一个环境变量，这里我们自定义了一个天气url接口的变量。在CoffeeScript中x ||=y是x = (x != null) ? x : y的简写方式，代表了如果x没有赋值，就取y的值，保证了x一定有值。 通过调用msg.robot.http()方法来发送异步请求，在回调方法中先解析成JSON格式，然后对数据进行拼接处理，再用msg返回。 再次启动Hubot，输入jarvis weather in Suzhou就能查到对应城市的天气了。 处理没有识别的信息 有时候，我们输入的信息没有被任何脚本的正则捕获到，我们还是希望对这些信息进行处理，那么可以新建一个catchAll.coffee脚本。 123module.exports = (robot) -&gt; robot.catchAll (res) -&gt; res.send &quot;Sorry My Master,I do not know what you are saying&quot; 四、插件 虽然我们写了很多的脚本，但是有的功能已经有现成的，可以直接使用。 自带插件 Hubot自带了几个插件，让我们来看一下。 hubot-pugme 这个插件有两个命令，一个是hubot pug me，另一个是hubot pug bomb [number]。 输入第一个命令看到出现一个链接，在浏览器中打开我们看到了一只可爱的哈巴狗，输入第二个链接，我们把[number]改成随意的一个数字6，我们看到出来6张照片，打开是6张哈巴狗的照片，没错，这个插件就是给你看狗狗的(难道是狗狗爱好者做的？)。 我顿时就忍不住吐槽了，居然还标榜自己是最重要的Hubot插件(Pugme is the most important hubot script)，简直鸡肋啊。 hubot-google-images 这个插件有两个命令，一个是hubot image me，另一个是hubot animate me。 官网解释它是用来搜索图片地址的，那么就让我们用官网的例子来尝试一下吧jarvis image me bananas。 很遗憾的是Hubot提醒我这个谷歌的图片搜索引擎不能用了，要设置自定义的引擎。再看了一下官方的文档，这个谷歌图片搜索引擎还要注册，并且每天只能免费搜索一百次，超过了还要收费，有点坑啊。 hubot-maps 这个插件看样子是地图插件，看了一下官方说明，也有两个命令hubot map me和hubot direction me。抱着希望再次尝试了一下jarvis map me wuxi，幸运的是结果出来了，是一个地图的地址，再看了一下是谷歌地图的地址，那不用说了，绝壁要科学上网了。 下载插件 自带的插件用完了，笔者顿时累觉不爱了，想着去网上找找有没有其他的插件。 笔者在网上看到能够使用npm search hubot-scripts github命令查看Hubot的插件，但是试了一下老是报错，求好心人告知。 于是又找到了Hubot在线插件库的链接，进去看到确实有不少插件。详细的插件用法本文不再赘述，读者可以自行根据需要下载使用，使用前需要把插件名称添加到/external-scripts.json文件中去 五、总结 经过这几天对Hubot的学习，对Hubot我有以下几点感悟： Hubot确实能够做一些自动化的工作，但是需要我们去写脚本配置 Hubot能够聊天但是没有很智能，基于事件监听的基础上，只能够设置几种固定的回复语句，实现类似于京东JIMI的效果，距离电影中的效果还差的很远。 插件数量不多，只有一百多个，实用的插件数量更少，很多插件都比较的鸡肋，不具实用性。 很多插件还不能用，比如Hubot-WeChat据说能够集成到微信，我用了一直有报错，希望有好心人成功了交流下经验。","tags":[{"name":"聊天","slug":"Chat","permalink":"http://xieyufei.com/tags/Chat/"},{"name":"机器","slug":"Machine","permalink":"http://xieyufei.com/tags/Machine/"}]},{"title":"搭建自己的Webpack项目:入门（一）","date":"2016-10-21T04:15:07.000Z","path":"2016/10/21/Front-Webpack-First.html","text":"作为当下最流行的前端打包工具，webpack有自己无与伦比的优势和功能特性，使用webpack打包自己的项目能够大大地提高我们的开发效率。小编整理了一下webpack在项目中的最佳实战分享给大家。 一、什么是webpack 随着网页内容的越来越丰富，在我们的网页上我们经常要用到很多的脚本文件，比如幻灯模块的脚本、列表模块的脚本和搜索模块的脚本等等。如果不对这些文件进行统一的打包，整个页面就会非常的凌乱。 于是，webpack就诞生了，我们可以把它想象成一台洗衣机+烘干机+叠衣机(据说岛国已经发明类似的机器人了)，我们可以把杂七杂八的衣服、裤子、袜子等等都丢进去，然后它就会帮我们洗干净、烘干、叠整齐了，一系列工作全自动完成，不需要我们亲自动手，怎么样，是不是很心动。 借用webpack官网的一张图来解释一下webpack的工作原理。左边就是我们杂乱的页面资源，有脚本文件、样式文件、图片文件等等，各种文件之间互相引用。经过webpack的打包整理，生成静态文件。 webpack的工作方式是：通过一个配置文件找到入口文件，从这个入口文件找到你项目依赖的所有资源文件，使用对应的资源加载器(loaders)来处理这些资源文件，最后打包成静态文件。 二、安装webpack 使用webpack之前需要安装webpack，在这里我们需要在两个地方安装：全局目录和项目目录，在项目目录下执行以下命令： 1234//全局安装的作用是直接在命令行中使用npm install -g webpack//安装到项目目录，使用webpack的功能npm install --save-dev webpack 三、使用webpack 在开始上手项目之前首先来搭建我们的目录结构。 目录结构说明 我们可以把项目目录搭建成如下，当然只是给大家做一个参考而已： 12345678-- package.json-- webpack.config.js-- public/ -- images/ -- javascript/ -- stylesheet/-- view/-- build/ package.json使用npm init命令可以自动生成，在这里不过多的阐述；build目录主要是webpack构建的产物，自动生成；这里的核心文件就是我们的webpack.config.js文件，需要自己手动编写。 webpack配置文件 webpack.config.js配置文件通过exports导出一个对象，这个对象中有三个模块比较重要：entry、output和module，具体如下： 12345678910111213141516var webpack = require(&#x27;webpack&#x27;);var path = require(&#x27;path&#x27;)module.exports = &#123; entry: &#123; index: &#x27;./public/javascript/index.js&#x27; &#125;, output: &#123; path: path.resolve(__dirname, &#x27;build&#x27;), filename: &#x27;[name].bundle.js&#x27;, publicPath: &#x27;./build/&#x27; &#125;, module: &#123; loaders: [] &#125;, plugins:&#123;&#125;&#125; entry属性 entry属性是页面的主入口，所有页面的文件都在这个入口文件中进行引用。 当然，一个项目肯定有不止一个页面，需要多个入口，entry属性可以这样配置： 12345entry: &#123; index: &#x27;./public/javascript/index.js&#x27;, list: &#x27;./public/javascript/list.js&#x27;, //...多个页面的入口&#125;, output属性 在webpack打包之后，生成的js文件、css文件、图片文件等等就会放到output属性所指定的文件目录下。 path属性就是所在文件夹的路径，需要使用绝对路径，这里用path的resolve方法进行解析；filename属性指定了输出的文件名，[name]表示入口的属性名叫什么就输出对应的文件，比如这里的index输入的文件名就是index.bundle.js。 publicPath是以http方式请求的静态资源的路径，webpack-dev-server(webpack的一个插件)会根据你请求的url来匹配这个publicPath下的文件。 module属性 module属性主要存放解析资源文件的各个加载器，每一个对象表示了一个加载器。 test属性表示正则匹配，用来匹配文件的后缀名；loader属性表示如果文件相匹配，则调用对应的加载器来解析文件。比如样式加载器有css-loader、sass-loader。 加载器的后缀都是-loader，在loader属性中配置加载器不用写后缀，配置不同的加载器需要使用!分隔并串联起来。 plugins属性 plugins属性是用来放webpack的插件，这个属性下面会用到 编写入口文件 在/public/javascript/目录下，编写我们的入口文件index.js，我们的入口文件非常简单，就在页面上打印一句话： 123/public/javascript/index.jsdocument.write(&#x27;webpack works&#x27;)document.write(require(&#x27;./module.js&#x27;)) 还有我们的模块文件： 12/public/javascript/module.jsmodule.exports=&#x27;It works from module.js.&#x27; 这样一个简单的webpack项目就完成了，通过在项目根目录使用webpack命令，在build文件中生成index.bundle.js文件就是我们的构建产物，在页面上直接引用这个js就能看到效果了 给页面点“颜色”看看 在页面上我们肯定会用到很多的样式文件，那么怎么在页面上使用呢？首先需要有对应的加载器，这里我们就要用到样式加载器。 首先安装我们的加载器： 1npm install css-loader style-loader sass-loader --save-dev 然后改写配置文件中的加载器模块： 123456module: &#123; loaders: [ &#123; test: /\\.css$/, loader: &#x27;style!css&#x27; &#125;, &#123;test: /\\.scss$/, loader: &quot;style!css!sass&quot;&#125; ]&#125; css-loader会遍历css文件，找到所有的url(…)并且处理。style-loader会把所有的样式插入到你页面的一个style标签中。 接下来就可以编写我们的样式文件了： 12/stylesheet/style.cssbody&#123;background:#f5f5f5&#125; 在index.js中我们添加对样式文件的引用： 1require(&#x27;../stylesheet/style.css&#x27;); 在根目录我们再次执行webpack命令，再次生成构建的js文件就能看到页面上有颜色了。 提取公共的脚本并压缩 有时候多个公共脚本中有公用的部分，如果多写就显得有点多余，我们可以利用webpack的提取公共部分的插件来帮助我们提取。 在plugins属性中添加如下代码： 123456plugins: [ //压缩代码 new webpack.optimize.UglifyJsPlugin(), //提取公共部分 new webpack.optimize.CommonsChunkPlugin(&#x27;common.js&#x27;)] 再次执行webpack命令，我们在build文件夹里看到多出了一个common.js文件，这个就是提取出的公共部分。 独立出样式文件 通过style标签引入样式可能会让页面的代码看起来非常的庞大非常的凌乱，有时候我们需要将所有的样式导出到一个独立的样式文件，然后通过link标签引入样式文件。 这时候我们就需要用新的插件。通过npm install命令安装extract-text-webpack-plugin插件。 1npm install extract-text-webpack-plugin --save-dev 安装完插件我们就需要在webpack.config.js文件中进行配置了。 1234567891011121314var ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);module.exports = &#123; // ...省略部分代码 module: &#123; loaders: [ // ...省略部分代码 &#123;test: /\\.css$/, loader: ExtractTextPlugin.extract(&quot;style-loader&quot;, &quot;css-loader&quot;)&#125; ] &#125;, plugins: [ new webpack.optimize.CommonsChunkPlugin(&#x27;common.js&#x27;), new ExtractTextPlugin(&quot;[name].css&quot;) ]&#125; 我们再使用webpack命令打包一下，看到build文件夹中看到多了一个index.css文件，就是插件提取出来的所有页面样式，都在一个文件中。 使用高逼格的ES6 ES6简洁的语法糖、性能的提升都让开发者对其深深的“迷恋”，下面来让我们的项目也来支持ES6的语法。 要想支持ES6首先要安装对应的解码器，es6的解码器就是babel，首先安装babel-loader： 1npm install babel-loader --save-dev 然后改写配置文件： 1234loaders: [ // ...省略部分代码 &#123; test: /\\.js[x]?$/, loader: &#x27;babel&#x27; &#125;] 配置完成后我们就可以在js中尽情地使用es6的语法糖了。 四、总结 在这里我们编写了webpack的配置文件，对配置文件的属性进行了详细地说明，也添加了webpack的几个插件。但是还是欠缺以下几点： 没有图片加载器 没有构建本地服务器，没有热加载 没有引导命令执行 本文所涉及到的代码都在我的github仓库，需要的读者可以去fork，喜欢的给个赞啊亲。希望在后续的文章中对代码进行优化，添加更多的插件来丰富功能。","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"打包工具","slug":"PackTool","permalink":"http://xieyufei.com/tags/PackTool/"},{"name":"Webpack","slug":"Webpack","permalink":"http://xieyufei.com/tags/Webpack/"}]},{"title":"微信小程序上手开发和使用总结（下）","date":"2016-10-11T08:53:26.000Z","path":"2016/10/11/Front-Tiny-WeChat-Next.html","text":"在微信小程序上手开发和使用总结（上）中介绍了微信小程序的基本用法、数据处理和页面渲染等，这篇文章整理一下微信小程序的事件绑定及模板的用法。 一、模板 WXML提供模板组件给我们使用，可以在模板定义公用的代码片段，然后在需要引用的地方进行调用。 定义模板 定义模板使用name属性作为模板的名字，然后在template标签中定义代码片段： 123456789101112&lt;template name=&quot;mytemplate1&quot;&gt; &lt;view&gt; &lt;text&gt;firstName:&#123;&#123;firstName&#125;&#125;&lt;/text&gt; &lt;text&gt;lastName: &#123;&#123;lastName&#125;&#125;&lt;/text&gt; &lt;/view&gt;&lt;/template&gt;&lt;template name=&quot;mytemplate2&quot;&gt; &lt;view wx:for=&quot;&#123;&#123;persons&#125;&#125;&quot;&gt; &lt;text&gt;firstName:&#123;&#123;item.firstName&#125;&#125;&lt;/text&gt; &lt;text&gt;lastName: &#123;&#123;item.lastName&#125;&#125;&lt;/text&gt; &lt;/view&gt;&lt;/template&gt; 使用模板 使用模板我们用is属性引用定义好的模板，然后把模板所需要的值通过data属性传给模板。比如需要遍历persons数组，我们可以将整个persons作为对象传给模板，也可以遍历persons后将每个对象传给模板，具体取决于所应用的场景。 1234&lt;view wx:for=&quot;&#123;&#123;persons&#125;&#125;&quot;&gt; &lt;template is=&quot;mytemplate1&quot; data=&quot;&#123;&#123;...item&#125;&#125;&quot;&gt;&lt;/template&gt;&lt;/view&gt;&lt;template is=&quot;mytemplate2&quot; data=&quot;&#123;&#123;persons&#125;&#125;&quot;&gt;&lt;/template&gt; 需要的数据结构如下 123456789Page(&#123; data:&#123; persons:[ &#123;firstName: &#x27;Hulk&#x27;, lastName: &#x27;Hu&#x27;&#125;, &#123;firstName: &#x27;Shang&#x27;, lastName: &#x27;You&#x27;&#125;, &#123;firstName: &#x27;Gideon&#x27;, lastName: &#x27;Lin&#x27;&#125; ] &#125;&#125;) 注意： is属性也可以使用Mustache语法进行动态渲染，决定使用哪个模板 data如果传的是对象类型的数据，需要用“…”进行“解构”，在模板中可以直接调用对象的属性；如果是其他数据类型则不需要用“…” 二、事件 什么是事件呢，简单来说，事件就是逻辑层到逻辑层的通讯方式。就是在页面上通过触发某个操作（就是我们说的事件），在逻辑层进行一系列的操作，最终来改变数据。 比如在一个输入框中用户输入了一段文字，但是data中的数据并没有随之改变，因此我们需要在输入框上绑定对应的输入事件来更改数据。 事件分类 事件也有分类，可以分为冒泡事件和非冒泡事件。“冒泡”这个词很形象的表现了事件向上传递的过程，这两种事件的区别也在于是否会向父节点进行传递。 一些常用的冒泡事件，除以下的事件外都是非冒泡事件： 名称 触发 touchstart 手指开始触摸 touchmove 手指触摸后移动 touchend 手指触摸动作结束 touchcancel 触摸被打断，比如来点，弹框等 tap 触摸后离开，有点像点击click longtap 长按，超过350ms才离开 事件对象 当事件函数被调用时，从逻辑层有一个默认的事件对象传到函数中，不同的事件所包含的事件对象的属性有所区别，一些常用的事件对象的属性如下： 属性 类型 说明 type String 事件类型 timeStamp Int 从页面加载到事件触发的时间戳 target Object 触发事件的组件的一些属性值集合 currentTarget Object 当前组件的属性值集合 touches Array 触摸点信息的数组 detail Object 额外的信息 target和currentTarget区别 当不存在嵌套时，target和currentTarget没有区别。但是当嵌套触发事件是，current和currentTarget的区别就体现出来了。 123456&lt;view class=&quot;A&quot; bindtap=&quot;handle1&quot;&gt; outer &lt;view class=&quot;B&quot; bindtap=&quot;handle2&quot;&gt; inner &lt;/view&gt; &lt;/view&gt; 点击组件B，当触发handle2事件时，收到target和currentTarget对象是一样，都指向组件B；而当点击组件B触发handle1事件时，target对象指向了组件B，currentTarget对象则组件A。总结一下： target对象指向了所触发事件的对象 currentTarget对象指向了绑定事件所在的对象 向detail中添加内容 在组件中定义数据，当触发事件时，这些数据通过事件对象传给逻辑层。书写规则：以“data-”开头，多个字符用“-”连接，不能含有大写，可以绑定多个data值。例如data-element-name，最终会在event.currentTarget.dataset中转为elementName属性，属性的值就是定义的数据。 三、异步数据 小程序还提供发送异步的方法request(object)，发起的是https请求。一个小程序，同时只有有5个网络请求链接。object的参数如下： 参数命 类型 说明 url Sring 服务器接口地址 data Object 请求的参数 header Object 设置请求头header，header不能设置Referer method String 请求方式，默认GET success Function 请求成功的回调方法 fail Function 请求失败的回调方法 complete Function 请求完成的回调方法(请求成功、失败都会调用) 跟jQuery不同的是，小程序请求的数据不是直接在success方法的res中(res是一个对象，还包括请求成功的状态码等)，而是在res.data中。示例代码如下： 12345678910111213wx.request(&#123; url: &#x27;/url&#x27;, data: &#123; x: &#x27;&#x27;, y: &#x27;&#x27; &#125;, header: &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27; &#125;, success: function(res) &#123; console.log(res.data) //接收到的数据 &#125;&#125;)","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"WeChat","slug":"WeChat","permalink":"http://xieyufei.com/tags/WeChat/"}]},{"title":"微信小程序上手开发和使用总结（上）","date":"2016-10-09T01:58:02.000Z","path":"2016/10/09/Front-Tiny-WeChat.html","text":"最近微信小程序一下子火了起来，我也学习了一下，写了几个简单的demo，分享一下自己的使用心得，希望对大家有帮助。 我们提供了一种新的开放能力，开发者可以快速的开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。 搭建环境 要开始做项目，首先要安装微信小程序的开发工具。官网的版本比较旧，笔者分享一个下载链接，大家可以去下载，微信小程序开发工具下载，下载完直接安装后新建项目就可以使用了。当然，由于还处在内测阶段，腾讯只邀请了部分企业参与内侧，所以AppID数量很稀少，读者在添加项目的时候可以选择无AppID。添加项目后打开小程序的开发工具是这样的：调试按钮可以打开调试界面，如果读者用惯了Chrome浏览器，想必对这个界面肯定不会陌生；如果需要切换到其他的项目，可以直接点关闭按钮，而不用关闭整个工具。 项目结构 整个项目由两部分组成，一个是描述整体程序的app文件和多个框架页面文件组成。 app文件 描述整体程序的app文件必须放在文件的跟目录，由三个文件组成，app.js、app.json和app.wxss。 app.js:程序的整体逻辑 app.json:程序的公共设置 app.wxss:小程序的公共样式(非必须) 在app.json文件中可以对小程序进行全局配置，比如页面路由、窗口表现、网络超时、多个tab等；在app.js中我们使用App()注册小程序的，它接受一个object对象作为它的参数，这个参数指定了小程序的生命周期函数。object函数说明： 属性 描述 触发 onLaunch 小程序初始化 初始化完成后 onShow 小程序显示 小程序由后台进入前台 onHide 小程序隐藏 小程序由前台进入后台 注意： App()函数只能定义一次，并且只能在app.js中定义。 onLaunch()函数在整个小程序的生命周期只调用一次，其他两个函数调用多次。 框架页面文件 项目框架页面可以配置多个，建议页面的文件名称和文件名保持一致。比如有一个下单页book，其中的文件可以设置为book.js、book.wxml、book.wxss、book.json。 xxx.js:页面逻辑 xxx.wxml:页面结构 xxx.wxss:页面样式(非必须) xxx.json:页面配置(非必须) 我们在框架页面也需要注册页面，注册页面通过Page()函数，这个函数也接受一个object函数，用来指定函数的生命周期函数和初始化的数据。 属性 类型 描述 data object 页面初始化数据 onLoad Function 页面加载时 onReady Function 页面初次渲染完成 onShow Function 页面显示时 onHide Function 页面隐藏时 onUnload Function 页面卸载时 onPullDownRefreash Function 页面下拉时 注意： onLoad()函数在页面加载时只调用一次。可以获取上个页面传来的参数，默认保存在data参数中，可以通过data.param的方式获取。 onUnload()页面卸载时调用，比如调用redirectTo或者navigateBack时。 数据处理 和jQuery等其他js框架不同的，小程序不能直接操作DOM元素，只能通过改变数据来控制页面元素的状态，这样有点类似React的思想。所以我觉得小程序的思想是面向数据，而不是面向元素。 数据绑定 上一节我们说过注册页面时需要传入一个object参数，这个参数可以挂载很多页面的生命周期函数，同时，也能将页面的数据挂载进去。页面的数据可以直接挂载到object参数的data对象中去。 12345678Page(&#123; data:&#123; name:&#x27;xyf&#x27; &#125;, myname:&#x27;test&#x27; onLoad:function()&#123; &#125;&#125;) 这里我们定义了两个数据，一个数据定义在data对象中，另一个数据直接定义Page的参数中。我们可以将data中的数据渲染到页面中，使用Mustache语法(双大括号)将要渲染的变量包起来，如下： 1&lt;view&gt;&#123;&#123;name&#125;&#125;&lt;/view&gt; 如果需要在组件的属性内渲染数据，也需要用双大括号包起来： 1&lt;view class=&quot;item-&#123;&#123;name&#125;&#125;&quot;&gt;&lt;/view&gt; 在双大括号中，我们可以进行简单的运算和判断，比如三元运算，算数运算，字符串运算等。 1&lt;view class=&quot;&#123;&#123;name==&#x27;xyf&#x27;?&#x27;yes&#x27;:&#x27;no&#x27;&#125;&#125;&quot;&gt;&#123;&#123;name+&#x27; is a smart boy&#x27;&#125;&#125;&lt;/view&gt; 数据获取和更改 对于data中的数据，我们必须通过this.data.name这种方式来获取，对于data外面的数据，我们可以通过this.myname的方式来获取。 1234onLoad:function()&#123; console.log(this.data.name); //&#x27;xyf&#x27; console.log(this.myname); //&#x27;test&#x27;&#125; 对于data中的数据，要想改变它的值，必须要调用setData()方法来改变，而要改变data外的数据，可以直接给他进行赋值。 12345678910onLoad:function()&#123; this.setData(&#123; name:&#x27;Corner&#x27; &#125;); console.log(this.data.name); //&#x27;Corner&#x27; this.data.name=&#x27;Nick&#x27;; console.log(this.data.name); //&#x27;Corner&#x27; this.myname=&#x27;mytest&#x27;; console.log(this.myname); //&#x27;myest&#x27;&#125; 注意： 在函数中注意this的作用域。在map函数或者异步回调函数中要使用this，要在函数外先把this赋值给that，然后用that进行操作。 setData()对象参数的值不能为undefined。每次setData进行赋值时都要对要赋的值进行非空判断，确保不是undefined，否则会报错。 总结一下，两种方式定义的数据区别如下： 能否被渲染：页面只能动态渲染data中的数据，data外的数据不能被渲染到页面上，所以data中放一些需要页面动态渲染的数据 获取方式：data中的数据通过this.data.[param]方式获取，data外的数据通过this.[param]方式获取。 赋值方式：data中的数据只能通过setData()函数进行赋值，而data外的数据可以直接赋值。 页面渲染 对于data中的简单变量，我们可以通过双大括号的方式进行渲染，但是如果对于一些稍微复杂一点的数据结构(比如数组)，双大括号就不能满足我们的需求了。我们需要引入另外两种渲染方式，条件渲染和列表渲染。 条件渲染 我们使用wx:if=”“的来判断是否需要渲染该模块，还可以添加wx:elif和wx:else渲染。 123&lt;view wx:if=&quot;&#123;&#123;length &gt; 5&#125;&#125;&quot;&gt; 大于 &lt;/view&gt;&lt;view wx:elif=&quot;&#123;&#123;length &gt; 2&#125;&#125;&quot;&gt; 中等 &lt;/view&gt;&lt;view wx:else&gt; 小于 &lt;/view&gt; 也可以直接在大括号中使用布尔类型的值控制页面元素隐藏和显示。如果data中flag为false，那么类名为demo的这个view组件就不会渲染到页面上去。 123&lt;view class=&quot;demo&quot; wx:if=&quot;&#123;&#123;flag&#125;&#125;&quot;&gt;显示&lt;/view&gt; 列表渲染 有时候我们需要将一个数组渲染到页面上，比如几个用户信息，比如点评列表，这时候就需要用到列表循环。 列表循环使用wx:for来绑定一个数组，就可以将数组中的每个数据循环遍历到组件中。默认情况下每个元素的变量名为item，每个变量的索引值为index。 123&lt;view wx:for=&quot;&#123;&#123;[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;]&#125;&#125;&quot;&gt; 这是第&#123;&#123;index&#125;&#125;个元素，元素内容为&#123;&#123;item&#125;&#125;&lt;/view&gt; 在列表遍历时我们并没有定义item和index，小程序自动为我们添加了wx:for-index=”index”和wx:for-item=”item”。因此在嵌套列表渲染时，注意index和item所代表的值和对象。需要我们自己定义变量名和索引，避免混乱。 总结和期待 微信小程序还在内测阶段就引起了这么多关注，作为一个程序员，尤其是一名前端程序员，上手和熟悉微信小程序的开发无疑会让我们越来越“吃香”。网上也在热议微信小程序是否会颠覆或者代替原生App，我觉得两者还是有以下区别的： 产品形态：微信小程序更加接近于HTML5产品，开发上也使用JavaScript进行开发，性能比H5好，但是要比原生App性能低。而且微信小程序整体文件大小限制在1MB以内，估计只能运行一些小型的应用和游戏，一些大型的应用肯定还是要用App的。 用户习惯：很多用户已经用惯了App，要想改变用户的习惯还是挺难的。用户操作肯定是越简单越好。比如现在微博App打开就能用，但是如果有了微博小程序，需要进入微信才能打开，相信用户还是挺反感中间多余的“步骤”。 个人感觉微信小程序的开发也存在着不足之处，希望在以后的版本中能够改进： 开发工具不能实时运行结果：每次都需要编译才能看到结果，程序猿表示每次看效果都比较麻烦。 不支持ES6：现在ES6越来越流行，确实给开发带来了不少的简洁和便利。每次开发还要使用原生js，程序猿表示鸭梨山大啊。 组件太少，不支持自定义组件：能够使用的组件偏少，大部分情况下只能使用view和text，不能够满足复杂的业务场景。","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"WeChat","slug":"WeChat","permalink":"http://xieyufei.com/tags/WeChat/"}]},{"title":"釜山行：一段旅途折射出世间百态","date":"2016-09-23T15:41:01.000Z","path":"2016/09/23/Film-TrainToBusan.html","text":"最近电影《釜山行》在各大荧幕热映，引起了观影群众的广泛热议。我身边的好多朋友看完了反响都还挺不错的，豆瓣也是给出了评分8.2的高分。今天在A站正好看到《釜山行》有资源，于是乎忍不住把它看完了。不得不说，韩国人拍的电影还是很不错的，给我的感触挺大的，想把自己的一些看法写下来。 这部电影在两个小时里其实讲了挺多东西的，亲情、爱情、友情和人性善良还有丑恶。笔者觉得一部好的电影不仅仅在特效和演员方面做好，所要刻画的人物才是整个电影的灵魂所在。那么怎么样才能刻画好电影中的人物形象呢，就是通过人性的善恶来刻画，折射出一类人，折射出社会的通病，这样的电影才能算是成功的电影。 这部电影一共刻画了这么几类人物，一个是主人公，身份是一位父亲，职业是证券基金经纪人；一个是秀安，跟随父亲一起去釜山看妈妈；一个是体格健壮的大叔，身份是一位丈夫，孩子即将出世；一个是快要临盆的孕妇，跟随丈夫一起去釜山；还有是高中生棒球队学生，和同学们去釜山比赛；还有是穿西装的中年大叔，职业是巴士公司常务，属于中产阶级；最后是中年大妈们，是一对姐妹花。 1.一个不被理解的父亲 首先是我们的主人公，作为一名证券基金经纪人，他也是一位成功人士，但是由于工作繁忙，他经常不在家陪孩子，和孩子产生了很深的隔阂。在孩子的强烈要求下，才放下工作，进行了这趟釜山行。上车后，秀安去洗手间遇到了体格健壮的大叔，大叔说主人公是“吸血鬼”，秀安非但没有为父亲辩护，反而还赞同大叔的观点。一开始主人公也是比较自私自利的，在大叔面临困难的时候他居然不是救人而是关门。在他得知前面有危险时，他也并没有及时地告诉其他人，而是各自管各自的带着女儿走了。 后来在遇到危险时，还是大叔和孕妇的帮助下，秀安才被救。他也被大叔和孕妇慢慢的感化，最后牺牲了自己，让秀安活了下来，在生命的最后还是惦记的女儿小时候的样子。看到最后这一幕，笔者也不禁为之所感动。主人公所代表的是一个不为女儿所理解的好父亲的形象，虽然他自身也有很多缺点，但是他还是会守护整个家庭，都在默默的为整个家庭所付出。 2.一个内心热情的健壮大叔 其次是体格健壮的大叔，一开始，外表看起来不太友善，但是对已怀孕的妻子确实十分的呵护，妻子对他发火的时候他也只是脸上堆满笑容。在整个电影里一直在救人，十分的有正义感。他利用自己健壮的优势，打退僵尸大军，不断地保护自己的妻子，保护身边的人。他也心胸开阔，虽然之前主人公关门不救他，但是后来不计前嫌，在主人公危难的时候还是救了他一把，两人也并肩作战。在最危机的时刻，他主动牺牲了自己，让主人公带自己的妻子先行逃离，自己拖住了僵尸队伍，还不忘记给自己未出世的女儿起名字。他是一个好丈夫，好父亲，好公民的角色。在我们生活中，总能看到这样一群大叔的身影，对生活充满热情，在我们迷路时，他会热情的为我们指路，在有人需要帮助的时候，他总会第一时间站出来。 3.一群涉世未深的高中生 然后是参加比赛的棒球队学生，他们刚开始在车上打打闹闹，玩的很开心，天真无邪。但是灾难发生的太突然了，除了女高中生和队长，其他的同学都被感染了。面对昔日的好友变成僵尸来攻击他们，队长拿着棒球拍愣住了，迟迟不敢动手，他内心肯定是不敢去相信的，自己的好朋友怎么会变成这样。到最后面对自己心爱的女生变成了僵尸，队长也只有一个劲的痛苦，却无可奈何，只能跟着爱情一起“陪葬”。学生是一群充满活力充满热情的群体，他们敢爱敢恨，能为爱情所牺牲，但是他们涉世未深，在困难面前容易不知所措，需要有人指引他们前进。 4.一对中年姐妹花大妈 还有就是一对中年大妈，一开始，姐姐给妹妹剥鸡蛋吃，对妹妹十分的“溺爱”，但是妹妹一脸嫌弃。他们的衣着也有着鲜明的对比，姐姐素颜素衣，头上带着些许的白发，看得出生活比较艰辛，历经岁月的沧桑。后来从妹妹的评价中得知，姐姐有一个儿子，把所有的都给了儿子，这应该是所有的母亲都会做的吧。妹妹打扮时髦，一身的花衣服，烫着头跟于谦老师一样，手上还涂着靓丽的指甲油。一开始妹妹跟广大的“吃瓜群众”一样冷漠，女学生说跟他们在一起比跟僵尸在一起还可怕。但是后来见到了已经变成了僵尸的姐姐，感叹她辛勤劳动了一辈子都是虚妄的。看到自己的亲人受到了社会不公平的待遇，她内心反人类反社会的性格开始表现，不顾他人的劳动成果，毅然地放僵尸大军进来，拉所有人跟她一起陪葬。 5.一个只想自己活命的常务大叔 最后是里面穿西装的常务大叔，一开始对秀安说，如果不认真学习也会变成流浪汉，天真无邪的秀安却引用妈妈的话，说他是坏人，感觉这是导演的铺垫？后来到了前面的车站，他主动跟列车长说要抛下其他乘客跑路。列车长还是挺热心肠的，为了更多乘客着想，拒绝了他，不过他的这种热心肠注定是要被常务大叔所利用的。后来主人公一行想要跟“吃瓜群众”汇合，但是常务大叔这个时候却开始热心肠起来了，口口声声说为了所有的乘客的安全着想，不能让他们把危险带过来，其实内心从头到尾都只是为了自己。他还欺骗“吃瓜群众”说主人公已经被感染，煽动其他乘客将主人公一行赶到了其他车厢去。后来当他和乘务长准备一起逃离时，骗乘务长先出去引开了僵尸，自己独自逃离；在被僵尸追上时，将女高中生推了下去，自己又跑了；在热心的列车长救他后，他却没有帮列车长，而是恩将仇报将列车长拉了下去，自己逃生。 到了最后，交代了自己还有亲人在等他，他想要活着回去。很多人都很痛恨常务大叔，害死了这么多人，但是在灾难面前，有多少人会为他人考虑呢。每个人都想要在灾难面前活下去，每个人都有活下去的权利，我们没有权利决定他人的生死。 还记得有一个网友在豆瓣上的评论是这样的：比丧尸更可怕的是人性。确实，只有在危险的情况下才能展示一个人最真实的一面，人性才能够彻底的暴露出来，这才是最真实的。有的人可能会善良的帮助他人，有的人可能就自己只顾着自己逃生，每个人都有自己的选择，孰是孰非我觉得应该更加理性的看到。有的人总喜欢站在道德的至高点，对他人的言行指指点点，但是自己遇到了一样的情况却并没有做的比他人好，这样的人更加的可怕。 最后，国庆马上要结束了，希望坐高铁回来的童鞋们旅途愉快;-)","tags":[{"name":"推荐","slug":"Recommend","permalink":"http://xieyufei.com/tags/Recommend/"},{"name":"电影","slug":"Movie","permalink":"http://xieyufei.com/tags/Movie/"}]},{"title":"深入理解js中的变量和作用域","date":"2016-09-21T02:51:58.000Z","path":"2016/09/21/JS-Variate-Scope.html","text":"如果把整个js比作是一个作战的军队，作用域就像是军队中的一个个编制单位，负责整编士兵；而变量就像军队中的最小单位—士兵。 变量变量分类 js中的变量分为两种：全局变量和局部变量。全局变量很好理解，就是在js任何地方都能够调用的变量；而局部变量就只能在函数的内部才能够调用的变量。 12345678var a=10;function show()&#123; console.log(&#x27;a:&#x27;+a); //a:10 var b=2; console.log(&#x27;inside b:&#x27;+b); //inside b:2&#125;show();console.log(&#x27;outside b:&#x27;+b); //b is no defined 在上面的程序中，变量a就是一个全局变量，在函数的内部能够调用。但是这里的变量b就是局部变量，当函数结束调用后，变量b就被回收了，因此在函数外部调用失败。 另外需要特别注意的是： 如果在声明局部变量时不用var声明，那么这个变量自动“提升”为全局变量。 12345678var a=10;function show()&#123; console.log(&#x27;a:&#x27;+a); //a:10 b=2; console.log(&#x27;inside b:&#x27;+b); //inside b:2&#125;show();console.log(&#x27;outside b:&#x27;+b); //outside b:2 对比两段代码，如果你在声明b=2时没有写var，那么b就隐式地声明为全局变量，在函数外面还是能够被调用到的。 虽然使用全局变量能够在任何地方调用，很方便，但是全局变量的优点也给他带来了缺点： 一直占用内存：全局变量保存在静态存储区，如果全局变量过多会占多大量内存，严重影响页面的性能。 影响了函数的独立性：一般函数都是传入参数和传出返回值进行运算的，如果函数依赖于全局变量，破坏了函数的这种独立性，同时也降低了函数的可移植性。 因此我们在定义变量时一般要尽可能少的定义全局变量。 变量声明 函数声明优先于变量声明 下面我们通过一段代码来说明. 1234var a; function a()&#123;&#125;console.log(typeof a); //function 或许有人是认为函数声明在后面的原因，那么调换一下位置。 1234function a()&#123;&#125;var a; console.log(typeof a); //function 调换位置后变量a的类型还是function，这时候声明变量a的语句没有起作用，被函数声明覆盖了。因此函数声明优先于变量的声明。 但是如果我们在声明的同时给a进行赋值。 1234function a()&#123;&#125;var a=&#x27;xyf&#x27;; console.log(typeof a); //string 我们将其调换一下位置再次进行验证。 1234var a=&#x27;xyf&#x27;; function a()&#123;&#125;console.log(typeof a); //string 可以看到，给变量a进行赋值后，不管变量a在哪，其类型变为字符串类型，上面两段代码相当于如下代码： 12345function a()&#123;&#125;var a;a=&#x27;xyf&#x27;;console.log(typeof a); //string a最后被赋值为字符串，因此a的类型自然是字符串 作用域块级作用域 js中作用域只有一个函数作用域和全局作用域，一个很大的特点就是js中没有块级作用域。函数作用域是比较容易理解的，那么什么是块级作用域呢？ 任何一对花括号（｛和｝）中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。 理解了块级作用域，来看一下下面的小例子。 12console.log(v); //undefinedvar v = &quot;world&quot;; 这段代码很好理解，由于变量v在没有赋值前使用了，所以是undefined。其实这里存在着声明的提前。 当前作用域内的声明都会提升到作用域的最前面，包括变量和函数的声明 由于js作用域中的声明都会被提升到作用域的最前面，所以，上面的代码相当于： 123var v;console.log(v); //undefinedv = &quot;world&quot;; 这样就能很清晰地理解为什么变量v是undefined的了。 下面我们把变量v放到一个方法中去： 1234if(true)&#123; var v = &quot;hello&quot;;&#125;console.log(v); //hello 在这里由于js没有块级作用域，所以if方法没有“形成”一个封闭的作用域，并不能够“阻挡”外面的代码获取里面的变量。 函数作用域 我们再把变量v放到函数中去： 12345function show()&#123; var v=&#x27;world&#x27;;&#125;show();console.log(v); //undefined 由于show函数是一个函数作用域，“阻挡”外面的代码获取里面变量（并不能阻挡里面的代码获取外面的变量），所以函数外部并不能获取到函数里面的变量v。因此证明了js中只有函数作用域，没有块级作用域。 再来看下面的一段代码： 123456var v=&#x27;hello&#x27;;function show()&#123; console.log(v); //undefined var v=&#x27;world&#x27;;&#125;show(); 很多人看到这边都会很疑惑，不是说这边show函数中能够获取到函数外面的变量的么？但是由于这边是一个函数作用域，而函数作用域存在着变量声明的提前，因此，上面的代码相当于下面的代码： 1234567var v=&#x27;hello&#x27;;function show()&#123; var v; console.log(v); //undefined v=&#x27;world&#x27;;&#125;show(); 这里把变量v的声明放到了整个函数作用域的最前面，因此显示为undefined。理解了上面的代码，相信下面的代码也不难理解了。 12345var v = &quot;hello&quot;;(function()&#123; console.log(v); var v = &quot;world&quot;;&#125;)(); 在这里自执行函数形成了函数作用域 需要注意的是 变量提升只提升函数的声明，并不提升函数的定义 12345show(); //show is not a functionvar show=function()&#123; //...&#125;show(); //成功运行 或许有人有疑问，为什么这边定义的函数就不能执行呢？在这里我们需要明白函数在js中是如何进行定义的。函数有两种定义方式，一种是函数声明，另一种是函数表达式。那么什么是函数声明什么是函数表达式呢？ 12345678//函数声明function show()&#123; //....&#125;//函数表达式var show=function()&#123; //...&#125; 乍一看，他们长得很像，写法都差不多，但是实际上还是有区别的。js的解析器对函数声明和函数表达式并不是一视同仁的对待的，有点“种族歧视”的意思在里面。 函数声明就像是“一等公民”，js会优先读取，确保在执行前就已经被解析了，所以函数声明放在当前作用域的任何地方都能够被调用，甚至放到调用函数声明之后面。 而函数表达式就显得比较“普通”，和一般的变量一样，只有到执行到该行时才进行解析，因此，调用函数表达式要在定义后进行使用。","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"面试","slug":"Interview","permalink":"http://xieyufei.com/tags/Interview/"},{"name":"js","slug":"js","permalink":"http://xieyufei.com/tags/js/"}]},{"title":"js中闭包的用法整理","date":"2016-09-20T13:48:47.000Z","path":"2016/09/20/Js-Closure.html","text":"闭包在js中比较常见，是js的一种特色，但同时也是js的一个难点。很多面试题都喜欢考核对js闭包的理解。这篇文章整理了js的一些常见的用法。 什么是js闭包 对于js闭包，官方的解释是这样的： 一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。 第一次读估计很难理解，什么绑定变量的环境表达式、表达式的一部分，都是些什么鬼。用通俗一点的话来说就是： 一个函数中有许多变量，这些变量变成了函数的一部分。闭包就是能够获取到函数内部变量的函数。 因此，闭包也称为闭包数据，闭包的本质也就是函数。 要理解闭包，首先要来理解两个概念：变量和作用域。在这里不多阐述，可以看笔者的另一篇文章《深入理解js中的变量和作用域》。 闭包的产生 由于函数作用域的封闭性，函数外部并不能访问函数内部的变量。 1234function func()&#123; var n=999;&#125;console.log(n); // n is not defined 但是有时候我们需要用到函数内部的变量，这时候闭包就派上用处了。我们将上面的代码改造一下，就能够获取到func函数内部的变量。 1234567891011121314function func()&#123; var n=999; add=function()&#123; n++; &#125; function show()&#123; return n; &#125; return show;&#125;var tempShow=func();console.log(tempShow()); //999add();console.log(tempShow()); //1000 这里的tempShow函数其实就是一个闭包show函数。它是通过最外层的func函数运行后进行赋值的。tempShow函数运行后就获取到了func函数内部的变量n。 那为什么func函数运行之后变量n没有被垃圾回收机制回收掉呢？在《深入理解js中的变量和作用域》中我们说过了，全局变量是保存在静态存储区的，由于静态存储区中的变量是不会被回收掉的。而在这里我们将函数show赋值给全局变量tempShow，而函数show是函数func的子函数，因此，函数func也保存在静态存储区了。所以我们可以在任何地方调用tempShow方法。 在这段代码中，很巧妙的定义了一个add函数，没有在add前使用var关键字，因此函数add是一个全局变量而不是局部变量，可以在函数的外部调用对变量n进行操作。函数add也是一个闭包函数。 理解了上面的代码，相信下面的代码也不难理解了。 1234567891011var name = &quot;The Window&quot;;var object = &#123; name : &quot;My Object&quot;, getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;;var temp=object.getNameFunc();console.log(temp()); //The Window 在这里出现了一个新的变量this，读者们可以通过笔者的这篇文章《Js中this的用法》大致的了解this。由于函数temp调用的环境不在object内部进行了调用，因此函数中的this指代了全局变量window。为了达到获取object内部name的效果，我们对上面的代码进行改造： 123456789101112var name = &quot;The Window&quot;;var object = &#123; name : &quot;My Object&quot;, getNameFunc : function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125;&#125;;var temp=object.getNameFunc();console.log(temp()); //My Object 或者这样改造，使用bind方法，将temp函数的作用域绑定到object上。 123456789101112var name = &quot;The Window&quot;;var object = &#123; name : &quot;My Object&quot;, getNameFunc : function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125;&#125;;var temp=object.getNameFunc().bind(object);console.log(temp()); //My Object 闭包不仅能够返回一个函数，还能够返回其他类型的数据，比如下面的代码返回了一个数组对象。 12345678910111213function createFunctions()&#123; var result = new Array(); for (var i=0; i &lt; 10; i++)&#123; result[i] = function()&#123; return i; &#125;; &#125; return result;&#125;var funcs = createFunctions();for (var i=0; i &lt; funcs.length; i++)&#123; console.log(funcs[i]()); //10个10&#125;","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"面试","slug":"Interview","permalink":"http://xieyufei.com/tags/Interview/"},{"name":"js","slug":"js","permalink":"http://xieyufei.com/tags/js/"}]},{"title":"Js中this的用法","date":"2016-09-18T04:02:50.000Z","path":"2016/09/18/Explain-Js-This.html","text":"this在js中是一个常见的变量，在不同的函数中this指代了不同的变量。刚开始我很困惑，怎么在这里是这个意思，到了相似的函数中却又改变了意思，让我很摸不着头脑。所以整理一下this的用法 全局作用域中的this 在全局作用域中，this指向了Window对象。 12this.name=&#x27;xyf&#x27;;console.log(this); 在上面我们把name挂载到了全局作用域Window下面，其实我们在用var声明变量的时候也是把变量挂载到Window下面。所以上面的操作等价于下面的操作 12var name=&#x27;xyf&#x27;;console.log(this); 函数中的this 在js中函数分为普通的函数和构造函数，主要的区别就是函数的调用形式。普通函数能够直接调用，而构造函数是不能调用，需要用new实例化。 普通函数中的this 普通函数的中this指向了Window对象 1234function show(name)&#123; this.name=name;&#125;show(&#x27;xyf&#x27;); 这时候函数show作为一个普通函数调用，虽然看起来像构造函数，但是内部的this却指向了Window对象，如果你在控制台打印Window对象，它下面挂载了name属性 构造函数中的this 构造函数中的this则指向了它所实例化的对象 12345function show(name)&#123; this.name=name;&#125;var myshow=new show(&#x27;xyf&#x27;);console.log(myshow.name); //&#x27;xyf&#x27; 在这里如果你直接调用show(‘xyf’)跟普通函数没有区别，通过new实例化一个myshow对象，这时候this就指向了这个实例化出来的对象 对象中的this 对象中的this指向了当前对象 1234567891011var person=&#123; name=&#x27;origin&#x27;, setName:function(name)&#123; this.name=name &#125;, getName:function()&#123; return this.name; &#125;&#125;person.setName(&#x27;xyf&#x27;);console.log(person.getName()); //&#x27;xyf&#x27; 但是如果对象的函数中嵌套了其他函数，this的指向就被改变了。 嵌套自执行函数12345678910111213var person=&#123; name=&#x27;origin&#x27;, setName:function(name)&#123; (function(name)&#123; this.name=name; &#125;)(name); &#125;, getName:function()&#123; return this.name; &#125;&#125;person.setName(&#x27;xyf&#x27;);console.log(person.getName()); //&#x27;origin&#x27; 这时候自执行函数中的this指向了全局对象Window，所以setName()函数并不能产生作用。 嵌套回调函数12345678910111213var person=&#123; name=&#x27;origin&#x27;, setName:function(name)&#123; $(&#x27;.temp&#x27;).on(&#x27;click&#x27;,function(e)&#123; this.name=name; &#125;); &#125;, getName:function()&#123; return this.name; &#125;&#125;person.setName(&#x27;xyf&#x27;);console.log(person.getName()); //&#x27;origin&#x27; 这里的this指向了$(‘.temp’)这个对象。为了避免这些情况，我们先将this赋值给局部变量that，然后使用that。这时候that就指向了我们需要的对象。 1234var that=this;(function(name)&#123; that.name=name;&#125;)(name); 特别声明 如果将一个对象中的函数赋值给一个变量，再通过该变量调用这个函数，此时函数中的this指向Window对象，即使这个操作在回调函数中。 12345678910111213141516171819var person=&#123; name:&quot;person&quot;, setName:function(name)&#123; this.name=name &#125;, getName:function()&#123; return this.name; &#125;&#125;var temp=&#123; name:&quot;temp&quot;, tempFun:function()&#123; $(&#x27;.temp&#x27;).on(&#x27;click&#x27;,function()&#123; var fun=person.getName; fun(); //&#x27;&#x27; &#125;) &#125;&#125;temp.tempFun(); 使用apply和call函数改变this指向 这两个函数都能够手动指定被调用函数内部this指向哪个对象。 123456789101112131415function person(name)&#123; this.name=&quot;&quot;; this.setName=function(name)&#123; this.name=name; &#125;&#125;var p1=new person(&#x27;p1&#x27;);var p2=new person(&#x27;p2&#x27;);p1.setName(&#x27;p1&#x27;);p2.setName(&#x27;p2&#x27;);//p1.setName.apply(p2,[&#x27;c&#x27;]);p1.setName.call(p2,&#x27;c&#x27;);console.log(p2.name); //&#x27;c&#x27; 当对象p1使用apply函数后，p1对象中的this就指向了对象p2，此时对象p1的setName函数的操作就作用在了p2对象上。","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"面试","slug":"Interview","permalink":"http://xieyufei.com/tags/Interview/"},{"name":"JS","slug":"JS","permalink":"http://xieyufei.com/tags/JS/"}]},{"title":"Windows程序员必备小工具推荐","date":"2016-09-16T00:49:40.000Z","path":"2016/09/16/Windows-Tools-Recommend.html","text":"作为一个程序猿，有一个好的撸码工具肯定会让你的效率成倍的提升。这篇文章总结了自笔者工作以来用过的比较好的提升效率的Windows下的小工具，推荐给大家来用(非广告)，这些小工具不仅仅是撸码的，还有其他的一些软件。 工欲善其事，必先利其器 “工”是指的工作，一件事情要想做好，必定先要让工具“锋利”。 撸码神器Sublime Text推荐指数★★★★★ Sublime是我用过的最好的撸码神器，没有之一。那些撸码还在用什么EditPlus、DreamWeaver的，和Sublime比，简直就是拿石器时代的石器武器和二十一世纪的大规模杀伤性武器做比较。Sublime拥有漂亮的用户界面和无比强大的功能，例如代码的缩略图、自定义按键绑定、拼写检查、项目切换、多窗口等等。Sublime的界面如下： Sublime还能支持多种编程语言的语法高亮，有优秀的代码自动补全的功能。而且Sublime还有非常强大的插件系统作为其功能的补充。一些常见和实用的插件如Emmet(快速编写 HTML/CSS 代码的方案)、ColorPicker(颜色选择器)、MarkdownPreview(markdown预览)、DocBlockr(代码注释规范)、SideBar(侧边栏工具)等等，其他一些强大的插件等待读者去体验。 小孩桌面便签推荐指数★★★☆☆ 大家在上学的时候肯定都用过便签纸一类的东西来记一些上课笔记之类的东西，然后贴在课本上，整个课本就贴的花花绿绿的。小孩桌面便签就是这样一个在桌面上贴上便签的工具。正如它的名字一样：DeskNotes(桌面贴纸)。 这是我一个女同事推荐我使用的，刚开始我还很不屑的，没怎么用。后来随着工作越来越多，渐渐的发现……脑子越来越不够用了。然后我就把这个工具用起来了，确实能够提醒我很多事情。它的界面如下： 除了能够添加贴纸外，小孩便签还增加了实用的小功能，如闹钟提醒和定时关机。 FastStone Capture推荐指数★★☆☆☆ 由于笔者从事网页的工作，经常要和图片打交道，所以经常需要截图、取色、测量像素等等。这是笔者在上学时一个老师推荐的软件，基本能够解决上述需求。FastStone Capture的界面如下： 很多读者可能会说：那你用PhotoShop啊，功能更强悍。诚然，PhotoShop功能确实相当的强悍，笔者的电脑里也装了，但是体积大，而且又十分的吃内存，每次打开都要耗不少时间(估计是电脑太老了)。 相比于PhotoShop，FastStone Capture就轻巧了不少。整个软件的大小不超过3MB，通过任务管理器看到所占用的内存仅0.3MB，基本上可以忽略不计，每次打开基本上都是秒开的。 它的主要功能有截图、屏幕录像、图像处理(裁切，改变图像效果等)。附带的特色小功能有屏幕放大器、屏幕取色器、屏幕标尺、图像转为PDF，功能可是非常的强大。 有道云笔记推荐指数★★☆☆☆ 有的读者可能会说：欸，上面不是有小孩桌面便签可以用来记事了么，怎么还要有道云笔记呢。诚然，便签是可以记录生活中的琐事，但是要想把记录的内容从一台电脑转移到另一台电脑却比较费时。 笔者的所处的环境就是需要在多个地点记录，比如上班的时候看到有用的东西需要记录下来，下班在家里做一些学习笔记也需要记录下来，虽然小孩桌面便签有强大的导入导出功能，但是频繁的导入导出操作也是比较麻烦的，或许是笔者比较懒。 这个时候使用有道云笔记就可以很方便的在“云上”进行办公，而且还支持Android、iPhone、iPad、Mac、WP和web等平台，让工作摆脱了平台和设备的限制。有道云笔记还支持多种编辑格式，可以用富文本进行编辑也可以采用Markdown语法进行编辑，Markdown支持有预览的功能。读者还可以将写的文章比较好的文章在微博、微信和扣扣中进行分享。 Beyond Compare推荐指数★★★★☆ 在工作和生活中，笔者经常会将文件添加上版本号以区分，但是时间一长，就会忘记不同的版本号所更改的内容，所以经常需要一一地比对，这就让笔者很苦恼。有一天在上网时无意中发现了这款“神器”，让我们来看看它长什么样： Beyond Compare主要用途是对比两个文件夹或者文件的不同，并将差异 通过颜色的不同以标识。对的，你没有看错，就是文件夹的不同。它还可以按照你的需要进行比较，比如需要对比文件的不同或者对比文件的相同，都可以显示。 Everything推荐指数★★★★★ 由于笔者的每天工作都会收到很多不同文件，但是笔者又不善于对文件归类存放，都是杂乱的放在桌面，需要用到的时候找起来又相当的麻烦。这时候Everything这款文件快速搜索软件就成为我们这种“懒人”的福音了。他的界面如下： 它的体积也相当的轻巧，才30多MB，和现在动辄几百MB的软件相比确实小了很多；它的界面也很简洁易用，常用的就一个输入框和下面的文件列表，非常方便日常的使用；占用系统资源极低，Everything搜索只基于文件和文件夹的名称，所以建立起搜索数据库非常的快，搜索文件基本上都是秒搜。 Chrome推荐指数★★★★★ Chrome是笔者用过最好用的浏览器，没有之一。不管是日常生活中的使用还是开发中的测试等，Chrome都能够轻松胜任。 Chrome的特点是简洁、快速。它支持多个标签进行浏览，即使有一个标签崩溃，其他标签页不会崩溃。而且，Chrome是基于V8 JavaScript引擎的，页面性能更加优异。 对于像笔者一样的网页开发者来说，Chrome更是开发网页的“利器”。使用F12调出控制台，在这里你能看到Elements(页面元素)、Console(网页运行的提示消息)、Sources(页面运行所加载的源码)、Resources(页面所需要的文件、存储的cookie和session等资源)、Network(可以看到网页加载脚本样式页面的时间还有异步的资源)","tags":[{"name":"推荐","slug":"Recommend","permalink":"http://xieyufei.com/tags/Recommend/"}]},{"title":"Git命令学习（上）","date":"2016-09-11T01:48:00.000Z","path":"2016/09/11/Git-Command-Start.html","text":"git是一个开源的分布式版本控制系统，可以很高效的处理不同规模的项目的版本管理。git的命令比较多，在这篇文章中主要介绍了各种git命令的基本操作。本文比较基础，适合入门。 1. 创建版本库创建目录12mkdir examplecd example 将这个目录变成版本库1git init 目录下多一个.git目录，用来跟踪管理版本库，你也可以把线上的项目克隆到本地，使用下面的命令 1git clone [url] 2.将文件添加到版本库追踪文件1git add [filename] 或者一次性添加所有未追踪的文件 1git add . 提交到仓库1git commit -m &quot;[you description]&quot; 3.查看当前仓库的状态1git status 这个命令用来查看仓库的详细状态，添加-s查看简要的状态(s表示short) 1git status -s 简要状态下前面的符号代表的意思： ?? 表示添加文件后而未追踪的文件 M 表示修改文件(Modify) A 表示添加文件后追踪了该文件(Add) D 表示删除文件(Delete) 简要状态下颜色的不同也有区别。如果是红色，则表示该文件修改后没有追踪；是绿色则表示修改后追踪了改文件。 4.对比文件差异 git diff(difference)此命令比较的是工作目录中当前文件和暂存区域快照之间的差异,也就是修改之后还没有暂存起来的变化内容 1git diff 如果使用add命令追踪该文件后，diff命令失效。 5.显示提交的日志1git log log命令用于显示从最近到以前的提交日志，commit后面显示的一长串字符数字是该次提交所对应的版本号，每次都不会重复的。log命令显示的信息比较多，可以加上 –pretty=oneline 参数 1git log --pretty=oneline 在下面的版本回退中需要用到提交日志的版本号，这时候就需要复制这个版本号。在windows下复制git窗口中的内容的快捷键是Ctrl+Insert，粘贴是Insert 6.版本回退1git reset --hard [LogId] reset命令用于控制版本回退到之前提交时的状态。这边的LogId就是上一节中复制出来的版本号。 7.撤销修改1git checkout -- [filename] checkout命令让你在工作区做的修改全部撤销，回到上一次commit时的状态。 8.删除文件 如果你在工作区删除了一个文件，那么status就会提醒你工作区和暂存区不一致。这时候你有两种选择，一个是git rm命令确认删除， 1git rm [filename] 这个命令相当于同时进行了删除命令和追踪文件命令，其等价命令如下： 12rm [filename]git add [filename] 另一个是通过checkout命令找回删除的文件 1git checkout -- [filename]","tags":[{"name":"面试","slug":"Interview","permalink":"http://xieyufei.com/tags/Interview/"},{"name":"git","slug":"git","permalink":"http://xieyufei.com/tags/git/"}]},{"title":"CraftyJs初探","date":"2016-07-08T14:00:00.000Z","path":"2016/07/08/CraftyJs-Start.html","text":"前不久听了一趟分享课，分享课的主题是JS游戏的制作，但是如果是自己写游戏比较的繁琐，如果能应用一个游戏引擎，就能大大的简化游戏的开发速度和开发效率，于是我在网上参考了几个游戏引擎，找到了CraftyJs这个游戏引擎还是挺不错的，但是苦于网上的教程不是很全面，所以今天就开个坑，写个入门级的教程，仅供参考。 初始化 首先从官网上下载CraftyJs的脚本引用到项目中来。然后就可以开始写我们自己的程序了。 1CraftyJs.init(this.config.width,this.config.height); 这段代码用于初始化整个stage，用官方的话来说就是舞台，所有的元素将在这整个舞台里活动。这个舞台的宽度是this.config.width(px)，高度是this.config.height(px)。如果有元素超出了舞台的范围，这个元素将被遮住，因为整个舞台设置了样式overflow:hidden将超出的元素隐藏掉。 1Crafty.background(&quot;#f0f0f0&quot;); 你还可以通过background()方法给整个舞台设置背景颜色 放置场景 当整个舞台初始化后就可以玩游戏了吧？不！你去剧院看戏一入座演员就给你演戏么，当然不是，还需要一些场景的带入和切换。这些场景比如加载动画、菜单选项等一系列。 1234567891011Crafty.defineScene(&quot;loading&quot;, function() &#123; Crafty.background(&quot;#000&quot;); Crafty.e(&quot;2D, DOM, Text&quot;).attr(&#123; w: 100, h: 20, x: 150, y: 120 &#125;).text(&quot;Loading&quot;).css(&#123; &quot;text-align&quot;: &quot;center&quot; &#125;).textColor(&quot;#FFFFFF&quot;);&#125;); 我们可以使用Crafty.defineScene()方法来定义一个场景。在这里我们定义了一个叫loading的场景，里面只有一个元素就是一行”Loading”的字。但是定义好了场景并没有显示在舞台上，因为这个场景并没有被调用到。 1Crafty.enterScene(&quot;loading&quot;); 通过enterScene()这个方法来展示刚才我们定义好场景，你会在舞台上看到这个场景。这个展示舞台的方法可以在任何地方被调用。但是需要注意的是这个方法会清除舞台上所有的元素，除了那些有”Persist”组件的元素（组件这一名词下面会解释到）。 实体/组件系统 现在到了CraftyJS最重要的部分来了，就是CraftyJS独特的实体/组件系统。这个系统有点面向对象编程的意思。整个系统分为两个部分。 组件系统 所谓的组件，有点类似JAVA中的对象（不是现实里的对象），看不见摸不着，是对实体的抽象。每个组件里封装了对应的方法，可以在实体中直接调用。CraftyJS中有很多已经被预先定义好的组件可以直接拿来使用，而且组件可以被重复地继承。 实体系统 实体是真正看得见的元素，是对组件的“实例化”。一个单一的实体能够继承多个实体。 1var square = Crafty.e(&#x27;2D, DOM, Color&#x27;); 这样就通过e()方法定义了几个叫”square”的实体。这个实体继承了三个组件”2D”、”DOM”和”Color”，这三个组件预先在CraftyJS中就已经被定义好了。如果你觉得单单使用这三个组件还不够，你可以后续往”square”这个实体中再添加组件。 1square.addComponent(&quot;Text&quot;); 通过addComponent()方法向实体中加入”Text”组件，这个方法支持一次添加多个组件。 1square.addComponent(&quot;Text,Mouse&quot;);//这是可以的 你还可以通过has()方法判断某个实体中是否含有某个组件 1square.has(&quot;Mouse&quot;); 这个方法返回一个boolean类型的值。但是需要注意的是这个方法一次性只能判断一个组件存在，并不支持同时判定多个组件比如： 1square.has(&quot;2D,DOM&quot;);//这是错误的 如果你对某个组件不满意，你还可以把它删掉，这个方法也不支持传入两个以上的组件名称 1square.removeComponent(&quot;2D&quot;); 常用的组件、属性和方法 一些常用的组件是CratyJs帮我们定义好了，我们直接使用就可以了。 “2D”组件 2D组件是CraftyJS预先给我们定义好的一个组件，是最常用的组件之一。他提供了一个attr()的方法让我们来设置实体的属性值。 123456789square.attr(&#123; x: 150, y: 150, w: 100, h: 100, alpha: 0.5, rotation: 45, visible:true &#125;); 这里的x和y是实体相对于舞台左上角的位置，单位都为像素(px)。w和h是实体的宽度和高度，单位也是像素(px)。alpha是实体的透明度，取值范围是0到1。visible代表实体是否可见，只能接受boolean类型的参数。x、y、w、h如果不设置值，默认为0。 “Text”组件 Text组件有四个方法可以使用，分别是text()、textColor()、textFont()和unselectable()。text()方法用于设置组件里面的内容。 1Crafty.e(&quot;2D,DOM,Text&quot;).text(&quot;hello world!&quot;); text()方法支持传入一个方法，但是这个方法必须要返回一个字符串类型的参数，否则这个组件的内容将会显示undefined(未定义)。 123Crafty.e(&quot;2D, Canvas, Text&quot;).text(function () &#123; return &quot;hello world!&quot;;&#125;); textColor()方法用来设置组件文字的颜色，你可以使用HEX、rgb或者rgba的方式来定义颜色。 123Crafty.e(&quot;2D, DOM, Text&quot;).textColor(&#x27;#FF0000&#x27;) .textColor(&#x27;rgba(0, 255, 0, 0.5)&#x27;) .textColor(&#x27;white&#x27;); textFont()方法用来设置文字的字体。如果有多个字体的属性，传入一个对象的方式进行设置，Crafty支持设置的属性有以下几个： 1Crafty.e(&quot;2D, DOM, Text&quot;).textFont(&#123; &#x27;type&#x27;: &#x27;italic&#x27;, &#x27;family&#x27;: &#x27;Arial&#x27; , &#x27;size&#x27;:&#x27;20px&#x27;, &#x27;weight&#x27;:&#x27;bold&#x27;, &#x27;lineHeight&#x27;:&#x27;30px&#x27;&#125;); unselectable()方法设置Text组件中的内容不能被高亮选中。Canvas的Text是不能被高亮选中的，所以这个方法只对DOM的Text组件有效。 1Crafty.e(&quot;2D, DOM, Text&quot;).text(&#x27;This text cannot be highlighted!&#x27;).unselectable();","tags":[{"name":"前端","slug":"FrontEnd","permalink":"http://xieyufei.com/tags/FrontEnd/"},{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://xieyufei.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"CraftyJs","slug":"CraftyJs","permalink":"http://xieyufei.com/tags/CraftyJs/"}]},{"title":"JAVA处理跨域问题","date":"2016-05-28T05:58:00.000Z","path":"2016/05/28/Java-Ajax.html","text":"在写前端脚本的时候我们经常会遇到发送数据到后台的情况，但是由于浏览器的限制，不同域名之间的数据是不能互相访问的，那前端怎么和后端如何进行数据之间的交换呢？ JavaScript由于安全性方面的考虑，不允许页面跨域调用其他页面的对象，那么问题来了，什么是跨域问题？答：这是由于浏览器同源策略的限制，现在所有支持JavaScript的浏览器都使用了这个策略。那么什么是同源呢？所谓的同源是指三个方面“相同”： 域名相同 协议相同 端口相同 下面就举几个例子来帮助更好的理解同源策略。 URL 说明 是否允许通信 http://www.a.com/a.js http://www.a.com/b.js 同一域名 允许 http://www.a.com/a.js http://www.b.com/a.js 不同域名 不允许 http://www.a.com:8000/a.jshttp://www.a.com/b.js 同一域名不同端口 不允许 https://www.a.com/a.js http://www.a.com/b.js 同一域名不同协议 不允许 在JAVA中处理跨域问题，通常有以下两种常用的解决方法。 第一种解决方法 后台代码在被请求的Servlet中添加Header设置： 12345678910111213response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);PrintWriter out =null;try&#123; out = response.getWriter();&#125; catch (IOException e)&#123; // TODO Auto-generated catch block e.printStackTrace();&#125;out.print(&quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;);out.flush();out.close(); Access-Control-Allow-Origin这个Header在W3C标准里用来检查该跨域请求是否可以被通过，如果值为*则表明当前页面可以跨域访问。默认的情况下是不允许的。 在前端JS中需要向Servlet发出请求，请求代码如下所示： 12345678910$.ajax(&#123; url: &quot;your url&quot;, type:&quot;get or post&quot;, dataType:&quot;json&quot;, data:&#123; .... &#125;, success:function(data)&#123; ... &#125; 第二种解决方法 通过jsonp跨域请求的方式。JSONP和JSON虽然只有一个字母的区别，但是他们完全就是两回事，很多人很容易把他们搞混。JSON是一种数据交换的格式，而JSONP则是一种非官方跨域数据交互协议。 首先来说一下前端JS是怎么发送请求。代码如下所示： 12345678910111213141516$.ajax(&#123; url:&quot;your url&quot;, type:&quot;get or post&quot;, async:false, dataType : &quot;jsonp&quot;, //服务端用于接收callback调用的function名的参数 jsonp:&quot;callbackparam&quot;, //callback的function名称 jsonpCallback:&quot;success_jsonpCallback&quot;, success:function(data)&#123; console.log(data); &#125;, error:function(data)&#123; console.log(data); &#125;&#125;); 这里的callbackparam和success_jsonpCallback可以理解为发送的data数据的键值对，可以自定义，但是callbackparam需要和后台约定好参数名称，因为后台需要获取到这个参数里面的值（即success_jsonpCallback）。 下面，最重要的来了，后台怎么样获取和返回数据呢。代码如下所示: 1234567891011121314PrintWriter out =null;String callback=req.getParameter(&quot;callbackparam&quot;);String json=callback+&quot;(&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;)&quot;;try&#123; out = resp.getWriter();&#125; catch (IOException e)&#123; // TODO Auto-generated catch block e.printStackTrace();&#125;out.print(json);out.flush();out.close(); 首先需要获取参数名为callbackparam的值，这里获取到的值就是“success_jsonpCallback”。然后将这个值加上一对小括号。小括号里放入你需要返回的数据内容，比如这里我返回一个JSON对象。当然你也可以返回其他对象，比如只返回一个字符串类型数据也可以。最后前端JS返回的数据就是这样的： 1success_jsonpCallback(&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;) 浏览器会自动解析为json对象，这时候你只需要在success回调函数中直接用data.status就可以了。","tags":[{"name":"Java","slug":"Java","permalink":"http://xieyufei.com/tags/Java/"},{"name":"异步跨域","slug":"异步跨域","permalink":"http://xieyufei.com/tags/%E5%BC%82%E6%AD%A5%E8%B7%A8%E5%9F%9F/"}]}]