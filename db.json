{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/images/Film-TrainToBusan/end.jpg","path":"images/Film-TrainToBusan/end.jpg","modified":1,"renderable":0},{"_id":"source/images/Front-Tiny-WeChat/interface.png","path":"images/Front-Tiny-WeChat/interface.png","modified":1,"renderable":0},{"_id":"source/images/Film-TrainToBusan/sister.jpg","path":"images/Film-TrainToBusan/sister.jpg","modified":1,"renderable":0},{"_id":"source/images/Windows-Tools-Recommend/Beyond-Compare.png","path":"images/Windows-Tools-Recommend/Beyond-Compare.png","modified":1,"renderable":0},{"_id":"source/images/Windows-Tools-Recommend/FastStone-Capture.png","path":"images/Windows-Tools-Recommend/FastStone-Capture.png","modified":1,"renderable":0},{"_id":"source/images/Windows-Tools-Recommend/everything.png","path":"images/Windows-Tools-Recommend/everything.png","modified":1,"renderable":0},{"_id":"themes/indigo/source/img/cc.png","path":"img/cc.png","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/style.less","path":"css/style.less","modified":1,"renderable":1},{"_id":"themes/indigo/source/img/brand.jpg","path":"img/brand.jpg","modified":1,"renderable":1},{"_id":"themes/indigo/source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":1},{"_id":"themes/indigo/source/img/img-loading.png","path":"img/img-loading.png","modified":1,"renderable":1},{"_id":"themes/indigo/source/img/img-err.png","path":"img/img-err.png","modified":1,"renderable":1},{"_id":"themes/indigo/source/img/logo.jpg","path":"img/logo.jpg","modified":1,"renderable":1},{"_id":"themes/indigo/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/indigo/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/indigo/source/js/waves.min.js","path":"js/waves.min.js","modified":1,"renderable":1},{"_id":"source/images/Film-TrainToBusan/bad.jpg","path":"images/Film-TrainToBusan/bad.jpg","modified":1,"renderable":0},{"_id":"themes/indigo/source/js/wxshare.js","path":"js/wxshare.js","modified":1,"renderable":1},{"_id":"themes/indigo/source/img/wechat.png","path":"img/wechat.png","modified":1,"renderable":1},{"_id":"themes/indigo/source/js/zepto.min.js","path":"js/zepto.min.js","modified":1,"renderable":1},{"_id":"source/images/Windows-Tools-Recommend/YNote.png","path":"images/Windows-Tools-Recommend/YNote.png","modified":1,"renderable":0},{"_id":"source/images/Windows-Tools-Recommend/DesktopNotes.jpg","path":"images/Windows-Tools-Recommend/DesktopNotes.jpg","modified":1,"renderable":0},{"_id":"source/images/Windows-Tools-Recommend/Sublime-UI.png","path":"images/Windows-Tools-Recommend/Sublime-UI.png","modified":1,"renderable":0},{"_id":"themes/indigo/source/img/alipay.png","path":"img/alipay.png","modified":1,"renderable":1},{"_id":"themes/indigo/source/img/head.png","path":"img/head.png","modified":1,"renderable":1},{"_id":"source/images/Windows-Tools-Recommend/chrome.jpg","path":"images/Windows-Tools-Recommend/chrome.jpg","modified":1,"renderable":0},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.eot","path":"css/fonts/roboto/Roboto-Bold.eot","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff","path":"css/fonts/roboto/Roboto-Bold.woff","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff2","path":"css/fonts/roboto/Roboto-Bold.woff2","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.eot","path":"css/fonts/roboto/Roboto-Light.eot","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff","path":"css/fonts/roboto/Roboto-Light.woff","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff2","path":"css/fonts/roboto/Roboto-Light.woff2","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.eot","path":"css/fonts/roboto/Roboto-Medium.eot","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff","path":"css/fonts/roboto/Roboto-Medium.woff","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff2","path":"css/fonts/roboto/Roboto-Medium.woff2","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.eot","path":"css/fonts/roboto/Roboto-Regular.eot","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff2","path":"css/fonts/roboto/Roboto-Regular.woff2","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.eot","path":"css/fonts/roboto/Roboto-Thin.eot","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff","path":"css/fonts/roboto/Roboto-Thin.woff","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff2","path":"css/fonts/roboto/Roboto-Thin.woff2","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/FontAwesome.otf","path":"css/fonts/fontawesome/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.eot","path":"css/fonts/fontawesome/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff","path":"css/fonts/roboto/Roboto-Regular.woff","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff","path":"css/fonts/fontawesome/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff2","path":"css/fonts/fontawesome/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.ttf","path":"css/fonts/roboto/Roboto-Light.ttf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.ttf","path":"css/fonts/roboto/Roboto-Medium.ttf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.ttf","path":"css/fonts/roboto/Roboto-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.ttf","path":"css/fonts/roboto/Roboto-Bold.ttf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.ttf","path":"css/fonts/roboto/Roboto-Thin.ttf","modified":1,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.ttf","path":"css/fonts/fontawesome/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"source/images/Film-TrainToBusan/stage.jpg","path":"images/Film-TrainToBusan/stage.jpg","modified":1,"renderable":0},{"_id":"source/images/Film-TrainToBusan/strong.jpg","path":"images/Film-TrainToBusan/strong.jpg","modified":1,"renderable":0},{"_id":"source/images/Film-TrainToBusan/student.jpg","path":"images/Film-TrainToBusan/student.jpg","modified":1,"renderable":0},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.svg","path":"css/fonts/fontawesome/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"source/images/Film-TrainToBusan/protagonist.jpg","path":"images/Film-TrainToBusan/protagonist.jpg","modified":1,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"902bd8e0fad59929b96c2165469a6b8c709f2bdb","modified":1473649626064},{"_id":"themes/indigo/package.json","hash":"98a8e55a914d218ba26eb8a90a59076f6542a616","modified":1474511011147},{"_id":"themes/indigo/README.md","hash":"a91710ebddfcbeee28ebdccbdd2688ddff8f1560","modified":1474511011136},{"_id":"themes/indigo/_config.yml","hash":"4c16fd6532a347f08c6295da97a8b623f772204a","modified":1474511011136},{"_id":"source/_posts/Front-Tiny-WeChat-Next.md","hash":"e1d1b2f1d3ea67eeb10b5750d9ffe3b8b20ed617","modified":1476418466711},{"_id":"source/_posts/Front-Tiny-WeChat.md","hash":"202aad089c0bf2bcee3b5c4df73350a8c4a2a37f","modified":1476159147692},{"_id":"source/_posts/Git-Command-End.md","hash":"a1f52b67eb240983d8f45959f5e856a91f66d4b8","modified":1475975289223},{"_id":"source/_posts/CraftyJs-Start.md","hash":"6e57d481988a8a16155a79783278bcc979479733","modified":1475975289223},{"_id":"source/_posts/HexoGitHub-Start.md","hash":"e60708b7958d50bc5f0b1c94c71563a8448abcd7","modified":1473757252313},{"_id":"source/_posts/Explain-Js-This.md","hash":"f3b57a7eb2fd902c0e54f94bc44e7b124d08ea58","modified":1475975289223},{"_id":"source/_posts/Film-TrainToBusan.md","hash":"27d31147f58907292f09f0ee19bb4e182ef7e917","modified":1475975289223},{"_id":"source/_posts/Git-Command-Start.md","hash":"7e9f0ba65aaf426047031688c1036b49f0257110","modified":1475975289223},{"_id":"source/_posts/JS-Variate-Scope.md","hash":"0dc7bf748bdb31a8d3851f4eaadd1a446e432323","modified":1475975289223},{"_id":"source/404/index.md","hash":"0f27e6069aefafa833dd73db0ed21f0657af025e","modified":1473732161720},{"_id":"source/_posts/Java-Ajax.md","hash":"bdca8893ed3aa49e80aeb6492338900d40ed4146","modified":1475975289223},{"_id":"source/_posts/Windows-Tools-Recommend.md","hash":"e4ae80f23947526fc06ddc9b560de7e965c0e5f3","modified":1475975289223},{"_id":"source/_posts/Js-Closure.md","hash":"a61bc82e040d14b942de8f425a10d6ea475eb2c4","modified":1475975289223},{"_id":"source/about/index.html","hash":"82e7515de43b90383eafc0a4c5ddf8f4b623ff34","modified":1473649626066},{"_id":"source/categories/index.md","hash":"3001744d51adbd7ba53f6fcbe10c75ea70391155","modified":1473654290901},{"_id":"source/tags/index.md","hash":"911259b7027c572bcf15aa25ddb6a802db0ff7dc","modified":1474511011136},{"_id":"themes/indigo/layout/archive.ejs","hash":"29dd0adde8415dc56032878d3286690e4b8cee66","modified":1474511011145},{"_id":"themes/indigo/layout/index.ejs","hash":"08b1dd8e53de4516ae8dcb61a8bc9155ec0cbe46","modified":1474511011145},{"_id":"themes/indigo/layout/layout.ejs","hash":"415e249dc7c9da8fe496987b024b956dbcc419cf","modified":1474511011146},{"_id":"themes/indigo/layout/page.ejs","hash":"26c42241ae442942fa78e22c99b7ee7debe512e4","modified":1474511011146},{"_id":"themes/indigo/layout/category.ejs","hash":"183ec4632c44243db391b1722aec485073417690","modified":1474511011145},{"_id":"themes/indigo/layout/tag.ejs","hash":"183ec4632c44243db391b1722aec485073417690","modified":1474511011147},{"_id":"themes/indigo/layout/post.ejs","hash":"26c42241ae442942fa78e22c99b7ee7debe512e4","modified":1474511011146},{"_id":"themes/indigo/layout/tags.ejs","hash":"f8e019f8183fc1771f18e344029bc8ecb86272e0","modified":1474511011147},{"_id":"themes/indigo/screenshots/hexo-theme-search.png","hash":"ffa0b5e1ed0f4eea7a1e57f6779c78052df03b5c","modified":1474511011152},{"_id":"themes/indigo/screenshots/hexo-theme-pad.png","hash":"08e41f140682fbd9a78999de79823ed59b1d2232","modified":1474511011149},{"_id":"themes/indigo/screenshots/hexo-theme-phone.png","hash":"1404b4fd664a8a552eed8ab46c0fb3b281c4f007","modified":1474511011151},{"_id":"source/images/Film-TrainToBusan/end.jpg","hash":"ab0f8e15283b7265deebce85943dbaab53d7ba2a","modified":1475734838029},{"_id":"source/images/Front-Tiny-WeChat/interface.png","hash":"0434c878ab87d545b5e5a83db1dc35b4d82ae9ba","modified":1476149956343},{"_id":"source/images/Film-TrainToBusan/sister.jpg","hash":"378b80818ae4bb69569ffc1acb38986db409e0a2","modified":1475808713542},{"_id":"source/images/Windows-Tools-Recommend/Beyond-Compare.png","hash":"414286545d09b61c903e0eb259060fbba9c1da80","modified":1474169108348},{"_id":"source/images/Windows-Tools-Recommend/FastStone-Capture.png","hash":"d9a29285fd80dc3f0970e59111b4b10dd95c1e6d","modified":1474169108352},{"_id":"themes/indigo/layout/_partial/after-footer.ejs","hash":"6f5676fe08dd75f2dc7d8399d36c65636b8a5ccd","modified":1475975289223},{"_id":"themes/indigo/layout/_partial/archive.ejs","hash":"ca6944189b24444f1b7d976c68631977cb21ff4e","modified":1474511011137},{"_id":"themes/indigo/layout/_partial/cnzz.ejs","hash":"dbee64698919aeaeb0923c44b3f8c5402c7b8fed","modified":1474511011138},{"_id":"themes/indigo/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1474511011139},{"_id":"source/images/Windows-Tools-Recommend/everything.png","hash":"ee3a1161dec9929b30fc98f33e1e8aa89b62b69d","modified":1474169108362},{"_id":"themes/indigo/layout/_partial/footer.ejs","hash":"a0678e83e45ec74194773e064d38425164f9f928","modified":1474511011138},{"_id":"themes/indigo/layout/_partial/head.ejs","hash":"50f208704295af71c7c2a151cb16cff74882ccd7","modified":1475975289223},{"_id":"themes/indigo/layout/_partial/header.ejs","hash":"d960ad6c1b49ecee68c8450cb1666d208513b9e4","modified":1474511011139},{"_id":"themes/indigo/layout/_partial/index-item.ejs","hash":"b0cc61079b36dc9922f7a5694b853fe4d7148959","modified":1474511011139},{"_id":"themes/indigo/layout/_partial/loading.ejs","hash":"8b3e037dd5f3d4564012689c5cd6f63caf73df0f","modified":1474511011140},{"_id":"themes/indigo/layout/_partial/mathjax.ejs","hash":"b82771c359969ddf3b384ab4aacdb1bacbb53377","modified":1474511011140},{"_id":"themes/indigo/layout/_partial/search.ejs","hash":"5b8d9b22a189ea0da4d2b04f409d68408712e36c","modified":1474511011144},{"_id":"themes/indigo/layout/_partial/script.ejs","hash":"1d0dd9a2e6494da056fbcf63cb2135ffb142d6e0","modified":1475888379430},{"_id":"themes/indigo/layout/_partial/menu.ejs","hash":"96d9b21c22e8c2048f2023ccbe7134031ecebdca","modified":1474511011140},{"_id":"themes/indigo/layout/_partial/post.ejs","hash":"35a6dc954f331f09a068dbf7ee900d3049c52646","modified":1474511011141},{"_id":"themes/indigo/screenshots/hexo-theme-archive.png","hash":"36fd8e55e6672aa6afbd7f88b68a532c819f4473","modified":1474511011149},{"_id":"themes/indigo/screenshots/hexo-theme-pc.png","hash":"5898394b7664bf87ec1422fe7c21e7e76fb37185","modified":1474511011151},{"_id":"themes/indigo/source/img/cc.png","hash":"ebce75a62b40976a72d43f0bd937d859ac24d87c","modified":1474511011185},{"_id":"themes/indigo/source/css/style.less","hash":"21d76d71fb87ac651bc492a312559d78937f6585","modified":1474511011183},{"_id":"themes/indigo/source/img/brand.jpg","hash":"0e237f1b433851c156e1f1cdaeb044054b3b9879","modified":1474511011185},{"_id":"themes/indigo/source/img/favicon.ico","hash":"88697c9f333e0346f57c2b71a69f300ed9c1d466","modified":1474511011186},{"_id":"themes/indigo/source/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1474511011188},{"_id":"themes/indigo/source/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1474511011187},{"_id":"themes/indigo/source/img/logo.jpg","hash":"a089e42acab93864d33e16801b0ac5dc1617c373","modified":1474511011188},{"_id":"themes/indigo/source/js/main.js","hash":"2e798ba8afe6f02fce9e7bb7288dabcaa1f9e621","modified":1474511011189},{"_id":"themes/indigo/source/js/search.js","hash":"c655a0a41bc478549f64a677e4daf7930f5363c3","modified":1474511011189},{"_id":"themes/indigo/source/js/waves.min.js","hash":"8d5293425bc9f34dac6687ba14d5d2b6ed1a3109","modified":1475888379431},{"_id":"source/images/Film-TrainToBusan/bad.jpg","hash":"f5c4fe87938b87fadf8bef33220a89a13cdc0ac7","modified":1475817663668},{"_id":"themes/indigo/source/js/wxshare.js","hash":"3580088f9283e8a70d19504e8145b20fc49237c4","modified":1475975289223},{"_id":"themes/indigo/source/img/wechat.png","hash":"c58dd178222eaa96dc30e3faf47946583f4d5777","modified":1474511011189},{"_id":"themes/indigo/source/js/zepto.min.js","hash":"ca77092bb911567f63fbd355bc9a09b654ce3402","modified":1475975289223},{"_id":"source/images/Windows-Tools-Recommend/YNote.png","hash":"7ebb65f1e7517dab76dc0d8f3b6f4ecd00bbef36","modified":1474169108356},{"_id":"source/images/Windows-Tools-Recommend/DesktopNotes.jpg","hash":"71cfda4d4cbf1d1eaae1c61cc75ca3ac3a1b3cb7","modified":1474169108350},{"_id":"source/images/Windows-Tools-Recommend/Sublime-UI.png","hash":"c50477a9e4a0821259556b5fca447cfa7978a67b","modified":1474169108355},{"_id":"themes/indigo/layout/_partial/post/head-meta.ejs","hash":"f137c126672769e9571be2bb0a70ea8dda644b0e","modified":1474511011142},{"_id":"themes/indigo/layout/_partial/post/category.ejs","hash":"c08e44cbd7315dec7afb6054b04d3c7b82c3bde8","modified":1474511011141},{"_id":"themes/indigo/layout/_partial/post/nav.ejs","hash":"fbb42e10a402555c54f94d8a7e9a03cb6a794f94","modified":1474511011143},{"_id":"themes/indigo/layout/_partial/post/duoshuo.ejs","hash":"f6b4c4eaafb5ac386273354b5f64a26139b7a3b0","modified":1474511011142},{"_id":"themes/indigo/layout/_partial/post/tag.ejs","hash":"60139e37b41769d218e5cf6f6040c41bd2293728","modified":1474511011144},{"_id":"themes/indigo/layout/_partial/post/comment.ejs","hash":"4d25f0bf9d7dba72908a5819f17b9edcd7361d6c","modified":1474511011141},{"_id":"themes/indigo/layout/_partial/post/reward.ejs","hash":"e73dc0bb5be57e9b7d44a2e9eedc67a18672158b","modified":1474511011143},{"_id":"themes/indigo/layout/_partial/post/title.ejs","hash":"eaad7af7888bddd7095243a43ff38f55ad8c494a","modified":1474511011144},{"_id":"themes/indigo/layout/_partial/post/share.ejs","hash":"5728be1589a7533b10806982abe7ddb9bce23aa9","modified":1474511011143},{"_id":"themes/indigo/layout/_partial/post/date.ejs","hash":"f9a8a0d99b39eec351c4effb2ad8508c8d2395ab","modified":1474511011142},{"_id":"themes/indigo/source/css/_partial/gotop.less","hash":"bad63006b3bd4849bf53ad38482af0d9971061d3","modified":1474511011154},{"_id":"themes/indigo/source/css/_partial/archives.less","hash":"9bf953ae16b8796291ea49b4e60a5174cd787d07","modified":1474511011153},{"_id":"themes/indigo/source/css/_partial/article.less","hash":"6c3c3129fd7d6bf7e43f965c7c7b453466135145","modified":1474511011153},{"_id":"themes/indigo/source/css/_partial/loading.less","hash":"0361039b2abdeb1b41e504fa437df962cda055d2","modified":1474511011156},{"_id":"themes/indigo/source/css/_partial/highlight.less","hash":"4d225a6c7bb4bfec331893000f6a74f189d44ff9","modified":1474511011155},{"_id":"themes/indigo/source/css/_partial/header.less","hash":"439fed29b399232241b52a9c0d8464bdc21ef8c1","modified":1474511011154},{"_id":"themes/indigo/source/css/_partial/postlist.less","hash":"298abc4a58fbd838145d0c036b1fb007f569cf20","modified":1474511011156},{"_id":"themes/indigo/source/css/_partial/layout.less","hash":"abe4f31e97397882862f82e61dd245d90ac278c7","modified":1474511011155},{"_id":"themes/indigo/source/css/_partial/roboto.less","hash":"3e457942995da8840e7662fa6cb551a7e12ea294","modified":1474511011157},{"_id":"themes/indigo/source/css/_partial/reward.less","hash":"68e21650caeffa0575b3e720da91f235453362f3","modified":1474511011156},{"_id":"themes/indigo/source/css/_partial/tags.less","hash":"36e77ccb39b080aab19d9d87fd20882d5ac84ee9","modified":1474511011158},{"_id":"themes/indigo/source/css/_partial/share.less","hash":"a57647250236ca57768bb687f20fc5f8deb55dd0","modified":1474511011157},{"_id":"themes/indigo/source/css/_partial/variable.less","hash":"6871d076083b7541c132eb54664e8d6fd80bf8e8","modified":1474511011158},{"_id":"themes/indigo/source/css/_partial/waves.less","hash":"a8b41b0b0c8ff2f6cf95f7f9784611dd8c212ffe","modified":1474511011158},{"_id":"themes/indigo/source/img/alipay.png","hash":"f97333d11bc171ae5c5775d312eb88452d290eff","modified":1474511011184},{"_id":"themes/indigo/source/img/head.png","hash":"b8e5fa9559e3b6c80efa016f9f15791f179914ca","modified":1474511011186},{"_id":"themes/indigo/source/css/_partial/search.less","hash":"01bb8da651c5123ab862660b4fd79235464e31c0","modified":1474511011157},{"_id":"source/images/Windows-Tools-Recommend/chrome.jpg","hash":"434012fce17a4025abc677fd240a8413ed5a8f88","modified":1474169108360},{"_id":"themes/indigo/source/css/_partial/fontawesome.less","hash":"ffafe7c70131ce66d497c23fb455abd9aa367496","modified":1474511011154},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1474511011168},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1474511011170},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1474511011171},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1474511011171},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1474511011173},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1474511011174},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1474511011174},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1474511011176},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1474511011177},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1474511011177},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1474511011180},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1474511011180},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1474511011182},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1474511011183},{"_id":"themes/indigo/source/css/fonts/fontawesome/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1474511011160},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1474511011161},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1474511011179},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1474511011167},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1474511011167},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1474511011173},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1474511011176},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1474511011178},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1474511011169},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1474511011182},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1474511011166},{"_id":"source/images/Film-TrainToBusan/stage.jpg","hash":"dcceae83b781f00cc37a24d5501b5c88515057f5","modified":1475817877526},{"_id":"source/images/Film-TrainToBusan/strong.jpg","hash":"3d52152c167e9f8ebc1cf2b15b3e51d2eeb40ff1","modified":1475817919726},{"_id":"source/images/Film-TrainToBusan/student.jpg","hash":"7ae92778eb814fcefca15e51a9f6d3913a7ac6ec","modified":1475817958970},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.svg","hash":"964e8dac2cee79c4b49b5bc300675773f6518812","modified":1474511011164},{"_id":"source/images/Film-TrainToBusan/protagonist.jpg","hash":"0639d832cbbc67c700476955609e36e41be075dc","modified":1475817792038}],"Category":[{"name":"编程","_id":"ciu99fu3u0004r8fieittj659"},{"name":"影评","_id":"ciu99fu4k000nr8fipusf7cdq"},{"name":"工具","_id":"ciu99fu4x000yr8fiqy9tfelw"}],"Data":[],"Page":[{"title":"404 Not Found：该页无法显示","comments":0,"fancybox":false,"noDate":"true","_content":"\n<style type=\"text/css\">\n\t.article-title {\n\t\tfont-size: 2.1em;\n\t}\n\tstrong a {\n\t\tcolor: #747474;\n\t}\n\t.share {\n\t\tdisplay: none;\n\t}\n\t.player {\n\t\tmargin-left: -10px;\n\t}\n\t.sign {\n\t\ttext-align: right;\n\t\tfont-style: italic;\n\t}\n  \t#page-visit {\n\t\tdisplay: none;\n\t}\n\t.center {\n\t\ttext-align: center;\n\t\theight: 2.5em;\n\t\tfont-weight: bold;\n\t}\n\t.search2 {\n\t\theight: 2.2em;\n\t\tfont-size: 1em;\n\t\twidth: 50%;\n\t\tmargin: auto 24%;\n\t\tcolor: #727272;\n\t\topacity: .6;\n\t\tborder: 2px solid lightgray;\n\t}\n\t.search2:hover {\n\t\topacity: 1;\n\t\tbox-shadow: 0 0 10px rgba(0, 0, 0, 0.3)\n\t\t};\n\t.article-entry hr {\n\t\tmargin: 0;\n\t}\n\t.pic {\n\t\ttext-align: center;\n\t\tmargin: 0;\n\t}\n\t.pic br {\n  \t\tdisplay: none;\n  \t}\n</style>\n\n***\n\n<div class=\"pic\">\n\n</div>\n\n<p class=\"center\">很抱歉，您所访问的地址并不存在: </p>\n\n<p class=\"center\"><a href=\"/\">回主页</a> · <a href=\"/archives\">所有文章</a> · <a href=\"/about\">留言板</a></p>\n\n<p class=\"center\">可在边栏搜索框中对本站进行检索，以获取相关信息。</p>\n\n<div style=\"text-align: center\">\n以下是博主喜欢的一些歌曲，可以听听，稍作休息~\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=320 height=330 src=\"http://music.163.com/outchain/player?type=0&id=131099154&auto=0&height=430\"></iframe>\n</div>","source":"404/index.md","raw":"title: 404 Not Found：该页无法显示\ncomments: false\npermalink: /404\nfancybox: false\nnoDate: \"true\"\n---\n\n<style type=\"text/css\">\n\t.article-title {\n\t\tfont-size: 2.1em;\n\t}\n\tstrong a {\n\t\tcolor: #747474;\n\t}\n\t.share {\n\t\tdisplay: none;\n\t}\n\t.player {\n\t\tmargin-left: -10px;\n\t}\n\t.sign {\n\t\ttext-align: right;\n\t\tfont-style: italic;\n\t}\n  \t#page-visit {\n\t\tdisplay: none;\n\t}\n\t.center {\n\t\ttext-align: center;\n\t\theight: 2.5em;\n\t\tfont-weight: bold;\n\t}\n\t.search2 {\n\t\theight: 2.2em;\n\t\tfont-size: 1em;\n\t\twidth: 50%;\n\t\tmargin: auto 24%;\n\t\tcolor: #727272;\n\t\topacity: .6;\n\t\tborder: 2px solid lightgray;\n\t}\n\t.search2:hover {\n\t\topacity: 1;\n\t\tbox-shadow: 0 0 10px rgba(0, 0, 0, 0.3)\n\t\t};\n\t.article-entry hr {\n\t\tmargin: 0;\n\t}\n\t.pic {\n\t\ttext-align: center;\n\t\tmargin: 0;\n\t}\n\t.pic br {\n  \t\tdisplay: none;\n  \t}\n</style>\n\n***\n\n<div class=\"pic\">\n\n</div>\n\n<p class=\"center\">很抱歉，您所访问的地址并不存在: </p>\n\n<p class=\"center\"><a href=\"/\">回主页</a> · <a href=\"/archives\">所有文章</a> · <a href=\"/about\">留言板</a></p>\n\n<p class=\"center\">可在边栏搜索框中对本站进行检索，以获取相关信息。</p>\n\n<div style=\"text-align: center\">\n以下是博主喜欢的一些歌曲，可以听听，稍作休息~\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=320 height=330 src=\"http://music.163.com/outchain/player?type=0&id=131099154&auto=0&height=430\"></iframe>\n</div>","date":"2016-09-13T02:02:41.720Z","updated":"2016-09-13T02:02:41.720Z","path":"/404.html","layout":"page","_id":"ciu99fu3q0001r8fivvqvocdt","content":"<style type=\"text/css\">\n    .article-title {\n        font-size: 2.1em;\n    }\n    strong a {\n        color: #747474;\n    }\n    .share {\n        display: none;\n    }\n    .player {\n        margin-left: -10px;\n    }\n    .sign {\n        text-align: right;\n        font-style: italic;\n    }\n      #page-visit {\n        display: none;\n    }\n    .center {\n        text-align: center;\n        height: 2.5em;\n        font-weight: bold;\n    }\n    .search2 {\n        height: 2.2em;\n        font-size: 1em;\n        width: 50%;\n        margin: auto 24%;\n        color: #727272;\n        opacity: .6;\n        border: 2px solid lightgray;\n    }\n    .search2:hover {\n        opacity: 1;\n        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3)\n        };\n    .article-entry hr {\n        margin: 0;\n    }\n    .pic {\n        text-align: center;\n        margin: 0;\n    }\n    .pic br {\n          display: none;\n      }\n</style>\n\n<hr>\n<div class=\"pic\"><br><br></div>\n\n<p class=\"center\">很抱歉，您所访问的地址并不存在: </p>\n\n<p class=\"center\"><a href=\"/\">回主页</a> · <a href=\"/archives\">所有文章</a> · <a href=\"/about\">留言板</a></p>\n\n<p class=\"center\">可在边栏搜索框中对本站进行检索，以获取相关信息。</p>\n\n<div style=\"text-align: center\"><br>以下是博主喜欢的一些歌曲，可以听听，稍作休息~<br><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"320\" height=\"330\" src=\"http://music.163.com/outchain/player?type=0&id=131099154&auto=0&height=430\"></iframe><br></div>","excerpt":"","more":"<style type=\"text/css\">\n    .article-title {\n        font-size: 2.1em;\n    }\n    strong a {\n        color: #747474;\n    }\n    .share {\n        display: none;\n    }\n    .player {\n        margin-left: -10px;\n    }\n    .sign {\n        text-align: right;\n        font-style: italic;\n    }\n      #page-visit {\n        display: none;\n    }\n    .center {\n        text-align: center;\n        height: 2.5em;\n        font-weight: bold;\n    }\n    .search2 {\n        height: 2.2em;\n        font-size: 1em;\n        width: 50%;\n        margin: auto 24%;\n        color: #727272;\n        opacity: .6;\n        border: 2px solid lightgray;\n    }\n    .search2:hover {\n        opacity: 1;\n        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3)\n        };\n    .article-entry hr {\n        margin: 0;\n    }\n    .pic {\n        text-align: center;\n        margin: 0;\n    }\n    .pic br {\n          display: none;\n      }\n</style>\n\n<hr>\n<div class=\"pic\"><br><br></div>\n\n<p class=\"center\">很抱歉，您所访问的地址并不存在: </p>\n\n<p class=\"center\"><a href=\"/\">回主页</a> · <a href=\"/archives\">所有文章</a> · <a href=\"/about\">留言板</a></p>\n\n<p class=\"center\">可在边栏搜索框中对本站进行检索，以获取相关信息。</p>\n\n<div style=\"text-align: center\"><br>以下是博主喜欢的一些歌曲，可以听听，稍作休息~<br><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=320 height=330 src=\"http://music.163.com/outchain/player?type=0&id=131099154&auto=0&height=430\"></iframe><br></div>"},{"_content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n</head>\n<body>\n\t<ul>    \n    <li>WebSite：<a href=\"http://www.xieyufei.com\">http://www.xieyufei.com</a></li>\n    <li>Email：<a href=\"http://mail.163.com/\">corner_scofield@163.com</a></li>\n<!--     <li>GitHub：<a href=\"https://github.com/AnSwErYWJ\">AnSwErYWJ</a></li> -->\n    <li>Blog：<a href=\"http://www.xieyufei.com\">谢小飞的博客</a></li>\n    <!-- <li>Weibo：<a href=\"http://weibo.com/1783591593\">@AnSwEr不是答案</a></p></li> -->\n</ul>\n</body>\n</html>","source":"about/index.html","raw":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n</head>\n<body>\n\t<ul>    \n    <li>WebSite：<a href=\"http://www.xieyufei.com\">http://www.xieyufei.com</a></li>\n    <li>Email：<a href=\"http://mail.163.com/\">corner_scofield@163.com</a></li>\n<!--     <li>GitHub：<a href=\"https://github.com/AnSwErYWJ\">AnSwErYWJ</a></li> -->\n    <li>Blog：<a href=\"http://www.xieyufei.com\">谢小飞的博客</a></li>\n    <!-- <li>Weibo：<a href=\"http://weibo.com/1783591593\">@AnSwEr不是答案</a></p></li> -->\n</ul>\n</body>\n</html>","date":"2016-09-12T03:07:06.066Z","updated":"2016-09-12T03:07:06.066Z","path":"about/index.html","title":"","comments":1,"layout":"page","_id":"ciu99fu3t0003r8fiizkz265j","content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n</head>\n<body>\n\t<ul>    \n    <li>WebSite：<a href=\"http://www.xieyufei.com\" target=\"_blank\" rel=\"external\">http://www.xieyufei.com</a></li>\n    <li>Email：<a href=\"http://mail.163.com/\" target=\"_blank\" rel=\"external\">corner_scofield@163.com</a></li>\n<!--     <li>GitHub：<a href=\"https://github.com/AnSwErYWJ\">AnSwErYWJ</a></li> -->\n    <li>Blog：<a href=\"http://www.xieyufei.com\" target=\"_blank\" rel=\"external\">谢小飞的博客</a></li>\n    <!-- <li>Weibo：<a href=\"http://weibo.com/1783591593\">@AnSwEr不是答案</a></p></li> -->\n</ul>\n</body>\n</html>","excerpt":"","more":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n</head>\n<body>\n\t<ul>    \n    <li>WebSite：<a href=\"http://www.xieyufei.com\">http://www.xieyufei.com</a></li>\n    <li>Email：<a href=\"http://mail.163.com/\">corner_scofield@163.com</a></li>\n<!--     <li>GitHub：<a href=\"https://github.com/AnSwErYWJ\">AnSwErYWJ</a></li> -->\n    <li>Blog：<a href=\"http://www.xieyufei.com\">谢小飞的博客</a></li>\n    <!-- <li>Weibo：<a href=\"http://weibo.com/1783591593\">@AnSwEr不是答案</a></p></li> -->\n</ul>\n</body>\n</html>"},{"title":"标签","Antuor":"Corner","date":"2016-07-10T05:36:38.000Z","comments":0,"type":"tags","layout":"tags","noDate":true,"commonts":false,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\nAntuor: Corner\ndate: 2016-07-10 13:36:38\ncomments: false\ntype: \"tags\"\nlayout: tags\nnoDate: true\ncommonts: false\n---\n","updated":"2016-09-22T02:23:31.136Z","path":"tags/index.html","_id":"ciu99fu420007r8fi567ikw6m","content":"","excerpt":"","more":""},{"title":"分类","Antuor":"Corner","comments":0,"date":"2016-09-12T05:39:58.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\nAntuor: Corner\ncomments: false\ndate: 2016-09-12 13:39:58\ntype: \"categories\"\n---\n","updated":"2016-09-12T04:24:50.901Z","path":"categories/index.html","layout":"page","_id":"ciu99fu450009r8fil9ty9ra3","content":"","excerpt":"","more":""}],"Post":[{"title":"微信小程序上手开发和使用总结（上）","date":"2016-10-09T01:58:02.000Z","description":null,"toc":null,"author":"Corner","comments":1,"original":null,"photos":["/images/Front-Tiny-WeChat/interface.png"],"_content":"　　最近微信小程序一下子火了起来，我也学习了一下，写了几个简单的demo，分享一下自己的使用心得，希望对大家有帮助。\n<!-- more -->\n> 我们提供了一种新的开放能力，开发者可以快速的开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。\n\n# 搭建环境\n　　要开始做项目，首先要安装微信小程序的开发工具。官网的版本比较旧，笔者分享一个下载链接，大家可以去下载，[微信小程序开发工具下载](http://pan.baidu.com/s/1o86hgue)，下载完直接安装后新建项目就可以使用了。当然，由于还处在内测阶段，腾讯只邀请了部分企业参与内侧，所以AppID数量很稀少，读者在添加项目的时候可以选择无AppID。添加项目后打开小程序的开发工具是这样的：\n![微信小程序开发工具界面](/images/Front-Tiny-WeChat/interface.png)\n调试按钮可以打开调试界面，如果读者用惯了Chrome浏览器，想必对这个界面肯定不会陌生；如果需要切换到其他的项目，可以直接点关闭按钮，而不用关闭整个工具。\n\n# 项目结构\n　　整个项目由两部分组成，一个是描述整体程序的app文件和多个框架页面文件组成。\n## app文件\n　　描述整体程序的app文件必须放在文件的跟目录，由三个文件组成，app.js、app.json和app.wxss。\n* app.js:程序的整体逻辑\n* app.json:程序的公共设置\n* app.wxss:小程序的公共样式(非必须)\n\n在app.json文件中可以对小程序进行全局配置，比如页面路由、窗口表现、网络超时、多个tab等；在app.js中我们使用App()注册小程序的，它接受一个object对象作为它的参数，这个参数指定了小程序的生命周期函数。object函数说明：\n\n| 属性      | 描述         | 触发  |\n|  -        |       -      |  -    |\n| onLaunch  | 小程序初始化 | 初始化完成后 |\n| onShow    | 小程序显示   | 小程序由后台进入前台 |\n| onHide    | 小程序隐藏 | 小程序由前台进入后台 |\n\n**注意：**\n\n* App()函数只能定义一次，并且只能在app.js中定义。\n* onLaunch()函数在整个小程序的生命周期只调用一次，其他两个函数调用多次。\n\n## 框架页面文件\n　　项目框架页面可以配置多个，建议页面的文件名称和文件名保持一致。比如有一个下单页book，其中的文件可以设置为book.js、book.wxml、book.wxss、book.json。\n* xxx.js:页面逻辑\n* xxx.wxml:页面结构\n* xxx.wxss:页面样式(非必须)\n* xxx.json:页面配置(非必须)\n\n我们在框架页面也需要注册页面，注册页面通过Page()函数，这个函数也接受一个object函数，用来指定函数的生命周期函数和初始化的数据。\n\n| 属性      | 类型         | 描述  |\n|  -        |       -      |  -    |\n| data      |   object     |  页面初始化数据   |\n| onLoad    |  Function    |  页面加载时   |\n| onReady   |  Function    |  页面初次渲染完成   |\n| onShow   |  Function    |  页面显示时   |\n| onHide   |  Function    |  页面隐藏时   |\n| onUnload |  Function    |  页面卸载时   |\n| onPullDownRefreash  |  Function    |  页面下拉时   |\n\n**注意：**\n\n* onLoad()函数在页面加载时只调用一次。可以获取上个页面传来的参数，默认保存在data参数中，可以通过data.param的方式获取。\n* onUnload()页面卸载时调用，比如调用redirectTo或者navigateBack时。\n\n# 数据处理\n　　和jQuery等其他js框架不同的，小程序不能直接操作DOM元素，只能通过改变数据来控制页面元素的状态，这样有点类似React的思想。所以我觉得小程序的思想是面向数据，而不是面向元素。\n\n## 数据绑定\n　　上一节我们说过注册页面时需要传入一个object参数，这个参数可以挂载很多页面的生命周期函数，同时，也能将页面的数据挂载进去。页面的数据可以直接挂载到object参数的data对象中去。\n\n```javascript\nPage({\n\tdata:{\n\t\tname:'xyf'\n\t},\n\tmyname:'test'\n\tonLoad:function(){\n\t}\n})\n```\n\n　　这里我们定义了两个数据，一个数据定义在data对象中，另一个数据直接定义Page的参数中。我们可以将data中的数据渲染到页面中，使用Mustache语法(双大括号)将要渲染的变量包起来，如下：\n\n```html\n<view>{{name}}</view>\n```\n\n如果需要在组件的属性内渲染数据，也需要用双大括号包起来：\n\n```html\n<view class=\"item-{{name}}\"></view>\n```\n\n在双大括号中，我们可以进行简单的运算和判断，比如三元运算，算数运算，字符串运算等。\n\n```html\n<view class=\"{{name=='xyf'?'yes':'no'}}\">{{name+' is a smart boy'}}</view>\n```\n\n\n## 数据获取和更改\n　　对于data中的数据，我们必须通过this.data.name这种方式来获取，对于data外面的数据，我们可以通过this.myname的方式来获取。\n\n```javascript\nonLoad:function(){\n\tconsole.log(this.data.name); //'xyf'\n\tconsole.log(this.myname);    //'test'\n}\n```\n\n　　对于data中的数据，要想改变它的值，必须要调用setData()方法来改变，而要改变data外的数据，可以直接给他进行赋值。\n\n```javascript\nonLoad:function(){\n\tthis.setData({\n\t\tname:'Corner'\n\t});\n\tconsole.log(this.data.name); //'Corner'\n\tthis.data.name='Nick';\n\tconsole.log(this.data.name); //'Corner'\n\tthis.myname='mytest';\n\tconsole.log(this.myname);    //'myest'\n}\n```\n\n**注意：**\n* 在函数中注意this的作用域。在map函数或者异步回调函数中要使用this，要在函数外先把this赋值给that，然后用that进行操作。\n* setData()对象参数的值不能为undefined。每次setData进行赋值时都要对要赋的值进行非空判断，确保不是undefined，否则会报错。\n\n总结一下，两种方式定义的数据区别如下：\n\n* 能否被渲染：页面只能动态渲染data中的数据，data外的数据不能被渲染到页面上，所以data中放一些需要页面动态渲染的数据\n* 获取方式：data中的数据通过this.data.[param]方式获取，data外的数据通过this.[param]方式获取。\n* 赋值方式：data中的数据只能通过setData()函数进行赋值，而data外的数据可以直接赋值。\n\n# 页面渲染\n　　对于data中的简单变量，我们可以通过双大括号的方式进行渲染，但是如果对于一些稍微复杂一点的数据结构(比如数组)，双大括号就不能满足我们的需求了。我们需要引入另外两种渲染方式，条件渲染和列表渲染。\n\n## 条件渲染\n　　我们使用wx:if=\"{{condition}}\"的来判断是否需要渲染该模块，还可以添加wx:elif和wx:else渲染。\n\n```html\n<view wx:if=\"{{length > 5}}\"> 大于 </view>\n<view wx:elif=\"{{length > 2}}\"> 中等 </view>\n<view wx:else> 小于 </view>\n```\n\n　　也可以直接在大括号中使用布尔类型的值控制页面元素隐藏和显示。如果data中flag为false，那么类名为demo的这个view组件就不会渲染到页面上去。\n\n```html\n<view class=\"demo\" wx:if=\"{{flag}}\">\n显示\n</view>\n```\n\n## 列表渲染\n　　有时候我们需要将一个数组渲染到页面上，比如几个用户信息，比如点评列表，这时候就需要用到列表循环。\n　　列表循环使用wx:for来绑定一个数组，就可以将数组中的每个数据循环遍历到组件中。默认情况下每个元素的变量名为item，每个变量的索引值为index。\n\n```html\n<view wx:for=\"{{['a','b','c','d']}}\">\n\t这是第{{index}}个元素，元素内容为{{item}}\n</view>\n```\n\n　　在列表遍历时我们并没有定义item和index，小程序自动为我们添加了wx:for-index=\"index\"和wx:for-item=\"item\"。因此在嵌套列表渲染时，注意index和item所代表的值和对象。需要我们自己定义变量名和索引，避免混乱。\n\n\n# 总结和期待\n　　微信小程序还在内测阶段就引起了这么多关注，作为一个程序员，尤其是一名前端程序员，上手和熟悉微信小程序的开发无疑会让我们越来越“吃香”。网上也在热议微信小程序是否会颠覆或者代替原生App，我觉得两者还是有以下区别的：\n\n* 产品形态：微信小程序更加接近于HTML5产品，开发上也使用JavaScript进行开发，性能比H5好，但是要比原生App性能低。而且微信小程序整体文件大小限制在1MB以内，估计只能运行一些小型的应用和游戏，一些大型的应用肯定还是要用App的。\n* 用户习惯：很多用户已经用惯了App，要想改变用户的习惯还是挺难的。用户操作肯定是越简单越好。比如现在微博App打开就能用，但是如果有了微博小程序，需要进入微信才能打开，相信用户还是挺反感中间多余的“步骤”。\n\n\n　　个人感觉微信小程序的开发也存在着不足之处，希望在以后的版本中能够改进：\n\n* 开发工具不能实时运行结果：每次都需要编译才能看到结果，程序猿表示每次看效果都比较麻烦。\n* 不支持ES6：现在ES6越来越流行，确实给开发带来了不少的简洁和便利。每次开发还要使用原生js，程序猿表示鸭梨山大啊。\n* 组件太少，不支持自定义组件：能够使用的组件偏少，大部分情况下只能使用view和text，不能够满足复杂的业务场景。\n\n\n\n\n","source":"_posts/Front-Tiny-WeChat.md","raw":"title: 微信小程序上手开发和使用总结（上）\ndate: 2016-10-09 09:58:02\ndescription:\ncategories:\n- 编程\ntags:\n- 前端\n- WeChat\ntoc:\nauthor: Corner\ncomments:\noriginal:\npermalink:\nphotos: /images/Front-Tiny-WeChat/interface.png\n---\n　　最近微信小程序一下子火了起来，我也学习了一下，写了几个简单的demo，分享一下自己的使用心得，希望对大家有帮助。\n<!-- more -->\n> 我们提供了一种新的开放能力，开发者可以快速的开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。\n\n# 搭建环境\n　　要开始做项目，首先要安装微信小程序的开发工具。官网的版本比较旧，笔者分享一个下载链接，大家可以去下载，[微信小程序开发工具下载](http://pan.baidu.com/s/1o86hgue)，下载完直接安装后新建项目就可以使用了。当然，由于还处在内测阶段，腾讯只邀请了部分企业参与内侧，所以AppID数量很稀少，读者在添加项目的时候可以选择无AppID。添加项目后打开小程序的开发工具是这样的：\n![微信小程序开发工具界面](/images/Front-Tiny-WeChat/interface.png)\n调试按钮可以打开调试界面，如果读者用惯了Chrome浏览器，想必对这个界面肯定不会陌生；如果需要切换到其他的项目，可以直接点关闭按钮，而不用关闭整个工具。\n\n# 项目结构\n　　整个项目由两部分组成，一个是描述整体程序的app文件和多个框架页面文件组成。\n## app文件\n　　描述整体程序的app文件必须放在文件的跟目录，由三个文件组成，app.js、app.json和app.wxss。\n* app.js:程序的整体逻辑\n* app.json:程序的公共设置\n* app.wxss:小程序的公共样式(非必须)\n\n在app.json文件中可以对小程序进行全局配置，比如页面路由、窗口表现、网络超时、多个tab等；在app.js中我们使用App()注册小程序的，它接受一个object对象作为它的参数，这个参数指定了小程序的生命周期函数。object函数说明：\n\n| 属性      | 描述         | 触发  |\n|  -        |       -      |  -    |\n| onLaunch  | 小程序初始化 | 初始化完成后 |\n| onShow    | 小程序显示   | 小程序由后台进入前台 |\n| onHide    | 小程序隐藏 | 小程序由前台进入后台 |\n\n**注意：**\n\n* App()函数只能定义一次，并且只能在app.js中定义。\n* onLaunch()函数在整个小程序的生命周期只调用一次，其他两个函数调用多次。\n\n## 框架页面文件\n　　项目框架页面可以配置多个，建议页面的文件名称和文件名保持一致。比如有一个下单页book，其中的文件可以设置为book.js、book.wxml、book.wxss、book.json。\n* xxx.js:页面逻辑\n* xxx.wxml:页面结构\n* xxx.wxss:页面样式(非必须)\n* xxx.json:页面配置(非必须)\n\n我们在框架页面也需要注册页面，注册页面通过Page()函数，这个函数也接受一个object函数，用来指定函数的生命周期函数和初始化的数据。\n\n| 属性      | 类型         | 描述  |\n|  -        |       -      |  -    |\n| data      |   object     |  页面初始化数据   |\n| onLoad    |  Function    |  页面加载时   |\n| onReady   |  Function    |  页面初次渲染完成   |\n| onShow   |  Function    |  页面显示时   |\n| onHide   |  Function    |  页面隐藏时   |\n| onUnload |  Function    |  页面卸载时   |\n| onPullDownRefreash  |  Function    |  页面下拉时   |\n\n**注意：**\n\n* onLoad()函数在页面加载时只调用一次。可以获取上个页面传来的参数，默认保存在data参数中，可以通过data.param的方式获取。\n* onUnload()页面卸载时调用，比如调用redirectTo或者navigateBack时。\n\n# 数据处理\n　　和jQuery等其他js框架不同的，小程序不能直接操作DOM元素，只能通过改变数据来控制页面元素的状态，这样有点类似React的思想。所以我觉得小程序的思想是面向数据，而不是面向元素。\n\n## 数据绑定\n　　上一节我们说过注册页面时需要传入一个object参数，这个参数可以挂载很多页面的生命周期函数，同时，也能将页面的数据挂载进去。页面的数据可以直接挂载到object参数的data对象中去。\n\n```javascript\nPage({\n\tdata:{\n\t\tname:'xyf'\n\t},\n\tmyname:'test'\n\tonLoad:function(){\n\t}\n})\n```\n\n　　这里我们定义了两个数据，一个数据定义在data对象中，另一个数据直接定义Page的参数中。我们可以将data中的数据渲染到页面中，使用Mustache语法(双大括号)将要渲染的变量包起来，如下：\n\n```html\n<view>{{name}}</view>\n```\n\n如果需要在组件的属性内渲染数据，也需要用双大括号包起来：\n\n```html\n<view class=\"item-{{name}}\"></view>\n```\n\n在双大括号中，我们可以进行简单的运算和判断，比如三元运算，算数运算，字符串运算等。\n\n```html\n<view class=\"{{name=='xyf'?'yes':'no'}}\">{{name+' is a smart boy'}}</view>\n```\n\n\n## 数据获取和更改\n　　对于data中的数据，我们必须通过this.data.name这种方式来获取，对于data外面的数据，我们可以通过this.myname的方式来获取。\n\n```javascript\nonLoad:function(){\n\tconsole.log(this.data.name); //'xyf'\n\tconsole.log(this.myname);    //'test'\n}\n```\n\n　　对于data中的数据，要想改变它的值，必须要调用setData()方法来改变，而要改变data外的数据，可以直接给他进行赋值。\n\n```javascript\nonLoad:function(){\n\tthis.setData({\n\t\tname:'Corner'\n\t});\n\tconsole.log(this.data.name); //'Corner'\n\tthis.data.name='Nick';\n\tconsole.log(this.data.name); //'Corner'\n\tthis.myname='mytest';\n\tconsole.log(this.myname);    //'myest'\n}\n```\n\n**注意：**\n* 在函数中注意this的作用域。在map函数或者异步回调函数中要使用this，要在函数外先把this赋值给that，然后用that进行操作。\n* setData()对象参数的值不能为undefined。每次setData进行赋值时都要对要赋的值进行非空判断，确保不是undefined，否则会报错。\n\n总结一下，两种方式定义的数据区别如下：\n\n* 能否被渲染：页面只能动态渲染data中的数据，data外的数据不能被渲染到页面上，所以data中放一些需要页面动态渲染的数据\n* 获取方式：data中的数据通过this.data.[param]方式获取，data外的数据通过this.[param]方式获取。\n* 赋值方式：data中的数据只能通过setData()函数进行赋值，而data外的数据可以直接赋值。\n\n# 页面渲染\n　　对于data中的简单变量，我们可以通过双大括号的方式进行渲染，但是如果对于一些稍微复杂一点的数据结构(比如数组)，双大括号就不能满足我们的需求了。我们需要引入另外两种渲染方式，条件渲染和列表渲染。\n\n## 条件渲染\n　　我们使用wx:if=\"{{condition}}\"的来判断是否需要渲染该模块，还可以添加wx:elif和wx:else渲染。\n\n```html\n<view wx:if=\"{{length > 5}}\"> 大于 </view>\n<view wx:elif=\"{{length > 2}}\"> 中等 </view>\n<view wx:else> 小于 </view>\n```\n\n　　也可以直接在大括号中使用布尔类型的值控制页面元素隐藏和显示。如果data中flag为false，那么类名为demo的这个view组件就不会渲染到页面上去。\n\n```html\n<view class=\"demo\" wx:if=\"{{flag}}\">\n显示\n</view>\n```\n\n## 列表渲染\n　　有时候我们需要将一个数组渲染到页面上，比如几个用户信息，比如点评列表，这时候就需要用到列表循环。\n　　列表循环使用wx:for来绑定一个数组，就可以将数组中的每个数据循环遍历到组件中。默认情况下每个元素的变量名为item，每个变量的索引值为index。\n\n```html\n<view wx:for=\"{{['a','b','c','d']}}\">\n\t这是第{{index}}个元素，元素内容为{{item}}\n</view>\n```\n\n　　在列表遍历时我们并没有定义item和index，小程序自动为我们添加了wx:for-index=\"index\"和wx:for-item=\"item\"。因此在嵌套列表渲染时，注意index和item所代表的值和对象。需要我们自己定义变量名和索引，避免混乱。\n\n\n# 总结和期待\n　　微信小程序还在内测阶段就引起了这么多关注，作为一个程序员，尤其是一名前端程序员，上手和熟悉微信小程序的开发无疑会让我们越来越“吃香”。网上也在热议微信小程序是否会颠覆或者代替原生App，我觉得两者还是有以下区别的：\n\n* 产品形态：微信小程序更加接近于HTML5产品，开发上也使用JavaScript进行开发，性能比H5好，但是要比原生App性能低。而且微信小程序整体文件大小限制在1MB以内，估计只能运行一些小型的应用和游戏，一些大型的应用肯定还是要用App的。\n* 用户习惯：很多用户已经用惯了App，要想改变用户的习惯还是挺难的。用户操作肯定是越简单越好。比如现在微博App打开就能用，但是如果有了微博小程序，需要进入微信才能打开，相信用户还是挺反感中间多余的“步骤”。\n\n\n　　个人感觉微信小程序的开发也存在着不足之处，希望在以后的版本中能够改进：\n\n* 开发工具不能实时运行结果：每次都需要编译才能看到结果，程序猿表示每次看效果都比较麻烦。\n* 不支持ES6：现在ES6越来越流行，确实给开发带来了不少的简洁和便利。每次开发还要使用原生js，程序猿表示鸭梨山大啊。\n* 组件太少，不支持自定义组件：能够使用的组件偏少，大部分情况下只能使用view和text，不能够满足复杂的业务场景。\n\n\n\n\n","slug":"Front-Tiny-WeChat","published":1,"updated":"2016-10-11T04:12:27.692Z","layout":"post","link":"","_id":"ciu99fu3m0000r8filpw4svbb","content":"<p>　　最近微信小程序一下子火了起来，我也学习了一下，写了几个简单的demo，分享一下自己的使用心得，希望对大家有帮助。<br><a id=\"more\"></a></p>\n<blockquote>\n<p>我们提供了一种新的开放能力，开发者可以快速的开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。</p>\n</blockquote>\n<h1 id=\"搭建环境\"><a href=\"#搭建环境\" class=\"headerlink\" title=\"搭建环境\"></a>搭建环境</h1><p>　　要开始做项目，首先要安装微信小程序的开发工具。官网的版本比较旧，笔者分享一个下载链接，大家可以去下载，<a href=\"http://pan.baidu.com/s/1o86hgue\" target=\"_blank\" rel=\"external\">微信小程序开发工具下载</a>，下载完直接安装后新建项目就可以使用了。当然，由于还处在内测阶段，腾讯只邀请了部分企业参与内侧，所以AppID数量很稀少，读者在添加项目的时候可以选择无AppID。添加项目后打开小程序的开发工具是这样的：<br><img src=\"/images/Front-Tiny-WeChat/interface.png\" alt=\"微信小程序开发工具界面\"><br>调试按钮可以打开调试界面，如果读者用惯了Chrome浏览器，想必对这个界面肯定不会陌生；如果需要切换到其他的项目，可以直接点关闭按钮，而不用关闭整个工具。</p>\n<h1 id=\"项目结构\"><a href=\"#项目结构\" class=\"headerlink\" title=\"项目结构\"></a>项目结构</h1><p>　　整个项目由两部分组成，一个是描述整体程序的app文件和多个框架页面文件组成。</p>\n<h2 id=\"app文件\"><a href=\"#app文件\" class=\"headerlink\" title=\"app文件\"></a>app文件</h2><p>　　描述整体程序的app文件必须放在文件的跟目录，由三个文件组成，app.js、app.json和app.wxss。</p>\n<ul>\n<li>app.js:程序的整体逻辑</li>\n<li>app.json:程序的公共设置</li>\n<li>app.wxss:小程序的公共样式(非必须)</li>\n</ul>\n<p>在app.json文件中可以对小程序进行全局配置，比如页面路由、窗口表现、网络超时、多个tab等；在app.js中我们使用App()注册小程序的，它接受一个object对象作为它的参数，这个参数指定了小程序的生命周期函数。object函数说明：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n<th>触发</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onLaunch</td>\n<td>小程序初始化</td>\n<td>初始化完成后</td>\n</tr>\n<tr>\n<td>onShow</td>\n<td>小程序显示</td>\n<td>小程序由后台进入前台</td>\n</tr>\n<tr>\n<td>onHide</td>\n<td>小程序隐藏</td>\n<td>小程序由前台进入后台</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注意：</strong></p>\n<ul>\n<li>App()函数只能定义一次，并且只能在app.js中定义。</li>\n<li>onLaunch()函数在整个小程序的生命周期只调用一次，其他两个函数调用多次。</li>\n</ul>\n<h2 id=\"框架页面文件\"><a href=\"#框架页面文件\" class=\"headerlink\" title=\"框架页面文件\"></a>框架页面文件</h2><p>　　项目框架页面可以配置多个，建议页面的文件名称和文件名保持一致。比如有一个下单页book，其中的文件可以设置为book.js、book.wxml、book.wxss、book.json。</p>\n<ul>\n<li>xxx.js:页面逻辑</li>\n<li>xxx.wxml:页面结构</li>\n<li>xxx.wxss:页面样式(非必须)</li>\n<li>xxx.json:页面配置(非必须)</li>\n</ul>\n<p>我们在框架页面也需要注册页面，注册页面通过Page()函数，这个函数也接受一个object函数，用来指定函数的生命周期函数和初始化的数据。</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>data</td>\n<td>object</td>\n<td>页面初始化数据</td>\n</tr>\n<tr>\n<td>onLoad</td>\n<td>Function</td>\n<td>页面加载时</td>\n</tr>\n<tr>\n<td>onReady</td>\n<td>Function</td>\n<td>页面初次渲染完成</td>\n</tr>\n<tr>\n<td>onShow</td>\n<td>Function</td>\n<td>页面显示时</td>\n</tr>\n<tr>\n<td>onHide</td>\n<td>Function</td>\n<td>页面隐藏时</td>\n</tr>\n<tr>\n<td>onUnload</td>\n<td>Function</td>\n<td>页面卸载时</td>\n</tr>\n<tr>\n<td>onPullDownRefreash</td>\n<td>Function</td>\n<td>页面下拉时</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注意：</strong></p>\n<ul>\n<li>onLoad()函数在页面加载时只调用一次。可以获取上个页面传来的参数，默认保存在data参数中，可以通过data.param的方式获取。</li>\n<li>onUnload()页面卸载时调用，比如调用redirectTo或者navigateBack时。</li>\n</ul>\n<h1 id=\"数据处理\"><a href=\"#数据处理\" class=\"headerlink\" title=\"数据处理\"></a>数据处理</h1><p>　　和jQuery等其他js框架不同的，小程序不能直接操作DOM元素，只能通过改变数据来控制页面元素的状态，这样有点类似React的思想。所以我觉得小程序的思想是面向数据，而不是面向元素。</p>\n<h2 id=\"数据绑定\"><a href=\"#数据绑定\" class=\"headerlink\" title=\"数据绑定\"></a>数据绑定</h2><p>　　上一节我们说过注册页面时需要传入一个object参数，这个参数可以挂载很多页面的生命周期函数，同时，也能将页面的数据挂载进去。页面的数据可以直接挂载到object参数的data对象中去。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Page(&#123;</div><div class=\"line\">\tdata:&#123;</div><div class=\"line\">\t\tname:<span class=\"string\">'xyf'</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\tmyname:<span class=\"string\">'test'</span></div><div class=\"line\">\tonLoad:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>　　这里我们定义了两个数据，一个数据定义在data对象中，另一个数据直接定义Page的参数中。我们可以将data中的数据渲染到页面中，使用Mustache语法(双大括号)将要渲染的变量包起来，如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>如果需要在组件的属性内渲染数据，也需要用双大括号包起来：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">\"item-&#123;&#123;name&#125;&#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在双大括号中，我们可以进行简单的运算和判断，比如三元运算，算数运算，字符串运算等。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">\"&#123;&#123;name=='xyf'?'yes':'no'&#125;&#125;\"</span>&gt;</span>&#123;&#123;name+' is a smart boy'&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></div></pre></td></tr></table></figure>\n<h2 id=\"数据获取和更改\"><a href=\"#数据获取和更改\" class=\"headerlink\" title=\"数据获取和更改\"></a>数据获取和更改</h2><p>　　对于data中的数据，我们必须通过this.data.name这种方式来获取，对于data外面的数据，我们可以通过this.myname的方式来获取。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">onLoad:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.data.name); <span class=\"comment\">//'xyf'</span></div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.myname);    <span class=\"comment\">//'test'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>　　对于data中的数据，要想改变它的值，必须要调用setData()方法来改变，而要改变data外的数据，可以直接给他进行赋值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">onLoad:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.setData(&#123;</div><div class=\"line\">\t\tname:<span class=\"string\">'Corner'</span></div><div class=\"line\">\t&#125;);</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.data.name); <span class=\"comment\">//'Corner'</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.data.name=<span class=\"string\">'Nick'</span>;</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.data.name); <span class=\"comment\">//'Corner'</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.myname=<span class=\"string\">'mytest'</span>;</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.myname);    <span class=\"comment\">//'myest'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>注意：</strong></p>\n<ul>\n<li>在函数中注意this的作用域。在map函数或者异步回调函数中要使用this，要在函数外先把this赋值给that，然后用that进行操作。</li>\n<li>setData()对象参数的值不能为undefined。每次setData进行赋值时都要对要赋的值进行非空判断，确保不是undefined，否则会报错。</li>\n</ul>\n<p>总结一下，两种方式定义的数据区别如下：</p>\n<ul>\n<li>能否被渲染：页面只能动态渲染data中的数据，data外的数据不能被渲染到页面上，所以data中放一些需要页面动态渲染的数据</li>\n<li>获取方式：data中的数据通过this.data.[param]方式获取，data外的数据通过this.[param]方式获取。</li>\n<li>赋值方式：data中的数据只能通过setData()函数进行赋值，而data外的数据可以直接赋值。</li>\n</ul>\n<h1 id=\"页面渲染\"><a href=\"#页面渲染\" class=\"headerlink\" title=\"页面渲染\"></a>页面渲染</h1><p>　　对于data中的简单变量，我们可以通过双大括号的方式进行渲染，但是如果对于一些稍微复杂一点的数据结构(比如数组)，双大括号就不能满足我们的需求了。我们需要引入另外两种渲染方式，条件渲染和列表渲染。</p>\n<h2 id=\"条件渲染\"><a href=\"#条件渲染\" class=\"headerlink\" title=\"条件渲染\"></a>条件渲染</h2><p>　　我们使用wx:if=”“的来判断是否需要渲染该模块，还可以添加wx:elif和wx:else渲染。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">wx:if</span>=<span class=\"string\">\"&#123;&#123;length &gt; 5&#125;&#125;\"</span>&gt;</span> 大于 <span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">wx:elif</span>=<span class=\"string\">\"&#123;&#123;length &gt; 2&#125;&#125;\"</span>&gt;</span> 中等 <span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">wx:else</span>&gt;</span> 小于 <span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>　　也可以直接在大括号中使用布尔类型的值控制页面元素隐藏和显示。如果data中flag为false，那么类名为demo的这个view组件就不会渲染到页面上去。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">\"demo\"</span> <span class=\"attr\">wx:if</span>=<span class=\"string\">\"&#123;&#123;flag&#125;&#125;\"</span>&gt;</span></div><div class=\"line\">显示</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></div></pre></td></tr></table></figure>\n<h2 id=\"列表渲染\"><a href=\"#列表渲染\" class=\"headerlink\" title=\"列表渲染\"></a>列表渲染</h2><p>　　有时候我们需要将一个数组渲染到页面上，比如几个用户信息，比如点评列表，这时候就需要用到列表循环。<br>　　列表循环使用wx:for来绑定一个数组，就可以将数组中的每个数据循环遍历到组件中。默认情况下每个元素的变量名为item，每个变量的索引值为index。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">wx:for</span>=<span class=\"string\">\"&#123;&#123;['a','b','c','d']&#125;&#125;\"</span>&gt;</span></div><div class=\"line\">\t这是第&#123;&#123;index&#125;&#125;个元素，元素内容为&#123;&#123;item&#125;&#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>　　在列表遍历时我们并没有定义item和index，小程序自动为我们添加了wx:for-index=”index”和wx:for-item=”item”。因此在嵌套列表渲染时，注意index和item所代表的值和对象。需要我们自己定义变量名和索引，避免混乱。</p>\n<h1 id=\"总结和期待\"><a href=\"#总结和期待\" class=\"headerlink\" title=\"总结和期待\"></a>总结和期待</h1><p>　　微信小程序还在内测阶段就引起了这么多关注，作为一个程序员，尤其是一名前端程序员，上手和熟悉微信小程序的开发无疑会让我们越来越“吃香”。网上也在热议微信小程序是否会颠覆或者代替原生App，我觉得两者还是有以下区别的：</p>\n<ul>\n<li>产品形态：微信小程序更加接近于HTML5产品，开发上也使用JavaScript进行开发，性能比H5好，但是要比原生App性能低。而且微信小程序整体文件大小限制在1MB以内，估计只能运行一些小型的应用和游戏，一些大型的应用肯定还是要用App的。</li>\n<li>用户习惯：很多用户已经用惯了App，要想改变用户的习惯还是挺难的。用户操作肯定是越简单越好。比如现在微博App打开就能用，但是如果有了微博小程序，需要进入微信才能打开，相信用户还是挺反感中间多余的“步骤”。</li>\n</ul>\n<p>　　个人感觉微信小程序的开发也存在着不足之处，希望在以后的版本中能够改进：</p>\n<ul>\n<li>开发工具不能实时运行结果：每次都需要编译才能看到结果，程序猿表示每次看效果都比较麻烦。</li>\n<li>不支持ES6：现在ES6越来越流行，确实给开发带来了不少的简洁和便利。每次开发还要使用原生js，程序猿表示鸭梨山大啊。</li>\n<li>组件太少，不支持自定义组件：能够使用的组件偏少，大部分情况下只能使用view和text，不能够满足复杂的业务场景。</li>\n</ul>\n","excerpt":"<p>　　最近微信小程序一下子火了起来，我也学习了一下，写了几个简单的demo，分享一下自己的使用心得，希望对大家有帮助。<br>","more":"</p>\n<blockquote>\n<p>我们提供了一种新的开放能力，开发者可以快速的开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。</p>\n</blockquote>\n<h1 id=\"搭建环境\"><a href=\"#搭建环境\" class=\"headerlink\" title=\"搭建环境\"></a>搭建环境</h1><p>　　要开始做项目，首先要安装微信小程序的开发工具。官网的版本比较旧，笔者分享一个下载链接，大家可以去下载，<a href=\"http://pan.baidu.com/s/1o86hgue\">微信小程序开发工具下载</a>，下载完直接安装后新建项目就可以使用了。当然，由于还处在内测阶段，腾讯只邀请了部分企业参与内侧，所以AppID数量很稀少，读者在添加项目的时候可以选择无AppID。添加项目后打开小程序的开发工具是这样的：<br><img src=\"/images/Front-Tiny-WeChat/interface.png\" alt=\"微信小程序开发工具界面\"><br>调试按钮可以打开调试界面，如果读者用惯了Chrome浏览器，想必对这个界面肯定不会陌生；如果需要切换到其他的项目，可以直接点关闭按钮，而不用关闭整个工具。</p>\n<h1 id=\"项目结构\"><a href=\"#项目结构\" class=\"headerlink\" title=\"项目结构\"></a>项目结构</h1><p>　　整个项目由两部分组成，一个是描述整体程序的app文件和多个框架页面文件组成。</p>\n<h2 id=\"app文件\"><a href=\"#app文件\" class=\"headerlink\" title=\"app文件\"></a>app文件</h2><p>　　描述整体程序的app文件必须放在文件的跟目录，由三个文件组成，app.js、app.json和app.wxss。</p>\n<ul>\n<li>app.js:程序的整体逻辑</li>\n<li>app.json:程序的公共设置</li>\n<li>app.wxss:小程序的公共样式(非必须)</li>\n</ul>\n<p>在app.json文件中可以对小程序进行全局配置，比如页面路由、窗口表现、网络超时、多个tab等；在app.js中我们使用App()注册小程序的，它接受一个object对象作为它的参数，这个参数指定了小程序的生命周期函数。object函数说明：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n<th>触发</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onLaunch</td>\n<td>小程序初始化</td>\n<td>初始化完成后</td>\n</tr>\n<tr>\n<td>onShow</td>\n<td>小程序显示</td>\n<td>小程序由后台进入前台</td>\n</tr>\n<tr>\n<td>onHide</td>\n<td>小程序隐藏</td>\n<td>小程序由前台进入后台</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注意：</strong></p>\n<ul>\n<li>App()函数只能定义一次，并且只能在app.js中定义。</li>\n<li>onLaunch()函数在整个小程序的生命周期只调用一次，其他两个函数调用多次。</li>\n</ul>\n<h2 id=\"框架页面文件\"><a href=\"#框架页面文件\" class=\"headerlink\" title=\"框架页面文件\"></a>框架页面文件</h2><p>　　项目框架页面可以配置多个，建议页面的文件名称和文件名保持一致。比如有一个下单页book，其中的文件可以设置为book.js、book.wxml、book.wxss、book.json。</p>\n<ul>\n<li>xxx.js:页面逻辑</li>\n<li>xxx.wxml:页面结构</li>\n<li>xxx.wxss:页面样式(非必须)</li>\n<li>xxx.json:页面配置(非必须)</li>\n</ul>\n<p>我们在框架页面也需要注册页面，注册页面通过Page()函数，这个函数也接受一个object函数，用来指定函数的生命周期函数和初始化的数据。</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>data</td>\n<td>object</td>\n<td>页面初始化数据</td>\n</tr>\n<tr>\n<td>onLoad</td>\n<td>Function</td>\n<td>页面加载时</td>\n</tr>\n<tr>\n<td>onReady</td>\n<td>Function</td>\n<td>页面初次渲染完成</td>\n</tr>\n<tr>\n<td>onShow</td>\n<td>Function</td>\n<td>页面显示时</td>\n</tr>\n<tr>\n<td>onHide</td>\n<td>Function</td>\n<td>页面隐藏时</td>\n</tr>\n<tr>\n<td>onUnload</td>\n<td>Function</td>\n<td>页面卸载时</td>\n</tr>\n<tr>\n<td>onPullDownRefreash</td>\n<td>Function</td>\n<td>页面下拉时</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注意：</strong></p>\n<ul>\n<li>onLoad()函数在页面加载时只调用一次。可以获取上个页面传来的参数，默认保存在data参数中，可以通过data.param的方式获取。</li>\n<li>onUnload()页面卸载时调用，比如调用redirectTo或者navigateBack时。</li>\n</ul>\n<h1 id=\"数据处理\"><a href=\"#数据处理\" class=\"headerlink\" title=\"数据处理\"></a>数据处理</h1><p>　　和jQuery等其他js框架不同的，小程序不能直接操作DOM元素，只能通过改变数据来控制页面元素的状态，这样有点类似React的思想。所以我觉得小程序的思想是面向数据，而不是面向元素。</p>\n<h2 id=\"数据绑定\"><a href=\"#数据绑定\" class=\"headerlink\" title=\"数据绑定\"></a>数据绑定</h2><p>　　上一节我们说过注册页面时需要传入一个object参数，这个参数可以挂载很多页面的生命周期函数，同时，也能将页面的数据挂载进去。页面的数据可以直接挂载到object参数的data对象中去。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Page(&#123;</div><div class=\"line\">\tdata:&#123;</div><div class=\"line\">\t\tname:<span class=\"string\">'xyf'</span></div><div class=\"line\">\t&#125;,</div><div class=\"line\">\tmyname:<span class=\"string\">'test'</span></div><div class=\"line\">\tonLoad:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>　　这里我们定义了两个数据，一个数据定义在data对象中，另一个数据直接定义Page的参数中。我们可以将data中的数据渲染到页面中，使用Mustache语法(双大括号)将要渲染的变量包起来，如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>如果需要在组件的属性内渲染数据，也需要用双大括号包起来：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">\"item-&#123;&#123;name&#125;&#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在双大括号中，我们可以进行简单的运算和判断，比如三元运算，算数运算，字符串运算等。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">\"&#123;&#123;name=='xyf'?'yes':'no'&#125;&#125;\"</span>&gt;</span>&#123;&#123;name+' is a smart boy'&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></div></pre></td></tr></table></figure>\n<h2 id=\"数据获取和更改\"><a href=\"#数据获取和更改\" class=\"headerlink\" title=\"数据获取和更改\"></a>数据获取和更改</h2><p>　　对于data中的数据，我们必须通过this.data.name这种方式来获取，对于data外面的数据，我们可以通过this.myname的方式来获取。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">onLoad:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.data.name); <span class=\"comment\">//'xyf'</span></div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.myname);    <span class=\"comment\">//'test'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>　　对于data中的数据，要想改变它的值，必须要调用setData()方法来改变，而要改变data外的数据，可以直接给他进行赋值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">onLoad:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.setData(&#123;</div><div class=\"line\">\t\tname:<span class=\"string\">'Corner'</span></div><div class=\"line\">\t&#125;);</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.data.name); <span class=\"comment\">//'Corner'</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.data.name=<span class=\"string\">'Nick'</span>;</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.data.name); <span class=\"comment\">//'Corner'</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.myname=<span class=\"string\">'mytest'</span>;</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.myname);    <span class=\"comment\">//'myest'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>注意：</strong></p>\n<ul>\n<li>在函数中注意this的作用域。在map函数或者异步回调函数中要使用this，要在函数外先把this赋值给that，然后用that进行操作。</li>\n<li>setData()对象参数的值不能为undefined。每次setData进行赋值时都要对要赋的值进行非空判断，确保不是undefined，否则会报错。</li>\n</ul>\n<p>总结一下，两种方式定义的数据区别如下：</p>\n<ul>\n<li>能否被渲染：页面只能动态渲染data中的数据，data外的数据不能被渲染到页面上，所以data中放一些需要页面动态渲染的数据</li>\n<li>获取方式：data中的数据通过this.data.[param]方式获取，data外的数据通过this.[param]方式获取。</li>\n<li>赋值方式：data中的数据只能通过setData()函数进行赋值，而data外的数据可以直接赋值。</li>\n</ul>\n<h1 id=\"页面渲染\"><a href=\"#页面渲染\" class=\"headerlink\" title=\"页面渲染\"></a>页面渲染</h1><p>　　对于data中的简单变量，我们可以通过双大括号的方式进行渲染，但是如果对于一些稍微复杂一点的数据结构(比如数组)，双大括号就不能满足我们的需求了。我们需要引入另外两种渲染方式，条件渲染和列表渲染。</p>\n<h2 id=\"条件渲染\"><a href=\"#条件渲染\" class=\"headerlink\" title=\"条件渲染\"></a>条件渲染</h2><p>　　我们使用wx:if=”“的来判断是否需要渲染该模块，还可以添加wx:elif和wx:else渲染。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">wx:if</span>=<span class=\"string\">\"&#123;&#123;length &gt; 5&#125;&#125;\"</span>&gt;</span> 大于 <span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">wx:elif</span>=<span class=\"string\">\"&#123;&#123;length &gt; 2&#125;&#125;\"</span>&gt;</span> 中等 <span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">wx:else</span>&gt;</span> 小于 <span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>　　也可以直接在大括号中使用布尔类型的值控制页面元素隐藏和显示。如果data中flag为false，那么类名为demo的这个view组件就不会渲染到页面上去。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">\"demo\"</span> <span class=\"attr\">wx:if</span>=<span class=\"string\">\"&#123;&#123;flag&#125;&#125;\"</span>&gt;</span></div><div class=\"line\">显示</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></div></pre></td></tr></table></figure>\n<h2 id=\"列表渲染\"><a href=\"#列表渲染\" class=\"headerlink\" title=\"列表渲染\"></a>列表渲染</h2><p>　　有时候我们需要将一个数组渲染到页面上，比如几个用户信息，比如点评列表，这时候就需要用到列表循环。<br>　　列表循环使用wx:for来绑定一个数组，就可以将数组中的每个数据循环遍历到组件中。默认情况下每个元素的变量名为item，每个变量的索引值为index。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">wx:for</span>=<span class=\"string\">\"&#123;&#123;['a','b','c','d']&#125;&#125;\"</span>&gt;</span></div><div class=\"line\">\t这是第&#123;&#123;index&#125;&#125;个元素，元素内容为&#123;&#123;item&#125;&#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>　　在列表遍历时我们并没有定义item和index，小程序自动为我们添加了wx:for-index=”index”和wx:for-item=”item”。因此在嵌套列表渲染时，注意index和item所代表的值和对象。需要我们自己定义变量名和索引，避免混乱。</p>\n<h1 id=\"总结和期待\"><a href=\"#总结和期待\" class=\"headerlink\" title=\"总结和期待\"></a>总结和期待</h1><p>　　微信小程序还在内测阶段就引起了这么多关注，作为一个程序员，尤其是一名前端程序员，上手和熟悉微信小程序的开发无疑会让我们越来越“吃香”。网上也在热议微信小程序是否会颠覆或者代替原生App，我觉得两者还是有以下区别的：</p>\n<ul>\n<li>产品形态：微信小程序更加接近于HTML5产品，开发上也使用JavaScript进行开发，性能比H5好，但是要比原生App性能低。而且微信小程序整体文件大小限制在1MB以内，估计只能运行一些小型的应用和游戏，一些大型的应用肯定还是要用App的。</li>\n<li>用户习惯：很多用户已经用惯了App，要想改变用户的习惯还是挺难的。用户操作肯定是越简单越好。比如现在微博App打开就能用，但是如果有了微博小程序，需要进入微信才能打开，相信用户还是挺反感中间多余的“步骤”。</li>\n</ul>\n<p>　　个人感觉微信小程序的开发也存在着不足之处，希望在以后的版本中能够改进：</p>\n<ul>\n<li>开发工具不能实时运行结果：每次都需要编译才能看到结果，程序猿表示每次看效果都比较麻烦。</li>\n<li>不支持ES6：现在ES6越来越流行，确实给开发带来了不少的简洁和便利。每次开发还要使用原生js，程序猿表示鸭梨山大啊。</li>\n<li>组件太少，不支持自定义组件：能够使用的组件偏少，大部分情况下只能使用view和text，不能够满足复杂的业务场景。</li>\n</ul>"},{"title":"微信小程序上手开发和使用总结（下）","date":"2016-10-11T08:53:26.000Z","description":null,"toc":null,"author":"Corner","comments":1,"original":null,"photos":[],"_content":"　　在[微信小程序上手开发和使用总结（上）](//xieyufei.com/2016/10/09/Front-Tiny-WeChat.html)中介绍了微信小程序的基本用法、数据处理和页面渲染等，这篇文章整理一下微信小程序的事件绑定及模板的用法。\n<!-- more -->\n\n# 模板\n　　WXML提供模板组件给我们使用，可以在模板定义公用的代码片段，然后在需要引用的地方进行调用。\n\n## 定义模板\n　　定义模板使用name属性作为模板的名字，然后在template标签中定义代码片段：\n\n```html\n<template name=\"mytemplate1\">\n  <view>\n    <text>firstName:{{firstName}}</text>\n    <text>lastName: {{lastName}}</text>\n  </view>\n</template>\n<template name=\"mytemplate2\">\n  <view wx:for=\"{{persons}}\">\n  \t<text>firstName:{{item.firstName}}</text>\n    <text>lastName: {{item.lastName}}</text>\n  </view>\n</template>\n```\n\n## 使用模板\n　　使用模板我们用is属性引用定义好的模板，然后把模板所需要的值通过data属性传给模板。比如需要遍历persons数组，我们可以将整个persons作为对象传给模板，也可以遍历persons后将每个对象传给模板，具体取决于所应用的场景。\n\n```html\n<view wx:for=\"{{persons}}\">\n  <template is=\"mytemplate1\" data=\"{{...item}}\"></template>\n</view>\n<template is=\"mytemplate2\" data=\"{{persons}}\"></template>\n```\n\n　　需要的数据结构如下\n```javascript\nPage({\n\tdata:{\n\t\tpersons:[\n\t\t\t{firstName: 'Hulk', lastName: 'Hu'},\n\t    \t{firstName: 'Shang', lastName: 'You'},\n\t    \t{firstName: 'Gideon', lastName: 'Lin'}\n\t\t]\n\t}\n})\n```\n\n**注意：**\n\n* is属性也可以使用Mustache语法进行动态渲染，决定使用哪个模板\n* data如果传的是对象类型的数据，需要用“...”进行“解构”，在模板中可以直接调用对象的属性；如果是其他数据类型则不需要用“...”\n\n# 事件\n　　什么是事件呢，简单来说，事件就是逻辑层到逻辑层的通讯方式。就是在页面上通过触发某个操作（就是我们说的事件），在逻辑层进行一系列的操作，最终来改变数据。\n　　比如在一个输入框中用户输入了一段文字，但是data中的数据并没有随之改变，因此我们需要在输入框上绑定对应的输入事件来更改数据。\n　　事件也有分类，可以分为冒泡事件和非冒泡事件。“冒泡”这个词很形象的表现了事件向上传递的过程，这两种事件的区别也在于是否会向父节点进行传递。\n　　一些常用的冒泡事件：\n|     名称     |            触发              |\n|       -      |             -                |\n| touchstart   | 手指开始触摸                 |\n| touchmove    | 手指触摸后移动               |\n| touchend     | 手指触摸动作结束             |\n| touchcancel  | 触摸被打断，比如来点，弹框等 |\n|    tap       | 触摸后离开，有点像点击click  |\n|   longtap    |    长按，超过350ms才离开     |\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Front-Tiny-WeChat-Next.md","raw":"title: 微信小程序上手开发和使用总结（下）\ndate: 2016-10-11 16:53:26\ndescription:\ncategories:\n- 编程\ntags:\n- 前端\n- WeChat\ntoc:\nauthor: Corner\ncomments:\noriginal:\npermalink:\nphotos:\n---\n　　在[微信小程序上手开发和使用总结（上）](//xieyufei.com/2016/10/09/Front-Tiny-WeChat.html)中介绍了微信小程序的基本用法、数据处理和页面渲染等，这篇文章整理一下微信小程序的事件绑定及模板的用法。\n<!-- more -->\n\n# 模板\n　　WXML提供模板组件给我们使用，可以在模板定义公用的代码片段，然后在需要引用的地方进行调用。\n\n## 定义模板\n　　定义模板使用name属性作为模板的名字，然后在template标签中定义代码片段：\n\n```html\n<template name=\"mytemplate1\">\n  <view>\n    <text>firstName:{{firstName}}</text>\n    <text>lastName: {{lastName}}</text>\n  </view>\n</template>\n<template name=\"mytemplate2\">\n  <view wx:for=\"{{persons}}\">\n  \t<text>firstName:{{item.firstName}}</text>\n    <text>lastName: {{item.lastName}}</text>\n  </view>\n</template>\n```\n\n## 使用模板\n　　使用模板我们用is属性引用定义好的模板，然后把模板所需要的值通过data属性传给模板。比如需要遍历persons数组，我们可以将整个persons作为对象传给模板，也可以遍历persons后将每个对象传给模板，具体取决于所应用的场景。\n\n```html\n<view wx:for=\"{{persons}}\">\n  <template is=\"mytemplate1\" data=\"{{...item}}\"></template>\n</view>\n<template is=\"mytemplate2\" data=\"{{persons}}\"></template>\n```\n\n　　需要的数据结构如下\n```javascript\nPage({\n\tdata:{\n\t\tpersons:[\n\t\t\t{firstName: 'Hulk', lastName: 'Hu'},\n\t    \t{firstName: 'Shang', lastName: 'You'},\n\t    \t{firstName: 'Gideon', lastName: 'Lin'}\n\t\t]\n\t}\n})\n```\n\n**注意：**\n\n* is属性也可以使用Mustache语法进行动态渲染，决定使用哪个模板\n* data如果传的是对象类型的数据，需要用“...”进行“解构”，在模板中可以直接调用对象的属性；如果是其他数据类型则不需要用“...”\n\n# 事件\n　　什么是事件呢，简单来说，事件就是逻辑层到逻辑层的通讯方式。就是在页面上通过触发某个操作（就是我们说的事件），在逻辑层进行一系列的操作，最终来改变数据。\n　　比如在一个输入框中用户输入了一段文字，但是data中的数据并没有随之改变，因此我们需要在输入框上绑定对应的输入事件来更改数据。\n　　事件也有分类，可以分为冒泡事件和非冒泡事件。“冒泡”这个词很形象的表现了事件向上传递的过程，这两种事件的区别也在于是否会向父节点进行传递。\n　　一些常用的冒泡事件：\n|     名称     |            触发              |\n|       -      |             -                |\n| touchstart   | 手指开始触摸                 |\n| touchmove    | 手指触摸后移动               |\n| touchend     | 手指触摸动作结束             |\n| touchcancel  | 触摸被打断，比如来点，弹框等 |\n|    tap       | 触摸后离开，有点像点击click  |\n|   longtap    |    长按，超过350ms才离开     |\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Front-Tiny-WeChat-Next","published":1,"updated":"2016-10-14T04:14:26.711Z","layout":"post","link":"","_id":"ciu99fu3r0002r8fia6jfgkst","content":"<p>　　在<a href=\"//xieyufei.com/2016/10/09/Front-Tiny-WeChat.html\">微信小程序上手开发和使用总结（上）</a>中介绍了微信小程序的基本用法、数据处理和页面渲染等，这篇文章整理一下微信小程序的事件绑定及模板的用法。<br><a id=\"more\"></a></p>\n<h1 id=\"模板\"><a href=\"#模板\" class=\"headerlink\" title=\"模板\"></a>模板</h1><p>　　WXML提供模板组件给我们使用，可以在模板定义公用的代码片段，然后在需要引用的地方进行调用。</p>\n<h2 id=\"定义模板\"><a href=\"#定义模板\" class=\"headerlink\" title=\"定义模板\"></a>定义模板</h2><p>　　定义模板使用name属性作为模板的名字，然后在template标签中定义代码片段：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">name</span>=<span class=\"string\">\"mytemplate1\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">view</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">text</span>&gt;</span>firstName:&#123;&#123;firstName&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">text</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">text</span>&gt;</span>lastName: &#123;&#123;lastName&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">text</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">name</span>=<span class=\"string\">\"mytemplate2\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">wx:for</span>=<span class=\"string\">\"&#123;&#123;persons&#125;&#125;\"</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">text</span>&gt;</span>firstName:&#123;&#123;item.firstName&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">text</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">text</span>&gt;</span>lastName: &#123;&#123;item.lastName&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">text</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div></pre></td></tr></table></figure>\n<h2 id=\"使用模板\"><a href=\"#使用模板\" class=\"headerlink\" title=\"使用模板\"></a>使用模板</h2><p>　　使用模板我们用is属性引用定义好的模板，然后把模板所需要的值通过data属性传给模板。比如需要遍历persons数组，我们可以将整个persons作为对象传给模板，也可以遍历persons后将每个对象传给模板，具体取决于所应用的场景。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">wx:for</span>=<span class=\"string\">\"&#123;&#123;persons&#125;&#125;\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">is</span>=<span class=\"string\">\"mytemplate1\"</span> <span class=\"attr\">data</span>=<span class=\"string\">\"&#123;&#123;...item&#125;&#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">is</span>=<span class=\"string\">\"mytemplate2\"</span> <span class=\"attr\">data</span>=<span class=\"string\">\"&#123;&#123;persons&#125;&#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>　　需要的数据结构如下<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">Page(&#123;</div><div class=\"line\">\tdata:&#123;</div><div class=\"line\">\t\tpersons:[</div><div class=\"line\">\t\t\t&#123;firstName: <span class=\"string\">'Hulk'</span>, lastName: <span class=\"string\">'Hu'</span>&#125;,</div><div class=\"line\">\t    \t&#123;firstName: <span class=\"string\">'Shang'</span>, lastName: <span class=\"string\">'You'</span>&#125;,</div><div class=\"line\">\t    \t&#123;firstName: <span class=\"string\">'Gideon'</span>, lastName: <span class=\"string\">'Lin'</span>&#125;</div><div class=\"line\">\t\t]</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p><strong>注意：</strong></p>\n<ul>\n<li>is属性也可以使用Mustache语法进行动态渲染，决定使用哪个模板</li>\n<li>data如果传的是对象类型的数据，需要用“…”进行“解构”，在模板中可以直接调用对象的属性；如果是其他数据类型则不需要用“…”</li>\n</ul>\n<h1 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h1><p>　　什么是事件呢，简单来说，事件就是逻辑层到逻辑层的通讯方式。就是在页面上通过触发某个操作（就是我们说的事件），在逻辑层进行一系列的操作，最终来改变数据。<br>　　比如在一个输入框中用户输入了一段文字，但是data中的数据并没有随之改变，因此我们需要在输入框上绑定对应的输入事件来更改数据。<br>　　事件也有分类，可以分为冒泡事件和非冒泡事件。“冒泡”这个词很形象的表现了事件向上传递的过程，这两种事件的区别也在于是否会向父节点进行传递。<br>　　一些常用的冒泡事件：<br>|     名称     |            触发              |<br>|       -      |             -                |<br>| touchstart   | 手指开始触摸                 |<br>| touchmove    | 手指触摸后移动               |<br>| touchend     | 手指触摸动作结束             |<br>| touchcancel  | 触摸被打断，比如来点，弹框等 |<br>|    tap       | 触摸后离开，有点像点击click  |<br>|   longtap    |    长按，超过350ms才离开     |</p>\n","excerpt":"<p>　　在<a href=\"//xieyufei.com/2016/10/09/Front-Tiny-WeChat.html\">微信小程序上手开发和使用总结（上）</a>中介绍了微信小程序的基本用法、数据处理和页面渲染等，这篇文章整理一下微信小程序的事件绑定及模板的用法。<br>","more":"</p>\n<h1 id=\"模板\"><a href=\"#模板\" class=\"headerlink\" title=\"模板\"></a>模板</h1><p>　　WXML提供模板组件给我们使用，可以在模板定义公用的代码片段，然后在需要引用的地方进行调用。</p>\n<h2 id=\"定义模板\"><a href=\"#定义模板\" class=\"headerlink\" title=\"定义模板\"></a>定义模板</h2><p>　　定义模板使用name属性作为模板的名字，然后在template标签中定义代码片段：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">name</span>=<span class=\"string\">\"mytemplate1\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">view</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">text</span>&gt;</span>firstName:&#123;&#123;firstName&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">text</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">text</span>&gt;</span>lastName: &#123;&#123;lastName&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">text</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">name</span>=<span class=\"string\">\"mytemplate2\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">wx:for</span>=<span class=\"string\">\"&#123;&#123;persons&#125;&#125;\"</span>&gt;</span></div><div class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">text</span>&gt;</span>firstName:&#123;&#123;item.firstName&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">text</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">text</span>&gt;</span>lastName: &#123;&#123;item.lastName&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">text</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div></pre></td></tr></table></figure>\n<h2 id=\"使用模板\"><a href=\"#使用模板\" class=\"headerlink\" title=\"使用模板\"></a>使用模板</h2><p>　　使用模板我们用is属性引用定义好的模板，然后把模板所需要的值通过data属性传给模板。比如需要遍历persons数组，我们可以将整个persons作为对象传给模板，也可以遍历persons后将每个对象传给模板，具体取决于所应用的场景。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">wx:for</span>=<span class=\"string\">\"&#123;&#123;persons&#125;&#125;\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">is</span>=<span class=\"string\">\"mytemplate1\"</span> <span class=\"attr\">data</span>=<span class=\"string\">\"&#123;&#123;...item&#125;&#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">is</span>=<span class=\"string\">\"mytemplate2\"</span> <span class=\"attr\">data</span>=<span class=\"string\">\"&#123;&#123;persons&#125;&#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>　　需要的数据结构如下<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">Page(&#123;</div><div class=\"line\">\tdata:&#123;</div><div class=\"line\">\t\tpersons:[</div><div class=\"line\">\t\t\t&#123;firstName: <span class=\"string\">'Hulk'</span>, lastName: <span class=\"string\">'Hu'</span>&#125;,</div><div class=\"line\">\t    \t&#123;firstName: <span class=\"string\">'Shang'</span>, lastName: <span class=\"string\">'You'</span>&#125;,</div><div class=\"line\">\t    \t&#123;firstName: <span class=\"string\">'Gideon'</span>, lastName: <span class=\"string\">'Lin'</span>&#125;</div><div class=\"line\">\t\t]</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p><strong>注意：</strong></p>\n<ul>\n<li>is属性也可以使用Mustache语法进行动态渲染，决定使用哪个模板</li>\n<li>data如果传的是对象类型的数据，需要用“…”进行“解构”，在模板中可以直接调用对象的属性；如果是其他数据类型则不需要用“…”</li>\n</ul>\n<h1 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h1><p>　　什么是事件呢，简单来说，事件就是逻辑层到逻辑层的通讯方式。就是在页面上通过触发某个操作（就是我们说的事件），在逻辑层进行一系列的操作，最终来改变数据。<br>　　比如在一个输入框中用户输入了一段文字，但是data中的数据并没有随之改变，因此我们需要在输入框上绑定对应的输入事件来更改数据。<br>　　事件也有分类，可以分为冒泡事件和非冒泡事件。“冒泡”这个词很形象的表现了事件向上传递的过程，这两种事件的区别也在于是否会向父节点进行传递。<br>　　一些常用的冒泡事件：<br>|     名称     |            触发              |<br>|       -      |             -                |<br>| touchstart   | 手指开始触摸                 |<br>| touchmove    | 手指触摸后移动               |<br>| touchend     | 手指触摸动作结束             |<br>| touchcancel  | 触摸被打断，比如来点，弹框等 |<br>|    tap       | 触摸后离开，有点像点击click  |<br>|   longtap    |    长按，超过350ms才离开     |</p>"},{"title":"CraftyJs初探","date":"2016-07-08T14:00:00.000Z","description":null,"toc":true,"author":"Corner","comments":1,"original":null,"photos":[],"_content":"　　前不久听了一趟分享课，分享课的主题是JS游戏的制作，但是如果是自己写游戏比较的繁琐，如果能应用一个游戏引擎，就能大大的简化游戏的开发速度和开发效率，于是我在网上参考了几个游戏引擎，找到了CraftyJs这个游戏引擎还是挺不错的，但是苦于网上的教程不是很全面，所以今天就开个坑，写个入门级的教程，仅供参考。\n<!-- more -->\n\n# 初始化\n　　首先从[官网](http://craftyjs.com/)上下载CraftyJs的脚本引用到项目中来。然后就可以开始写我们自己的程序了。\n```javascript\nCraftyJs.init(this.config.width,this.config.height);\n```\n　　这段代码用于初始化整个stage，用官方的话来说就是舞台，所有的元素将在这整个舞台里活动。这个舞台的宽度是this.config.width(px)，高度是this.config.height(px)。如果有元素超出了舞台的范围，这个元素将被遮住，因为整个舞台设置了样式overflow:hidden将超出的元素隐藏掉。\n```javascript\nCrafty.background(\"#f0f0f0\");\n```\n　　你还可以通过background()方法给整个舞台设置背景颜色\n\n# 放置场景\n　　当整个舞台初始化后就可以玩游戏了吧？不！你去剧院看戏一入座演员就给你演戏么，当然不是，还需要一些场景的带入和切换。这些场景比如加载动画、菜单选项等一系列。\n```javascript\nCrafty.defineScene(\"loading\", function() {\n\tCrafty.background(\"#000\");\n\tCrafty.e(\"2D, DOM, Text\").attr({\n\t\tw: 100,\n\t\th: 20,\n\t\tx: 150,\n\t\ty: 120\n\t}).text(\"Loading\").css({\n\t\t\"text-align\": \"center\"\n\t}).textColor(\"#FFFFFF\");\n});\n```\n　　我们可以使用Crafty.defineScene()方法来定义一个场景。在这里我们定义了一个叫loading的场景，里面只有一个元素就是一行\"Loading\"的字。但是定义好了场景并没有显示在舞台上，因为这个场景并没有被调用到。\n```javascript\nCrafty.enterScene(\"loading\");\n```\n　　通过enterScene()这个方法来展示刚才我们定义好场景，你会在舞台上看到这个场景。这个展示舞台的方法可以在任何地方被调用。但是需要注意的是这个方法会清除舞台上所有的元素，除了那些有\"Persist\"组件的元素（组件这一名词下面会解释到）。\n\n# 实体/组件系统\n　　现在到了CraftyJS最重要的部分来了，就是CraftyJS独特的实体/组件系统。这个系统有点面向对象编程的意思。整个系统分为两个部分。\n## 组件系统\n　　所谓的组件，有点类似JAVA中的对象（不是现实里的对象），看不见摸不着，是对实体的抽象。每个组件里封装了对应的方法，可以在实体中直接调用。CraftyJS中有很多已经被预先定义好的组件可以直接拿来使用，而且组件可以被重复地继承。\n## 实体系统\n　　实体是真正看得见的元素，是对组件的“实例化”。一个单一的实体能够继承多个实体。\n```javascript\nvar square = Crafty.e('2D, DOM, Color');\n```\n　　这样就通过e()方法定义了几个叫\"square\"的实体。这个实体继承了三个组件\"2D\"、\"DOM\"和\"Color\"，这三个组件预先在CraftyJS中就已经被定义好了。如果你觉得单单使用这三个组件还不够，你可以后续往\"square\"这个实体中再添加组件。\n```javascript\nsquare.addComponent(\"Text\");\n```\n　　通过addComponent()方法向实体中加入\"Text\"组件，这个方法支持一次添加多个组件。\n```javascript\nsquare.addComponent(\"Text,Mouse\");//这是可以的\n```\n　　你还可以通过has()方法判断某个实体中是否含有某个组件\n```javascript\nsquare.has(\"Mouse\");\n```\n　　这个方法返回一个boolean类型的值。但是需要注意的是这个方法一次性只能判断一个组件存在，并不支持同时判定多个组件比如：\n```javascript\nsquare.has(\"2D,DOM\");//这是错误的\n```\n　　如果你对某个组件不满意，你还可以把它删掉，这个方法也不支持传入两个以上的组件名称\n```javascript\nsquare.removeComponent(\"2D\");\n```\n# 常用的组件、属性和方法\n　　一些常用的组件是CratyJs帮我们定义好了，我们直接使用就可以了。\n## \"2D\"组件\n　　2D组件是CraftyJS预先给我们定义好的一个组件，是最常用的组件之一。他提供了一个attr()的方法让我们来设置实体的属性值。\n```javascript\nsquare.attr({\n  x: 150,\n  y: 150,\n  w: 100,\n  h: 100,\n  alpha: 0.5,\n  rotation: 45,\n  visible:true\n  });\n```\n　　这里的x和y是实体相对于舞台左上角的位置，单位都为像素(px)。w和h是实体的宽度和高度，单位也是像素(px)。alpha是实体的透明度，取值范围是0到1。visible代表实体是否可见，只能接受boolean类型的参数。x、y、w、h如果不设置值，默认为0。\n## \"Text\"组件\n　　Text组件有四个方法可以使用，分别是text()、textColor()、textFont()和unselectable()。text()方法用于设置组件里面的内容。\n```javascript\nCrafty.e(\"2D,DOM,Text\").text(\"hello world!\");\n```\n　　text()方法支持传入一个方法，但是这个方法必须要返回一个字符串类型的参数，否则这个组件的内容将会显示undefined(未定义)。\n```javascript\nCrafty.e(\"2D, Canvas, Text\").text(function () { \n\treturn \"hello world!\";\n});\n```\n　　textColor()方法用来设置组件文字的颜色，你可以使用HEX、rgb或者rgba的方式来定义颜色。\n```javascript\nCrafty.e(\"2D, DOM, Text\").textColor('#FF0000')\n\t\t.textColor('rgba(0, 255, 0, 0.5)')\n\t\t.textColor('white');\n```\n　　textFont()方法用来设置文字的字体。如果有多个字体的属性，传入一个对象的方式进行设置，Crafty支持设置的属性有以下几个：\n```javascript\nCrafty.e(\"2D, DOM, Text\").textFont({ 'type': 'italic', 'family': 'Arial' , 'size':'20px', 'weight':'bold', 'lineHeight':'30px'});\n```\n　　unselectable()方法设置Text组件中的内容不能被高亮选中。Canvas的Text是不能被高亮选中的，所以这个方法只对DOM的Text组件有效。\n```javascript\nCrafty.e(\"2D, DOM, Text\").text('This text cannot be highlighted!').unselectable();\n```","source":"_posts/CraftyJs-Start.md","raw":"title: CraftyJs初探\ndate: 2016-07-08 22:00:00\ndescription: \ncategories:\n- 编程\ntags:\n- 前端\n- 游戏引擎\n- CraftyJs\ntoc: true\nauthor: Corner\ncomments:\noriginal:\npermalink: \nphotos:\n---\n　　前不久听了一趟分享课，分享课的主题是JS游戏的制作，但是如果是自己写游戏比较的繁琐，如果能应用一个游戏引擎，就能大大的简化游戏的开发速度和开发效率，于是我在网上参考了几个游戏引擎，找到了CraftyJs这个游戏引擎还是挺不错的，但是苦于网上的教程不是很全面，所以今天就开个坑，写个入门级的教程，仅供参考。\n<!-- more -->\n\n# 初始化\n　　首先从[官网](http://craftyjs.com/)上下载CraftyJs的脚本引用到项目中来。然后就可以开始写我们自己的程序了。\n```javascript\nCraftyJs.init(this.config.width,this.config.height);\n```\n　　这段代码用于初始化整个stage，用官方的话来说就是舞台，所有的元素将在这整个舞台里活动。这个舞台的宽度是this.config.width(px)，高度是this.config.height(px)。如果有元素超出了舞台的范围，这个元素将被遮住，因为整个舞台设置了样式overflow:hidden将超出的元素隐藏掉。\n```javascript\nCrafty.background(\"#f0f0f0\");\n```\n　　你还可以通过background()方法给整个舞台设置背景颜色\n\n# 放置场景\n　　当整个舞台初始化后就可以玩游戏了吧？不！你去剧院看戏一入座演员就给你演戏么，当然不是，还需要一些场景的带入和切换。这些场景比如加载动画、菜单选项等一系列。\n```javascript\nCrafty.defineScene(\"loading\", function() {\n\tCrafty.background(\"#000\");\n\tCrafty.e(\"2D, DOM, Text\").attr({\n\t\tw: 100,\n\t\th: 20,\n\t\tx: 150,\n\t\ty: 120\n\t}).text(\"Loading\").css({\n\t\t\"text-align\": \"center\"\n\t}).textColor(\"#FFFFFF\");\n});\n```\n　　我们可以使用Crafty.defineScene()方法来定义一个场景。在这里我们定义了一个叫loading的场景，里面只有一个元素就是一行\"Loading\"的字。但是定义好了场景并没有显示在舞台上，因为这个场景并没有被调用到。\n```javascript\nCrafty.enterScene(\"loading\");\n```\n　　通过enterScene()这个方法来展示刚才我们定义好场景，你会在舞台上看到这个场景。这个展示舞台的方法可以在任何地方被调用。但是需要注意的是这个方法会清除舞台上所有的元素，除了那些有\"Persist\"组件的元素（组件这一名词下面会解释到）。\n\n# 实体/组件系统\n　　现在到了CraftyJS最重要的部分来了，就是CraftyJS独特的实体/组件系统。这个系统有点面向对象编程的意思。整个系统分为两个部分。\n## 组件系统\n　　所谓的组件，有点类似JAVA中的对象（不是现实里的对象），看不见摸不着，是对实体的抽象。每个组件里封装了对应的方法，可以在实体中直接调用。CraftyJS中有很多已经被预先定义好的组件可以直接拿来使用，而且组件可以被重复地继承。\n## 实体系统\n　　实体是真正看得见的元素，是对组件的“实例化”。一个单一的实体能够继承多个实体。\n```javascript\nvar square = Crafty.e('2D, DOM, Color');\n```\n　　这样就通过e()方法定义了几个叫\"square\"的实体。这个实体继承了三个组件\"2D\"、\"DOM\"和\"Color\"，这三个组件预先在CraftyJS中就已经被定义好了。如果你觉得单单使用这三个组件还不够，你可以后续往\"square\"这个实体中再添加组件。\n```javascript\nsquare.addComponent(\"Text\");\n```\n　　通过addComponent()方法向实体中加入\"Text\"组件，这个方法支持一次添加多个组件。\n```javascript\nsquare.addComponent(\"Text,Mouse\");//这是可以的\n```\n　　你还可以通过has()方法判断某个实体中是否含有某个组件\n```javascript\nsquare.has(\"Mouse\");\n```\n　　这个方法返回一个boolean类型的值。但是需要注意的是这个方法一次性只能判断一个组件存在，并不支持同时判定多个组件比如：\n```javascript\nsquare.has(\"2D,DOM\");//这是错误的\n```\n　　如果你对某个组件不满意，你还可以把它删掉，这个方法也不支持传入两个以上的组件名称\n```javascript\nsquare.removeComponent(\"2D\");\n```\n# 常用的组件、属性和方法\n　　一些常用的组件是CratyJs帮我们定义好了，我们直接使用就可以了。\n## \"2D\"组件\n　　2D组件是CraftyJS预先给我们定义好的一个组件，是最常用的组件之一。他提供了一个attr()的方法让我们来设置实体的属性值。\n```javascript\nsquare.attr({\n  x: 150,\n  y: 150,\n  w: 100,\n  h: 100,\n  alpha: 0.5,\n  rotation: 45,\n  visible:true\n  });\n```\n　　这里的x和y是实体相对于舞台左上角的位置，单位都为像素(px)。w和h是实体的宽度和高度，单位也是像素(px)。alpha是实体的透明度，取值范围是0到1。visible代表实体是否可见，只能接受boolean类型的参数。x、y、w、h如果不设置值，默认为0。\n## \"Text\"组件\n　　Text组件有四个方法可以使用，分别是text()、textColor()、textFont()和unselectable()。text()方法用于设置组件里面的内容。\n```javascript\nCrafty.e(\"2D,DOM,Text\").text(\"hello world!\");\n```\n　　text()方法支持传入一个方法，但是这个方法必须要返回一个字符串类型的参数，否则这个组件的内容将会显示undefined(未定义)。\n```javascript\nCrafty.e(\"2D, Canvas, Text\").text(function () { \n\treturn \"hello world!\";\n});\n```\n　　textColor()方法用来设置组件文字的颜色，你可以使用HEX、rgb或者rgba的方式来定义颜色。\n```javascript\nCrafty.e(\"2D, DOM, Text\").textColor('#FF0000')\n\t\t.textColor('rgba(0, 255, 0, 0.5)')\n\t\t.textColor('white');\n```\n　　textFont()方法用来设置文字的字体。如果有多个字体的属性，传入一个对象的方式进行设置，Crafty支持设置的属性有以下几个：\n```javascript\nCrafty.e(\"2D, DOM, Text\").textFont({ 'type': 'italic', 'family': 'Arial' , 'size':'20px', 'weight':'bold', 'lineHeight':'30px'});\n```\n　　unselectable()方法设置Text组件中的内容不能被高亮选中。Canvas的Text是不能被高亮选中的，所以这个方法只对DOM的Text组件有效。\n```javascript\nCrafty.e(\"2D, DOM, Text\").text('This text cannot be highlighted!').unselectable();\n```","slug":"CraftyJs-Start","published":1,"updated":"2016-10-09T01:08:09.223Z","layout":"post","link":"","_id":"ciu99fu400006r8fi02bhbkmp","content":"<p>　　前不久听了一趟分享课，分享课的主题是JS游戏的制作，但是如果是自己写游戏比较的繁琐，如果能应用一个游戏引擎，就能大大的简化游戏的开发速度和开发效率，于是我在网上参考了几个游戏引擎，找到了CraftyJs这个游戏引擎还是挺不错的，但是苦于网上的教程不是很全面，所以今天就开个坑，写个入门级的教程，仅供参考。<br><a id=\"more\"></a></p>\n<h1 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h1><p>　　首先从<a href=\"http://craftyjs.com/\" target=\"_blank\" rel=\"external\">官网</a>上下载CraftyJs的脚本引用到项目中来。然后就可以开始写我们自己的程序了。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">CraftyJs.init(<span class=\"keyword\">this</span>.config.width,<span class=\"keyword\">this</span>.config.height);</div></pre></td></tr></table></figure></p>\n<p>　　这段代码用于初始化整个stage，用官方的话来说就是舞台，所有的元素将在这整个舞台里活动。这个舞台的宽度是this.config.width(px)，高度是this.config.height(px)。如果有元素超出了舞台的范围，这个元素将被遮住，因为整个舞台设置了样式overflow:hidden将超出的元素隐藏掉。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Crafty.background(<span class=\"string\">\"#f0f0f0\"</span>);</div></pre></td></tr></table></figure></p>\n<p>　　你还可以通过background()方法给整个舞台设置背景颜色</p>\n<h1 id=\"放置场景\"><a href=\"#放置场景\" class=\"headerlink\" title=\"放置场景\"></a>放置场景</h1><p>　　当整个舞台初始化后就可以玩游戏了吧？不！你去剧院看戏一入座演员就给你演戏么，当然不是，还需要一些场景的带入和切换。这些场景比如加载动画、菜单选项等一系列。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">Crafty.defineScene(<span class=\"string\">\"loading\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\tCrafty.background(<span class=\"string\">\"#000\"</span>);</div><div class=\"line\">\tCrafty.e(<span class=\"string\">\"2D, DOM, Text\"</span>).attr(&#123;</div><div class=\"line\">\t\tw: <span class=\"number\">100</span>,</div><div class=\"line\">\t\th: <span class=\"number\">20</span>,</div><div class=\"line\">\t\tx: <span class=\"number\">150</span>,</div><div class=\"line\">\t\ty: <span class=\"number\">120</span></div><div class=\"line\">\t&#125;).text(<span class=\"string\">\"Loading\"</span>).css(&#123;</div><div class=\"line\">\t\t<span class=\"string\">\"text-align\"</span>: <span class=\"string\">\"center\"</span></div><div class=\"line\">\t&#125;).textColor(<span class=\"string\">\"#FFFFFF\"</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>　　我们可以使用Crafty.defineScene()方法来定义一个场景。在这里我们定义了一个叫loading的场景，里面只有一个元素就是一行”Loading”的字。但是定义好了场景并没有显示在舞台上，因为这个场景并没有被调用到。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Crafty.enterScene(<span class=\"string\">\"loading\"</span>);</div></pre></td></tr></table></figure></p>\n<p>　　通过enterScene()这个方法来展示刚才我们定义好场景，你会在舞台上看到这个场景。这个展示舞台的方法可以在任何地方被调用。但是需要注意的是这个方法会清除舞台上所有的元素，除了那些有”Persist”组件的元素（组件这一名词下面会解释到）。</p>\n<h1 id=\"实体-组件系统\"><a href=\"#实体-组件系统\" class=\"headerlink\" title=\"实体/组件系统\"></a>实体/组件系统</h1><p>　　现在到了CraftyJS最重要的部分来了，就是CraftyJS独特的实体/组件系统。这个系统有点面向对象编程的意思。整个系统分为两个部分。</p>\n<h2 id=\"组件系统\"><a href=\"#组件系统\" class=\"headerlink\" title=\"组件系统\"></a>组件系统</h2><p>　　所谓的组件，有点类似JAVA中的对象（不是现实里的对象），看不见摸不着，是对实体的抽象。每个组件里封装了对应的方法，可以在实体中直接调用。CraftyJS中有很多已经被预先定义好的组件可以直接拿来使用，而且组件可以被重复地继承。</p>\n<h2 id=\"实体系统\"><a href=\"#实体系统\" class=\"headerlink\" title=\"实体系统\"></a>实体系统</h2><p>　　实体是真正看得见的元素，是对组件的“实例化”。一个单一的实体能够继承多个实体。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> square = Crafty.e(<span class=\"string\">'2D, DOM, Color'</span>);</div></pre></td></tr></table></figure></p>\n<p>　　这样就通过e()方法定义了几个叫”square”的实体。这个实体继承了三个组件”2D”、”DOM”和”Color”，这三个组件预先在CraftyJS中就已经被定义好了。如果你觉得单单使用这三个组件还不够，你可以后续往”square”这个实体中再添加组件。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">square.addComponent(<span class=\"string\">\"Text\"</span>);</div></pre></td></tr></table></figure></p>\n<p>　　通过addComponent()方法向实体中加入”Text”组件，这个方法支持一次添加多个组件。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">square.addComponent(<span class=\"string\">\"Text,Mouse\"</span>);<span class=\"comment\">//这是可以的</span></div></pre></td></tr></table></figure></p>\n<p>　　你还可以通过has()方法判断某个实体中是否含有某个组件<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">square.has(<span class=\"string\">\"Mouse\"</span>);</div></pre></td></tr></table></figure></p>\n<p>　　这个方法返回一个boolean类型的值。但是需要注意的是这个方法一次性只能判断一个组件存在，并不支持同时判定多个组件比如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">square.has(<span class=\"string\">\"2D,DOM\"</span>);<span class=\"comment\">//这是错误的</span></div></pre></td></tr></table></figure></p>\n<p>　　如果你对某个组件不满意，你还可以把它删掉，这个方法也不支持传入两个以上的组件名称<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">square.removeComponent(<span class=\"string\">\"2D\"</span>);</div></pre></td></tr></table></figure></p>\n<h1 id=\"常用的组件、属性和方法\"><a href=\"#常用的组件、属性和方法\" class=\"headerlink\" title=\"常用的组件、属性和方法\"></a>常用的组件、属性和方法</h1><p>　　一些常用的组件是CratyJs帮我们定义好了，我们直接使用就可以了。</p>\n<h2 id=\"“2D”组件\"><a href=\"#“2D”组件\" class=\"headerlink\" title=\"“2D”组件\"></a>“2D”组件</h2><p>　　2D组件是CraftyJS预先给我们定义好的一个组件，是最常用的组件之一。他提供了一个attr()的方法让我们来设置实体的属性值。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">square.attr(&#123;</div><div class=\"line\">  x: <span class=\"number\">150</span>,</div><div class=\"line\">  y: <span class=\"number\">150</span>,</div><div class=\"line\">  w: <span class=\"number\">100</span>,</div><div class=\"line\">  h: <span class=\"number\">100</span>,</div><div class=\"line\">  alpha: <span class=\"number\">0.5</span>,</div><div class=\"line\">  rotation: <span class=\"number\">45</span>,</div><div class=\"line\">  visible:<span class=\"literal\">true</span></div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure></p>\n<p>　　这里的x和y是实体相对于舞台左上角的位置，单位都为像素(px)。w和h是实体的宽度和高度，单位也是像素(px)。alpha是实体的透明度，取值范围是0到1。visible代表实体是否可见，只能接受boolean类型的参数。x、y、w、h如果不设置值，默认为0。</p>\n<h2 id=\"“Text”组件\"><a href=\"#“Text”组件\" class=\"headerlink\" title=\"“Text”组件\"></a>“Text”组件</h2><p>　　Text组件有四个方法可以使用，分别是text()、textColor()、textFont()和unselectable()。text()方法用于设置组件里面的内容。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Crafty.e(<span class=\"string\">\"2D,DOM,Text\"</span>).text(<span class=\"string\">\"hello world!\"</span>);</div></pre></td></tr></table></figure></p>\n<p>　　text()方法支持传入一个方法，但是这个方法必须要返回一个字符串类型的参数，否则这个组件的内容将会显示undefined(未定义)。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Crafty.e(<span class=\"string\">\"2D, Canvas, Text\"</span>).text(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; </div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">\"hello world!\"</span>;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>　　textColor()方法用来设置组件文字的颜色，你可以使用HEX、rgb或者rgba的方式来定义颜色。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Crafty.e(<span class=\"string\">\"2D, DOM, Text\"</span>).textColor(<span class=\"string\">'#FF0000'</span>)</div><div class=\"line\">\t\t.textColor(<span class=\"string\">'rgba(0, 255, 0, 0.5)'</span>)</div><div class=\"line\">\t\t.textColor(<span class=\"string\">'white'</span>);</div></pre></td></tr></table></figure></p>\n<p>　　textFont()方法用来设置文字的字体。如果有多个字体的属性，传入一个对象的方式进行设置，Crafty支持设置的属性有以下几个：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Crafty.e(<span class=\"string\">\"2D, DOM, Text\"</span>).textFont(&#123; <span class=\"string\">'type'</span>: <span class=\"string\">'italic'</span>, <span class=\"string\">'family'</span>: <span class=\"string\">'Arial'</span> , <span class=\"string\">'size'</span>:<span class=\"string\">'20px'</span>, <span class=\"string\">'weight'</span>:<span class=\"string\">'bold'</span>, <span class=\"string\">'lineHeight'</span>:<span class=\"string\">'30px'</span>&#125;);</div></pre></td></tr></table></figure></p>\n<p>　　unselectable()方法设置Text组件中的内容不能被高亮选中。Canvas的Text是不能被高亮选中的，所以这个方法只对DOM的Text组件有效。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Crafty.e(<span class=\"string\">\"2D, DOM, Text\"</span>).text(<span class=\"string\">'This text cannot be highlighted!'</span>).unselectable();</div></pre></td></tr></table></figure></p>\n","excerpt":"<p>　　前不久听了一趟分享课，分享课的主题是JS游戏的制作，但是如果是自己写游戏比较的繁琐，如果能应用一个游戏引擎，就能大大的简化游戏的开发速度和开发效率，于是我在网上参考了几个游戏引擎，找到了CraftyJs这个游戏引擎还是挺不错的，但是苦于网上的教程不是很全面，所以今天就开个坑，写个入门级的教程，仅供参考。<br>","more":"</p>\n<h1 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h1><p>　　首先从<a href=\"http://craftyjs.com/\">官网</a>上下载CraftyJs的脚本引用到项目中来。然后就可以开始写我们自己的程序了。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">CraftyJs.init(<span class=\"keyword\">this</span>.config.width,<span class=\"keyword\">this</span>.config.height);</div></pre></td></tr></table></figure></p>\n<p>　　这段代码用于初始化整个stage，用官方的话来说就是舞台，所有的元素将在这整个舞台里活动。这个舞台的宽度是this.config.width(px)，高度是this.config.height(px)。如果有元素超出了舞台的范围，这个元素将被遮住，因为整个舞台设置了样式overflow:hidden将超出的元素隐藏掉。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Crafty.background(<span class=\"string\">\"#f0f0f0\"</span>);</div></pre></td></tr></table></figure></p>\n<p>　　你还可以通过background()方法给整个舞台设置背景颜色</p>\n<h1 id=\"放置场景\"><a href=\"#放置场景\" class=\"headerlink\" title=\"放置场景\"></a>放置场景</h1><p>　　当整个舞台初始化后就可以玩游戏了吧？不！你去剧院看戏一入座演员就给你演戏么，当然不是，还需要一些场景的带入和切换。这些场景比如加载动画、菜单选项等一系列。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">Crafty.defineScene(<span class=\"string\">\"loading\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\tCrafty.background(<span class=\"string\">\"#000\"</span>);</div><div class=\"line\">\tCrafty.e(<span class=\"string\">\"2D, DOM, Text\"</span>).attr(&#123;</div><div class=\"line\">\t\tw: <span class=\"number\">100</span>,</div><div class=\"line\">\t\th: <span class=\"number\">20</span>,</div><div class=\"line\">\t\tx: <span class=\"number\">150</span>,</div><div class=\"line\">\t\ty: <span class=\"number\">120</span></div><div class=\"line\">\t&#125;).text(<span class=\"string\">\"Loading\"</span>).css(&#123;</div><div class=\"line\">\t\t<span class=\"string\">\"text-align\"</span>: <span class=\"string\">\"center\"</span></div><div class=\"line\">\t&#125;).textColor(<span class=\"string\">\"#FFFFFF\"</span>);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>　　我们可以使用Crafty.defineScene()方法来定义一个场景。在这里我们定义了一个叫loading的场景，里面只有一个元素就是一行”Loading”的字。但是定义好了场景并没有显示在舞台上，因为这个场景并没有被调用到。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Crafty.enterScene(<span class=\"string\">\"loading\"</span>);</div></pre></td></tr></table></figure></p>\n<p>　　通过enterScene()这个方法来展示刚才我们定义好场景，你会在舞台上看到这个场景。这个展示舞台的方法可以在任何地方被调用。但是需要注意的是这个方法会清除舞台上所有的元素，除了那些有”Persist”组件的元素（组件这一名词下面会解释到）。</p>\n<h1 id=\"实体-组件系统\"><a href=\"#实体-组件系统\" class=\"headerlink\" title=\"实体/组件系统\"></a>实体/组件系统</h1><p>　　现在到了CraftyJS最重要的部分来了，就是CraftyJS独特的实体/组件系统。这个系统有点面向对象编程的意思。整个系统分为两个部分。</p>\n<h2 id=\"组件系统\"><a href=\"#组件系统\" class=\"headerlink\" title=\"组件系统\"></a>组件系统</h2><p>　　所谓的组件，有点类似JAVA中的对象（不是现实里的对象），看不见摸不着，是对实体的抽象。每个组件里封装了对应的方法，可以在实体中直接调用。CraftyJS中有很多已经被预先定义好的组件可以直接拿来使用，而且组件可以被重复地继承。</p>\n<h2 id=\"实体系统\"><a href=\"#实体系统\" class=\"headerlink\" title=\"实体系统\"></a>实体系统</h2><p>　　实体是真正看得见的元素，是对组件的“实例化”。一个单一的实体能够继承多个实体。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> square = Crafty.e(<span class=\"string\">'2D, DOM, Color'</span>);</div></pre></td></tr></table></figure></p>\n<p>　　这样就通过e()方法定义了几个叫”square”的实体。这个实体继承了三个组件”2D”、”DOM”和”Color”，这三个组件预先在CraftyJS中就已经被定义好了。如果你觉得单单使用这三个组件还不够，你可以后续往”square”这个实体中再添加组件。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">square.addComponent(<span class=\"string\">\"Text\"</span>);</div></pre></td></tr></table></figure></p>\n<p>　　通过addComponent()方法向实体中加入”Text”组件，这个方法支持一次添加多个组件。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">square.addComponent(<span class=\"string\">\"Text,Mouse\"</span>);<span class=\"comment\">//这是可以的</span></div></pre></td></tr></table></figure></p>\n<p>　　你还可以通过has()方法判断某个实体中是否含有某个组件<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">square.has(<span class=\"string\">\"Mouse\"</span>);</div></pre></td></tr></table></figure></p>\n<p>　　这个方法返回一个boolean类型的值。但是需要注意的是这个方法一次性只能判断一个组件存在，并不支持同时判定多个组件比如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">square.has(<span class=\"string\">\"2D,DOM\"</span>);<span class=\"comment\">//这是错误的</span></div></pre></td></tr></table></figure></p>\n<p>　　如果你对某个组件不满意，你还可以把它删掉，这个方法也不支持传入两个以上的组件名称<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">square.removeComponent(<span class=\"string\">\"2D\"</span>);</div></pre></td></tr></table></figure></p>\n<h1 id=\"常用的组件、属性和方法\"><a href=\"#常用的组件、属性和方法\" class=\"headerlink\" title=\"常用的组件、属性和方法\"></a>常用的组件、属性和方法</h1><p>　　一些常用的组件是CratyJs帮我们定义好了，我们直接使用就可以了。</p>\n<h2 id=\"“2D”组件\"><a href=\"#“2D”组件\" class=\"headerlink\" title=\"“2D”组件\"></a>“2D”组件</h2><p>　　2D组件是CraftyJS预先给我们定义好的一个组件，是最常用的组件之一。他提供了一个attr()的方法让我们来设置实体的属性值。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">square.attr(&#123;</div><div class=\"line\">  x: <span class=\"number\">150</span>,</div><div class=\"line\">  y: <span class=\"number\">150</span>,</div><div class=\"line\">  w: <span class=\"number\">100</span>,</div><div class=\"line\">  h: <span class=\"number\">100</span>,</div><div class=\"line\">  alpha: <span class=\"number\">0.5</span>,</div><div class=\"line\">  rotation: <span class=\"number\">45</span>,</div><div class=\"line\">  visible:<span class=\"literal\">true</span></div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure></p>\n<p>　　这里的x和y是实体相对于舞台左上角的位置，单位都为像素(px)。w和h是实体的宽度和高度，单位也是像素(px)。alpha是实体的透明度，取值范围是0到1。visible代表实体是否可见，只能接受boolean类型的参数。x、y、w、h如果不设置值，默认为0。</p>\n<h2 id=\"“Text”组件\"><a href=\"#“Text”组件\" class=\"headerlink\" title=\"“Text”组件\"></a>“Text”组件</h2><p>　　Text组件有四个方法可以使用，分别是text()、textColor()、textFont()和unselectable()。text()方法用于设置组件里面的内容。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Crafty.e(<span class=\"string\">\"2D,DOM,Text\"</span>).text(<span class=\"string\">\"hello world!\"</span>);</div></pre></td></tr></table></figure></p>\n<p>　　text()方法支持传入一个方法，但是这个方法必须要返回一个字符串类型的参数，否则这个组件的内容将会显示undefined(未定义)。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Crafty.e(<span class=\"string\">\"2D, Canvas, Text\"</span>).text(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; </div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">\"hello world!\"</span>;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>　　textColor()方法用来设置组件文字的颜色，你可以使用HEX、rgb或者rgba的方式来定义颜色。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Crafty.e(<span class=\"string\">\"2D, DOM, Text\"</span>).textColor(<span class=\"string\">'#FF0000'</span>)</div><div class=\"line\">\t\t.textColor(<span class=\"string\">'rgba(0, 255, 0, 0.5)'</span>)</div><div class=\"line\">\t\t.textColor(<span class=\"string\">'white'</span>);</div></pre></td></tr></table></figure></p>\n<p>　　textFont()方法用来设置文字的字体。如果有多个字体的属性，传入一个对象的方式进行设置，Crafty支持设置的属性有以下几个：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Crafty.e(<span class=\"string\">\"2D, DOM, Text\"</span>).textFont(&#123; <span class=\"string\">'type'</span>: <span class=\"string\">'italic'</span>, <span class=\"string\">'family'</span>: <span class=\"string\">'Arial'</span> , <span class=\"string\">'size'</span>:<span class=\"string\">'20px'</span>, <span class=\"string\">'weight'</span>:<span class=\"string\">'bold'</span>, <span class=\"string\">'lineHeight'</span>:<span class=\"string\">'30px'</span>&#125;);</div></pre></td></tr></table></figure></p>\n<p>　　unselectable()方法设置Text组件中的内容不能被高亮选中。Canvas的Text是不能被高亮选中的，所以这个方法只对DOM的Text组件有效。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Crafty.e(<span class=\"string\">\"2D, DOM, Text\"</span>).text(<span class=\"string\">'This text cannot be highlighted!'</span>).unselectable();</div></pre></td></tr></table></figure></p>"},{"title":"Hexo+GitHub搭建个人博客（上）","date":"2016-09-12T07:54:00.000Z","description":null,"toc":true,"author":"Corner","comments":1,"original":null,"photos":["http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg","http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg"],"_content":"　　使用Hexo+GitHub搭建个人博客ssss\n<!-- more -->\n\n# 使用Hexo+GitHub搭建个人博客\n占位","source":"_posts/HexoGitHub-Start.md","raw":"title: Hexo+GitHub搭建个人博客（上）\ndate: 2016-09-12 15:54:00\ndescription: \ncategories:\n- 编程\ntags:\n- git\ntoc: true\nauthor: Corner\ncomments:\noriginal:\npermalink: \nphotos:\n- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg\n- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg\n---\n　　使用Hexo+GitHub搭建个人博客ssss\n<!-- more -->\n\n# 使用Hexo+GitHub搭建个人博客\n占位","slug":"HexoGitHub-Start","published":1,"updated":"2016-09-13T09:00:52.313Z","layout":"post","link":"","_id":"ciu99fu430008r8ficm64h0yq","content":"<p>　　使用Hexo+GitHub搭建个人博客ssss<br><a id=\"more\"></a></p>\n<h1 id=\"使用Hexo-GitHub搭建个人博客\"><a href=\"#使用Hexo-GitHub搭建个人博客\" class=\"headerlink\" title=\"使用Hexo+GitHub搭建个人博客\"></a>使用Hexo+GitHub搭建个人博客</h1><p>占位</p>\n","excerpt":"<p>　　使用Hexo+GitHub搭建个人博客ssss<br>","more":"</p>\n<h1 id=\"使用Hexo-GitHub搭建个人博客\"><a href=\"#使用Hexo-GitHub搭建个人博客\" class=\"headerlink\" title=\"使用Hexo+GitHub搭建个人博客\"></a>使用Hexo+GitHub搭建个人博客</h1><p>占位</p>"},{"title":"Js中this的用法","date":"2016-09-18T04:02:50.000Z","description":null,"toc":null,"author":"Corner","comments":1,"original":null,"photos":[],"_content":"　　this在js中是一个常见的变量，在不同的函数中this指代了不同的变量。刚开始我很困惑，怎么在这里是这个意思，到了相似的函数中却又改变了意思，让我很摸不着头脑。所以整理一下this的用法\n<!-- more -->\n\n# 全局作用域中的this\n\n　　在全局作用域中，this指向了Window对象。\n\n```javascript\nthis.name='xyf';\nconsole.log(this);\n```\n　　在上面我们把name挂载到了全局作用域Window下面，其实我们在用var声明变量的时候也是把变量挂载到Window下面。所以上面的操作等价于下面的操作\n```javascript\nvar name='xyf';\nconsole.log(this);\n```\n\n# 函数中的this\n　　在js中函数分为普通的函数和构造函数，主要的区别就是函数的调用形式。普通函数能够直接调用，而构造函数是不能调用，需要用new实例化。\n## 普通函数中的this\n　　普通函数的中this指向了Window对象\n```javascript\nfunction show(name){\n\tthis.name=name;\n}\nshow('xyf');\n```\n　　这时候函数show作为一个普通函数调用，虽然看起来像构造函数，但是内部的this却指向了Window对象，如果你在控制台打印Window对象，它下面挂载了name属性\n\n## 构造函数中的this\n　　构造函数中的this则指向了它所实例化的对象\n```javascript\nfunction show(name){\n\tthis.name=name;\n}\nvar myshow=new show('xyf');\nconsole.log(myshow.name);  //'xyf'\n```\n　　在这里如果你直接调用show('xyf')跟普通函数没有区别，通过new实例化一个myshow对象，这时候this就指向了这个实例化出来的对象\n\n\n# 对象中的this\n\n　　对象中的this指向了当前对象\n\n```javascript\nvar person={\n\tname='origin',\n\tsetName:function(name){\n\t\tthis.name=name\n\t},\n\tgetName:function(){\n\t\treturn this.name;\n\t}\n}\nperson.setName('xyf');\nconsole.log(person.getName()); //'xyf'\n```\n\n　　但是如果对象的函数中嵌套了其他函数，this的指向就被改变了。\n\n## 嵌套自执行函数\n```javascript\nvar person={\n\tname='origin',\n\tsetName:function(name){\n\t\t(function(name){\n\t\t\tthis.name=name;\n\t\t})(name);\n\t},\n\tgetName:function(){\n\t\treturn this.name;\n\t}\n}\nperson.setName('xyf');\nconsole.log(person.getName()); //'origin'\n```\n　　这时候自执行函数中的this指向了全局对象Window，所以setName()函数并不能产生作用。\n\n\n## 嵌套回调函数\n```javascript\nvar person={\n\tname='origin',\n\tsetName:function(name){\n\t\t$('.temp').on('click',function(e){\n\t\t\tthis.name=name;\n\t\t});\n\t},\n\tgetName:function(){\n\t\treturn this.name;\n\t}\n}\nperson.setName('xyf');\nconsole.log(person.getName()); //'origin'\n```\n\n　　这里的this指向了$('.temp')这个对象。为了避免这些情况，我们先将this赋值给局部变量that，然后使用that。这时候that就指向了我们需要的对象。\n```javascript\nvar that=this;\n(function(name){\n\tthat.name=name;\n})(name);\n```\n\n## 特别声明\n　　如果将一个对象中的函数赋值给一个变量，再通过该变量调用这个函数，此时函数中的this指向Window对象，即使这个操作在回调函数中。\n```javascript\nvar person={\n\tname:\"person\",\n\tsetName:function(name){\n\t\tthis.name=name\n\t},\n\tgetName:function(){\n\t\treturn this.name;\n\t}\n}\nvar temp={\n\tname:\"temp\",\n\ttempFun:function(){\n\t\t$('.temp').on('click',function(){\n\t\t\tvar fun=person.getName;\n\t\t\tfun(); //''\n\t\t})\n\t}\n}\ntemp.tempFun();\n```\n\n# 使用apply和call函数改变this指向\n　　这两个函数都能够手动指定被调用函数内部this指向哪个对象。\n\n```javascript\nfunction person(name){\n\tthis.name=\"\";\n\tthis.setName=function(name){\n\t\tthis.name=name;\n\t}\n}\n\nvar p1=new person('p1');\nvar p2=new person('p2');\np1.setName('p1');\np2.setName('p2');\n\n//p1.setName.apply(p2,['c']);\np1.setName.call(p2,'c');\nconsole.log(p2.name); //'c'\n```\n　　当对象p1使用apply函数后，p1对象中的this就指向了对象p2，此时对象p1的setName函数的操作就作用在了p2对象上。\n\n\n\n\n\n\n","source":"_posts/Explain-Js-This.md","raw":"title: Js中this的用法\ndate: 2016-09-18 12:02:50\ndescription:\ncategories:\n- 编程\ntags:\n- JS\n- 前端\ntoc:\nauthor: Corner\ncomments:\noriginal:\npermalink:\nphotos:\n---\n　　this在js中是一个常见的变量，在不同的函数中this指代了不同的变量。刚开始我很困惑，怎么在这里是这个意思，到了相似的函数中却又改变了意思，让我很摸不着头脑。所以整理一下this的用法\n<!-- more -->\n\n# 全局作用域中的this\n\n　　在全局作用域中，this指向了Window对象。\n\n```javascript\nthis.name='xyf';\nconsole.log(this);\n```\n　　在上面我们把name挂载到了全局作用域Window下面，其实我们在用var声明变量的时候也是把变量挂载到Window下面。所以上面的操作等价于下面的操作\n```javascript\nvar name='xyf';\nconsole.log(this);\n```\n\n# 函数中的this\n　　在js中函数分为普通的函数和构造函数，主要的区别就是函数的调用形式。普通函数能够直接调用，而构造函数是不能调用，需要用new实例化。\n## 普通函数中的this\n　　普通函数的中this指向了Window对象\n```javascript\nfunction show(name){\n\tthis.name=name;\n}\nshow('xyf');\n```\n　　这时候函数show作为一个普通函数调用，虽然看起来像构造函数，但是内部的this却指向了Window对象，如果你在控制台打印Window对象，它下面挂载了name属性\n\n## 构造函数中的this\n　　构造函数中的this则指向了它所实例化的对象\n```javascript\nfunction show(name){\n\tthis.name=name;\n}\nvar myshow=new show('xyf');\nconsole.log(myshow.name);  //'xyf'\n```\n　　在这里如果你直接调用show('xyf')跟普通函数没有区别，通过new实例化一个myshow对象，这时候this就指向了这个实例化出来的对象\n\n\n# 对象中的this\n\n　　对象中的this指向了当前对象\n\n```javascript\nvar person={\n\tname='origin',\n\tsetName:function(name){\n\t\tthis.name=name\n\t},\n\tgetName:function(){\n\t\treturn this.name;\n\t}\n}\nperson.setName('xyf');\nconsole.log(person.getName()); //'xyf'\n```\n\n　　但是如果对象的函数中嵌套了其他函数，this的指向就被改变了。\n\n## 嵌套自执行函数\n```javascript\nvar person={\n\tname='origin',\n\tsetName:function(name){\n\t\t(function(name){\n\t\t\tthis.name=name;\n\t\t})(name);\n\t},\n\tgetName:function(){\n\t\treturn this.name;\n\t}\n}\nperson.setName('xyf');\nconsole.log(person.getName()); //'origin'\n```\n　　这时候自执行函数中的this指向了全局对象Window，所以setName()函数并不能产生作用。\n\n\n## 嵌套回调函数\n```javascript\nvar person={\n\tname='origin',\n\tsetName:function(name){\n\t\t$('.temp').on('click',function(e){\n\t\t\tthis.name=name;\n\t\t});\n\t},\n\tgetName:function(){\n\t\treturn this.name;\n\t}\n}\nperson.setName('xyf');\nconsole.log(person.getName()); //'origin'\n```\n\n　　这里的this指向了$('.temp')这个对象。为了避免这些情况，我们先将this赋值给局部变量that，然后使用that。这时候that就指向了我们需要的对象。\n```javascript\nvar that=this;\n(function(name){\n\tthat.name=name;\n})(name);\n```\n\n## 特别声明\n　　如果将一个对象中的函数赋值给一个变量，再通过该变量调用这个函数，此时函数中的this指向Window对象，即使这个操作在回调函数中。\n```javascript\nvar person={\n\tname:\"person\",\n\tsetName:function(name){\n\t\tthis.name=name\n\t},\n\tgetName:function(){\n\t\treturn this.name;\n\t}\n}\nvar temp={\n\tname:\"temp\",\n\ttempFun:function(){\n\t\t$('.temp').on('click',function(){\n\t\t\tvar fun=person.getName;\n\t\t\tfun(); //''\n\t\t})\n\t}\n}\ntemp.tempFun();\n```\n\n# 使用apply和call函数改变this指向\n　　这两个函数都能够手动指定被调用函数内部this指向哪个对象。\n\n```javascript\nfunction person(name){\n\tthis.name=\"\";\n\tthis.setName=function(name){\n\t\tthis.name=name;\n\t}\n}\n\nvar p1=new person('p1');\nvar p2=new person('p2');\np1.setName('p1');\np2.setName('p2');\n\n//p1.setName.apply(p2,['c']);\np1.setName.call(p2,'c');\nconsole.log(p2.name); //'c'\n```\n　　当对象p1使用apply函数后，p1对象中的this就指向了对象p2，此时对象p1的setName函数的操作就作用在了p2对象上。\n\n\n\n\n\n\n","slug":"Explain-Js-This","published":1,"updated":"2016-10-09T01:08:09.223Z","layout":"post","link":"","_id":"ciu99fu45000ar8fi1pk38h64","content":"<p>　　this在js中是一个常见的变量，在不同的函数中this指代了不同的变量。刚开始我很困惑，怎么在这里是这个意思，到了相似的函数中却又改变了意思，让我很摸不着头脑。所以整理一下this的用法<br><a id=\"more\"></a></p>\n<h1 id=\"全局作用域中的this\"><a href=\"#全局作用域中的this\" class=\"headerlink\" title=\"全局作用域中的this\"></a>全局作用域中的this</h1><p>　　在全局作用域中，this指向了Window对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">this</span>.name=<span class=\"string\">'xyf'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</div></pre></td></tr></table></figure>\n<p>　　在上面我们把name挂载到了全局作用域Window下面，其实我们在用var声明变量的时候也是把变量挂载到Window下面。所以上面的操作等价于下面的操作<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> name=<span class=\"string\">'xyf'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</div></pre></td></tr></table></figure></p>\n<h1 id=\"函数中的this\"><a href=\"#函数中的this\" class=\"headerlink\" title=\"函数中的this\"></a>函数中的this</h1><p>　　在js中函数分为普通的函数和构造函数，主要的区别就是函数的调用形式。普通函数能够直接调用，而构造函数是不能调用，需要用new实例化。</p>\n<h2 id=\"普通函数中的this\"><a href=\"#普通函数中的this\" class=\"headerlink\" title=\"普通函数中的this\"></a>普通函数中的this</h2><p>　　普通函数的中this指向了Window对象<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.name=name;</div><div class=\"line\">&#125;</div><div class=\"line\">show(<span class=\"string\">'xyf'</span>);</div></pre></td></tr></table></figure></p>\n<p>　　这时候函数show作为一个普通函数调用，虽然看起来像构造函数，但是内部的this却指向了Window对象，如果你在控制台打印Window对象，它下面挂载了name属性</p>\n<h2 id=\"构造函数中的this\"><a href=\"#构造函数中的this\" class=\"headerlink\" title=\"构造函数中的this\"></a>构造函数中的this</h2><p>　　构造函数中的this则指向了它所实例化的对象<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.name=name;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> myshow=<span class=\"keyword\">new</span> show(<span class=\"string\">'xyf'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(myshow.name);  <span class=\"comment\">//'xyf'</span></div></pre></td></tr></table></figure></p>\n<p>　　在这里如果你直接调用show(‘xyf’)跟普通函数没有区别，通过new实例化一个myshow对象，这时候this就指向了这个实例化出来的对象</p>\n<h1 id=\"对象中的this\"><a href=\"#对象中的this\" class=\"headerlink\" title=\"对象中的this\"></a>对象中的this</h1><p>　　对象中的this指向了当前对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person=&#123;</div><div class=\"line\">\tname=<span class=\"string\">'origin'</span>,</div><div class=\"line\">\tsetName:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.name=name</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\tgetName:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">person.setName(<span class=\"string\">'xyf'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(person.getName()); <span class=\"comment\">//'xyf'</span></div></pre></td></tr></table></figure>\n<p>　　但是如果对象的函数中嵌套了其他函数，this的指向就被改变了。</p>\n<h2 id=\"嵌套自执行函数\"><a href=\"#嵌套自执行函数\" class=\"headerlink\" title=\"嵌套自执行函数\"></a>嵌套自执行函数</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person=&#123;</div><div class=\"line\">\tname=<span class=\"string\">'origin'</span>,</div><div class=\"line\">\tsetName:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">\t\t(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.name=name;</div><div class=\"line\">\t\t&#125;)(name);</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\tgetName:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">person.setName(<span class=\"string\">'xyf'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(person.getName()); <span class=\"comment\">//'origin'</span></div></pre></td></tr></table></figure>\n<p>　　这时候自执行函数中的this指向了全局对象Window，所以setName()函数并不能产生作用。</p>\n<h2 id=\"嵌套回调函数\"><a href=\"#嵌套回调函数\" class=\"headerlink\" title=\"嵌套回调函数\"></a>嵌套回调函数</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person=&#123;</div><div class=\"line\">\tname=<span class=\"string\">'origin'</span>,</div><div class=\"line\">\tsetName:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">\t\t$(<span class=\"string\">'.temp'</span>).on(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.name=name;</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\tgetName:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">person.setName(<span class=\"string\">'xyf'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(person.getName()); <span class=\"comment\">//'origin'</span></div></pre></td></tr></table></figure>\n<p>　　这里的this指向了$(‘.temp’)这个对象。为了避免这些情况，我们先将this赋值给局部变量that，然后使用that。这时候that就指向了我们需要的对象。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> that=<span class=\"keyword\">this</span>;</div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">\tthat.name=name;</div><div class=\"line\">&#125;)(name);</div></pre></td></tr></table></figure></p>\n<h2 id=\"特别声明\"><a href=\"#特别声明\" class=\"headerlink\" title=\"特别声明\"></a>特别声明</h2><p>　　如果将一个对象中的函数赋值给一个变量，再通过该变量调用这个函数，此时函数中的this指向Window对象，即使这个操作在回调函数中。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person=&#123;</div><div class=\"line\">\tname:<span class=\"string\">\"person\"</span>,</div><div class=\"line\">\tsetName:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.name=name</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\tgetName:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> temp=&#123;</div><div class=\"line\">\tname:<span class=\"string\">\"temp\"</span>,</div><div class=\"line\">\ttempFun:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t$(<span class=\"string\">'.temp'</span>).on(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> fun=person.getName;</div><div class=\"line\">\t\t\tfun(); <span class=\"comment\">//''</span></div><div class=\"line\">\t\t&#125;)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">temp.tempFun();</div></pre></td></tr></table></figure></p>\n<h1 id=\"使用apply和call函数改变this指向\"><a href=\"#使用apply和call函数改变this指向\" class=\"headerlink\" title=\"使用apply和call函数改变this指向\"></a>使用apply和call函数改变this指向</h1><p>　　这两个函数都能够手动指定被调用函数内部this指向哪个对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">person</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.name=<span class=\"string\">\"\"</span>;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.setName=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.name=name;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> p1=<span class=\"keyword\">new</span> person(<span class=\"string\">'p1'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> p2=<span class=\"keyword\">new</span> person(<span class=\"string\">'p2'</span>);</div><div class=\"line\">p1.setName(<span class=\"string\">'p1'</span>);</div><div class=\"line\">p2.setName(<span class=\"string\">'p2'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//p1.setName.apply(p2,['c']);</span></div><div class=\"line\">p1.setName.call(p2,<span class=\"string\">'c'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(p2.name); <span class=\"comment\">//'c'</span></div></pre></td></tr></table></figure>\n<p>　　当对象p1使用apply函数后，p1对象中的this就指向了对象p2，此时对象p1的setName函数的操作就作用在了p2对象上。</p>\n","excerpt":"<p>　　this在js中是一个常见的变量，在不同的函数中this指代了不同的变量。刚开始我很困惑，怎么在这里是这个意思，到了相似的函数中却又改变了意思，让我很摸不着头脑。所以整理一下this的用法<br>","more":"</p>\n<h1 id=\"全局作用域中的this\"><a href=\"#全局作用域中的this\" class=\"headerlink\" title=\"全局作用域中的this\"></a>全局作用域中的this</h1><p>　　在全局作用域中，this指向了Window对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">this</span>.name=<span class=\"string\">'xyf'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</div></pre></td></tr></table></figure>\n<p>　　在上面我们把name挂载到了全局作用域Window下面，其实我们在用var声明变量的时候也是把变量挂载到Window下面。所以上面的操作等价于下面的操作<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> name=<span class=\"string\">'xyf'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</div></pre></td></tr></table></figure></p>\n<h1 id=\"函数中的this\"><a href=\"#函数中的this\" class=\"headerlink\" title=\"函数中的this\"></a>函数中的this</h1><p>　　在js中函数分为普通的函数和构造函数，主要的区别就是函数的调用形式。普通函数能够直接调用，而构造函数是不能调用，需要用new实例化。</p>\n<h2 id=\"普通函数中的this\"><a href=\"#普通函数中的this\" class=\"headerlink\" title=\"普通函数中的this\"></a>普通函数中的this</h2><p>　　普通函数的中this指向了Window对象<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.name=name;</div><div class=\"line\">&#125;</div><div class=\"line\">show(<span class=\"string\">'xyf'</span>);</div></pre></td></tr></table></figure></p>\n<p>　　这时候函数show作为一个普通函数调用，虽然看起来像构造函数，但是内部的this却指向了Window对象，如果你在控制台打印Window对象，它下面挂载了name属性</p>\n<h2 id=\"构造函数中的this\"><a href=\"#构造函数中的this\" class=\"headerlink\" title=\"构造函数中的this\"></a>构造函数中的this</h2><p>　　构造函数中的this则指向了它所实例化的对象<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.name=name;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> myshow=<span class=\"keyword\">new</span> show(<span class=\"string\">'xyf'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(myshow.name);  <span class=\"comment\">//'xyf'</span></div></pre></td></tr></table></figure></p>\n<p>　　在这里如果你直接调用show(‘xyf’)跟普通函数没有区别，通过new实例化一个myshow对象，这时候this就指向了这个实例化出来的对象</p>\n<h1 id=\"对象中的this\"><a href=\"#对象中的this\" class=\"headerlink\" title=\"对象中的this\"></a>对象中的this</h1><p>　　对象中的this指向了当前对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person=&#123;</div><div class=\"line\">\tname=<span class=\"string\">'origin'</span>,</div><div class=\"line\">\tsetName:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.name=name</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\tgetName:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">person.setName(<span class=\"string\">'xyf'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(person.getName()); <span class=\"comment\">//'xyf'</span></div></pre></td></tr></table></figure>\n<p>　　但是如果对象的函数中嵌套了其他函数，this的指向就被改变了。</p>\n<h2 id=\"嵌套自执行函数\"><a href=\"#嵌套自执行函数\" class=\"headerlink\" title=\"嵌套自执行函数\"></a>嵌套自执行函数</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person=&#123;</div><div class=\"line\">\tname=<span class=\"string\">'origin'</span>,</div><div class=\"line\">\tsetName:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">\t\t(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.name=name;</div><div class=\"line\">\t\t&#125;)(name);</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\tgetName:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">person.setName(<span class=\"string\">'xyf'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(person.getName()); <span class=\"comment\">//'origin'</span></div></pre></td></tr></table></figure>\n<p>　　这时候自执行函数中的this指向了全局对象Window，所以setName()函数并不能产生作用。</p>\n<h2 id=\"嵌套回调函数\"><a href=\"#嵌套回调函数\" class=\"headerlink\" title=\"嵌套回调函数\"></a>嵌套回调函数</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person=&#123;</div><div class=\"line\">\tname=<span class=\"string\">'origin'</span>,</div><div class=\"line\">\tsetName:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">\t\t$(<span class=\"string\">'.temp'</span>).on(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.name=name;</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\tgetName:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">person.setName(<span class=\"string\">'xyf'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(person.getName()); <span class=\"comment\">//'origin'</span></div></pre></td></tr></table></figure>\n<p>　　这里的this指向了$(‘.temp’)这个对象。为了避免这些情况，我们先将this赋值给局部变量that，然后使用that。这时候that就指向了我们需要的对象。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> that=<span class=\"keyword\">this</span>;</div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">\tthat.name=name;</div><div class=\"line\">&#125;)(name);</div></pre></td></tr></table></figure></p>\n<h2 id=\"特别声明\"><a href=\"#特别声明\" class=\"headerlink\" title=\"特别声明\"></a>特别声明</h2><p>　　如果将一个对象中的函数赋值给一个变量，再通过该变量调用这个函数，此时函数中的this指向Window对象，即使这个操作在回调函数中。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person=&#123;</div><div class=\"line\">\tname:<span class=\"string\">\"person\"</span>,</div><div class=\"line\">\tsetName:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.name=name</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\tgetName:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> temp=&#123;</div><div class=\"line\">\tname:<span class=\"string\">\"temp\"</span>,</div><div class=\"line\">\ttempFun:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t$(<span class=\"string\">'.temp'</span>).on(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> fun=person.getName;</div><div class=\"line\">\t\t\tfun(); <span class=\"comment\">//''</span></div><div class=\"line\">\t\t&#125;)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">temp.tempFun();</div></pre></td></tr></table></figure></p>\n<h1 id=\"使用apply和call函数改变this指向\"><a href=\"#使用apply和call函数改变this指向\" class=\"headerlink\" title=\"使用apply和call函数改变this指向\"></a>使用apply和call函数改变this指向</h1><p>　　这两个函数都能够手动指定被调用函数内部this指向哪个对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">person</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.name=<span class=\"string\">\"\"</span>;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.setName=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.name=name;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> p1=<span class=\"keyword\">new</span> person(<span class=\"string\">'p1'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> p2=<span class=\"keyword\">new</span> person(<span class=\"string\">'p2'</span>);</div><div class=\"line\">p1.setName(<span class=\"string\">'p1'</span>);</div><div class=\"line\">p2.setName(<span class=\"string\">'p2'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//p1.setName.apply(p2,['c']);</span></div><div class=\"line\">p1.setName.call(p2,<span class=\"string\">'c'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(p2.name); <span class=\"comment\">//'c'</span></div></pre></td></tr></table></figure>\n<p>　　当对象p1使用apply函数后，p1对象中的this就指向了对象p2，此时对象p1的setName函数的操作就作用在了p2对象上。</p>"},{"title":"Git命令学习（下）","date":"2016-09-12T07:54:00.000Z","description":null,"toc":true,"author":"Corner","comments":1,"original":null,"photos":[],"_content":"　　git是一个开源的分布式版本控制系统，可以很高效的处理不同规模的项目的版本管理。git的命令比较多，在这篇文章中主要介绍了各种git命令的。\n<!-- more -->\n\t占位\n\n\n","source":"_posts/Git-Command-End.md","raw":"title: Git命令学习（下）\ndate: 2016-09-12 15:54:00\ndescription: \ncategories:\n- 编程\ntags:\n- git\ntoc: true\nauthor: Corner\ncomments:\noriginal:\npermalink: \nphotos:\n---\n　　git是一个开源的分布式版本控制系统，可以很高效的处理不同规模的项目的版本管理。git的命令比较多，在这篇文章中主要介绍了各种git命令的。\n<!-- more -->\n\t占位\n\n\n","slug":"Git-Command-End","published":1,"updated":"2016-10-09T01:08:09.223Z","layout":"post","link":"","_id":"ciu99fu48000dr8fiux8rks2u","content":"<p>　　git是一个开源的分布式版本控制系统，可以很高效的处理不同规模的项目的版本管理。git的命令比较多，在这篇文章中主要介绍了各种git命令的。<br><a id=\"more\"></a><br>    占位</p>\n","excerpt":"<p>　　git是一个开源的分布式版本控制系统，可以很高效的处理不同规模的项目的版本管理。git的命令比较多，在这篇文章中主要介绍了各种git命令的。<br>","more":"<br>    占位</p>"},{"title":"釜山行：一段旅途折射出世间百态","date":"2016-09-23T15:41:01.000Z","description":null,"toc":null,"author":"Corner","comments":1,"original":null,"photos":["/images/Film-TrainToBusan/stage.jpg"],"_content":"　　最近电影《釜山行》在各大荧幕热映，引起了观影群众的广泛热议。我身边的好多朋友看完了反响都还挺不错的，豆瓣也是给出了评分8.2的高分。今天在A站正好看到《釜山行》有资源，于是乎忍不住把它看完了。不得不说，韩国人拍的电影还是很不错的，给我的感触挺大的，想把自己的一些看法写下来。\n<!-- more -->\n　　这部电影在两个小时里其实讲了挺多东西的，亲情、爱情、友情和人性善良还有丑恶。笔者觉得一部好的电影不仅仅在特效和演员方面做好，所要刻画的人物才是整个电影的灵魂所在。那么怎么样才能刻画好电影中的人物形象呢，就是通过人性的善恶来刻画，折射出一类人，折射出社会的通病，这样的电影才能算是成功的电影。\n　　这部电影一共刻画了这么几类人物，一个是主人公，身份是一位父亲，职业是证券基金经纪人；一个是秀安，跟随父亲一起去釜山看妈妈；一个是体格健壮的大叔，身份是一位丈夫，孩子即将出世；一个是快要临盆的孕妇，跟随丈夫一起去釜山；还有是高中生棒球队学生，和同学们去釜山比赛；还有是穿西装的中年大叔，职业是巴士公司常务，属于中产阶级；最后是中年大妈们，是一对姐妹花。\n![stage](/images/Film-TrainToBusan/stage.jpg)\n\n## 1.一个不被理解的父亲\n\n　　首先是我们的主人公，作为一名证券基金经纪人，他也是一位成功人士，但是由于工作繁忙，他经常不在家陪孩子，和孩子产生了很深的隔阂。在孩子的强烈要求下，才放下工作，进行了这趟釜山行。上车后，秀安去洗手间遇到了体格健壮的大叔，大叔说主人公是“吸血鬼”，秀安非但没有为父亲辩护，反而还赞同大叔的观点。一开始主人公也是比较自私自利的，在大叔面临困难的时候他居然不是救人而是关门。在他得知前面有危险时，他也并没有及时地告诉其他人，而是各自管各自的带着女儿走了。\n\n　　后来在遇到危险时，还是大叔和孕妇的帮助下，秀安才被救。他也被大叔和孕妇慢慢的感化，最后牺牲了自己，让秀安活了下来，在生命的最后还是惦记的女儿小时候的样子。看到最后这一幕，笔者也不禁为之所感动。主人公所代表的是一个不为女儿所理解的好父亲的形象，虽然他自身也有很多缺点，但是他还是会守护整个家庭，都在默默的为整个家庭所付出。\n![protagonist](/images/Film-TrainToBusan/protagonist.jpg)\n\n## 2.一个内心热情的健壮大叔\n\n　　其次是体格健壮的大叔，一开始，外表看起来不太友善，但是对已怀孕的妻子确实十分的呵护，妻子对他发火的时候他也只是脸上堆满笑容。在整个电影里一直在救人，十分的有正义感。他利用自己健壮的优势，打退僵尸大军，不断地保护自己的妻子，保护身边的人。他也心胸开阔，虽然之前主人公关门不救他，但是后来不计前嫌，在主人公危难的时候还是救了他一把，两人也并肩作战。在最危机的时刻，他主动牺牲了自己，让主人公带自己的妻子先行逃离，自己拖住了僵尸队伍，还不忘记给自己未出世的女儿起名字。他是一个好丈夫，好父亲，好公民的角色。在我们生活中，总能看到这样一群大叔的身影，对生活充满热情，在我们迷路时，他会热情的为我们指路，在有人需要帮助的时候，他总会第一时间站出来。\n![strong](/images/Film-TrainToBusan/strong.jpg)\n\n## 3.一群涉世未深的高中生\n　　然后是参加比赛的棒球队学生，他们刚开始在车上打打闹闹，玩的很开心，天真无邪。但是灾难发生的太突然了，除了女高中生和队长，其他的同学都被感染了。面对昔日的好友变成僵尸来攻击他们，队长拿着棒球拍愣住了，迟迟不敢动手，他内心肯定是不敢去相信的，自己的好朋友怎么会变成这样。到最后面对自己心爱的女生变成了僵尸，队长也只有一个劲的痛苦，却无可奈何，只能跟着爱情一起“陪葬”。学生是一群充满活力充满热情的群体，他们敢爱敢恨，能为爱情所牺牲，但是他们涉世未深，在困难面前容易不知所措，需要有人指引他们前进。\n![student](/images/Film-TrainToBusan/student.jpg)\n\n## 4.一对中年姐妹花大妈\n　　还有就是一对中年大妈，一开始，姐姐给妹妹剥鸡蛋吃，对妹妹十分的“溺爱”，但是妹妹一脸嫌弃。他们的衣着也有着鲜明的对比，姐姐素颜素衣，头上带着些许的白发，看得出生活比较艰辛，历经岁月的沧桑。后来从妹妹的评价中得知，姐姐有一个儿子，把所有的都给了儿子，这应该是所有的母亲都会做的吧。妹妹打扮时髦，一身的花衣服，烫着头跟于谦老师一样，手上还涂着靓丽的指甲油。一开始妹妹跟广大的“吃瓜群众”一样冷漠，女学生说跟他们在一起比跟僵尸在一起还可怕。但是后来见到了已经变成了僵尸的姐姐，感叹她辛勤劳动了一辈子都是虚妄的。看到自己的亲人受到了社会不公平的待遇，她内心反人类反社会的性格开始表现，不顾他人的劳动成果，毅然地放僵尸大军进来，拉所有人跟她一起陪葬。\n![sister](/images/Film-TrainToBusan/sister.jpg)\n\n## 5.一个只想自己活命的常务大叔\n　　最后是里面穿西装的常务大叔，一开始对秀安说，如果不认真学习也会变成流浪汉，天真无邪的秀安却引用妈妈的话，说他是坏人，感觉这是导演的铺垫？后来到了前面的车站，他主动跟列车长说要抛下其他乘客跑路。列车长还是挺热心肠的，为了更多乘客着想，拒绝了他，不过他的这种热心肠注定是要被常务大叔所利用的。后来主人公一行想要跟“吃瓜群众”汇合，但是常务大叔这个时候却开始热心肠起来了，口口声声说为了所有的乘客的安全着想，不能让他们把危险带过来，其实内心从头到尾都只是为了自己。他还欺骗“吃瓜群众”说主人公已经被感染，煽动其他乘客将主人公一行赶到了其他车厢去。后来当他和乘务长准备一起逃离时，骗乘务长先出去引开了僵尸，自己独自逃离；在被僵尸追上时，将女高中生推了下去，自己又跑了；在热心的列车长救他后，他却没有帮列车长，而是恩将仇报将列车长拉了下去，自己逃生。\n\n　　到了最后，交代了自己还有亲人在等他，他想要活着回去。很多人都很痛恨常务大叔，害死了这么多人，但是在灾难面前，有多少人会为他人考虑呢。每个人都想要在灾难面前活下去，每个人都有活下去的权利，我们没有权利决定他人的生死。\n![bad](/images/Film-TrainToBusan/bad.jpg)\n\n　　还记得有一个网友在豆瓣上的评论是这样的：比丧尸更可怕的是人性。确实，只有在危险的情况下才能展示一个人最真实的一面，人性才能够彻底的暴露出来，这才是最真实的。有的人可能会善良的帮助他人，有的人可能就自己只顾着自己逃生，每个人都有自己的选择，孰是孰非我觉得应该更加理性的看到。有的人总喜欢站在道德的至高点，对他人的言行指指点点，但是自己遇到了一样的情况却并没有做的比他人好，这样的人更加的可怕。\n\n　　最后，国庆马上要结束了，希望坐高铁回来的童鞋们旅途愉快;-)\n![end](/images/Film-TrainToBusan/end.jpg)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Film-TrainToBusan.md","raw":"title: 釜山行：一段旅途折射出世间百态\ndate: 2016-09-23 23:41:01\ndescription:\ncategories:\n- 影评\ntags:\n- 推荐\n- 电影\ntoc:\nauthor: Corner\ncomments:\noriginal:\npermalink:\nphotos: /images/Film-TrainToBusan/stage.jpg\n---\n　　最近电影《釜山行》在各大荧幕热映，引起了观影群众的广泛热议。我身边的好多朋友看完了反响都还挺不错的，豆瓣也是给出了评分8.2的高分。今天在A站正好看到《釜山行》有资源，于是乎忍不住把它看完了。不得不说，韩国人拍的电影还是很不错的，给我的感触挺大的，想把自己的一些看法写下来。\n<!-- more -->\n　　这部电影在两个小时里其实讲了挺多东西的，亲情、爱情、友情和人性善良还有丑恶。笔者觉得一部好的电影不仅仅在特效和演员方面做好，所要刻画的人物才是整个电影的灵魂所在。那么怎么样才能刻画好电影中的人物形象呢，就是通过人性的善恶来刻画，折射出一类人，折射出社会的通病，这样的电影才能算是成功的电影。\n　　这部电影一共刻画了这么几类人物，一个是主人公，身份是一位父亲，职业是证券基金经纪人；一个是秀安，跟随父亲一起去釜山看妈妈；一个是体格健壮的大叔，身份是一位丈夫，孩子即将出世；一个是快要临盆的孕妇，跟随丈夫一起去釜山；还有是高中生棒球队学生，和同学们去釜山比赛；还有是穿西装的中年大叔，职业是巴士公司常务，属于中产阶级；最后是中年大妈们，是一对姐妹花。\n![stage](/images/Film-TrainToBusan/stage.jpg)\n\n## 1.一个不被理解的父亲\n\n　　首先是我们的主人公，作为一名证券基金经纪人，他也是一位成功人士，但是由于工作繁忙，他经常不在家陪孩子，和孩子产生了很深的隔阂。在孩子的强烈要求下，才放下工作，进行了这趟釜山行。上车后，秀安去洗手间遇到了体格健壮的大叔，大叔说主人公是“吸血鬼”，秀安非但没有为父亲辩护，反而还赞同大叔的观点。一开始主人公也是比较自私自利的，在大叔面临困难的时候他居然不是救人而是关门。在他得知前面有危险时，他也并没有及时地告诉其他人，而是各自管各自的带着女儿走了。\n\n　　后来在遇到危险时，还是大叔和孕妇的帮助下，秀安才被救。他也被大叔和孕妇慢慢的感化，最后牺牲了自己，让秀安活了下来，在生命的最后还是惦记的女儿小时候的样子。看到最后这一幕，笔者也不禁为之所感动。主人公所代表的是一个不为女儿所理解的好父亲的形象，虽然他自身也有很多缺点，但是他还是会守护整个家庭，都在默默的为整个家庭所付出。\n![protagonist](/images/Film-TrainToBusan/protagonist.jpg)\n\n## 2.一个内心热情的健壮大叔\n\n　　其次是体格健壮的大叔，一开始，外表看起来不太友善，但是对已怀孕的妻子确实十分的呵护，妻子对他发火的时候他也只是脸上堆满笑容。在整个电影里一直在救人，十分的有正义感。他利用自己健壮的优势，打退僵尸大军，不断地保护自己的妻子，保护身边的人。他也心胸开阔，虽然之前主人公关门不救他，但是后来不计前嫌，在主人公危难的时候还是救了他一把，两人也并肩作战。在最危机的时刻，他主动牺牲了自己，让主人公带自己的妻子先行逃离，自己拖住了僵尸队伍，还不忘记给自己未出世的女儿起名字。他是一个好丈夫，好父亲，好公民的角色。在我们生活中，总能看到这样一群大叔的身影，对生活充满热情，在我们迷路时，他会热情的为我们指路，在有人需要帮助的时候，他总会第一时间站出来。\n![strong](/images/Film-TrainToBusan/strong.jpg)\n\n## 3.一群涉世未深的高中生\n　　然后是参加比赛的棒球队学生，他们刚开始在车上打打闹闹，玩的很开心，天真无邪。但是灾难发生的太突然了，除了女高中生和队长，其他的同学都被感染了。面对昔日的好友变成僵尸来攻击他们，队长拿着棒球拍愣住了，迟迟不敢动手，他内心肯定是不敢去相信的，自己的好朋友怎么会变成这样。到最后面对自己心爱的女生变成了僵尸，队长也只有一个劲的痛苦，却无可奈何，只能跟着爱情一起“陪葬”。学生是一群充满活力充满热情的群体，他们敢爱敢恨，能为爱情所牺牲，但是他们涉世未深，在困难面前容易不知所措，需要有人指引他们前进。\n![student](/images/Film-TrainToBusan/student.jpg)\n\n## 4.一对中年姐妹花大妈\n　　还有就是一对中年大妈，一开始，姐姐给妹妹剥鸡蛋吃，对妹妹十分的“溺爱”，但是妹妹一脸嫌弃。他们的衣着也有着鲜明的对比，姐姐素颜素衣，头上带着些许的白发，看得出生活比较艰辛，历经岁月的沧桑。后来从妹妹的评价中得知，姐姐有一个儿子，把所有的都给了儿子，这应该是所有的母亲都会做的吧。妹妹打扮时髦，一身的花衣服，烫着头跟于谦老师一样，手上还涂着靓丽的指甲油。一开始妹妹跟广大的“吃瓜群众”一样冷漠，女学生说跟他们在一起比跟僵尸在一起还可怕。但是后来见到了已经变成了僵尸的姐姐，感叹她辛勤劳动了一辈子都是虚妄的。看到自己的亲人受到了社会不公平的待遇，她内心反人类反社会的性格开始表现，不顾他人的劳动成果，毅然地放僵尸大军进来，拉所有人跟她一起陪葬。\n![sister](/images/Film-TrainToBusan/sister.jpg)\n\n## 5.一个只想自己活命的常务大叔\n　　最后是里面穿西装的常务大叔，一开始对秀安说，如果不认真学习也会变成流浪汉，天真无邪的秀安却引用妈妈的话，说他是坏人，感觉这是导演的铺垫？后来到了前面的车站，他主动跟列车长说要抛下其他乘客跑路。列车长还是挺热心肠的，为了更多乘客着想，拒绝了他，不过他的这种热心肠注定是要被常务大叔所利用的。后来主人公一行想要跟“吃瓜群众”汇合，但是常务大叔这个时候却开始热心肠起来了，口口声声说为了所有的乘客的安全着想，不能让他们把危险带过来，其实内心从头到尾都只是为了自己。他还欺骗“吃瓜群众”说主人公已经被感染，煽动其他乘客将主人公一行赶到了其他车厢去。后来当他和乘务长准备一起逃离时，骗乘务长先出去引开了僵尸，自己独自逃离；在被僵尸追上时，将女高中生推了下去，自己又跑了；在热心的列车长救他后，他却没有帮列车长，而是恩将仇报将列车长拉了下去，自己逃生。\n\n　　到了最后，交代了自己还有亲人在等他，他想要活着回去。很多人都很痛恨常务大叔，害死了这么多人，但是在灾难面前，有多少人会为他人考虑呢。每个人都想要在灾难面前活下去，每个人都有活下去的权利，我们没有权利决定他人的生死。\n![bad](/images/Film-TrainToBusan/bad.jpg)\n\n　　还记得有一个网友在豆瓣上的评论是这样的：比丧尸更可怕的是人性。确实，只有在危险的情况下才能展示一个人最真实的一面，人性才能够彻底的暴露出来，这才是最真实的。有的人可能会善良的帮助他人，有的人可能就自己只顾着自己逃生，每个人都有自己的选择，孰是孰非我觉得应该更加理性的看到。有的人总喜欢站在道德的至高点，对他人的言行指指点点，但是自己遇到了一样的情况却并没有做的比他人好，这样的人更加的可怕。\n\n　　最后，国庆马上要结束了，希望坐高铁回来的童鞋们旅途愉快;-)\n![end](/images/Film-TrainToBusan/end.jpg)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Film-TrainToBusan","published":1,"updated":"2016-10-09T01:08:09.223Z","layout":"post","link":"","_id":"ciu99fu4b000fr8fidsqmuag5","content":"<p>　　最近电影《釜山行》在各大荧幕热映，引起了观影群众的广泛热议。我身边的好多朋友看完了反响都还挺不错的，豆瓣也是给出了评分8.2的高分。今天在A站正好看到《釜山行》有资源，于是乎忍不住把它看完了。不得不说，韩国人拍的电影还是很不错的，给我的感触挺大的，想把自己的一些看法写下来。<br><a id=\"more\"></a><br>　　这部电影在两个小时里其实讲了挺多东西的，亲情、爱情、友情和人性善良还有丑恶。笔者觉得一部好的电影不仅仅在特效和演员方面做好，所要刻画的人物才是整个电影的灵魂所在。那么怎么样才能刻画好电影中的人物形象呢，就是通过人性的善恶来刻画，折射出一类人，折射出社会的通病，这样的电影才能算是成功的电影。<br>　　这部电影一共刻画了这么几类人物，一个是主人公，身份是一位父亲，职业是证券基金经纪人；一个是秀安，跟随父亲一起去釜山看妈妈；一个是体格健壮的大叔，身份是一位丈夫，孩子即将出世；一个是快要临盆的孕妇，跟随丈夫一起去釜山；还有是高中生棒球队学生，和同学们去釜山比赛；还有是穿西装的中年大叔，职业是巴士公司常务，属于中产阶级；最后是中年大妈们，是一对姐妹花。<br><img src=\"/images/Film-TrainToBusan/stage.jpg\" alt=\"stage\"></p>\n<h2 id=\"1-一个不被理解的父亲\"><a href=\"#1-一个不被理解的父亲\" class=\"headerlink\" title=\"1.一个不被理解的父亲\"></a>1.一个不被理解的父亲</h2><p>　　首先是我们的主人公，作为一名证券基金经纪人，他也是一位成功人士，但是由于工作繁忙，他经常不在家陪孩子，和孩子产生了很深的隔阂。在孩子的强烈要求下，才放下工作，进行了这趟釜山行。上车后，秀安去洗手间遇到了体格健壮的大叔，大叔说主人公是“吸血鬼”，秀安非但没有为父亲辩护，反而还赞同大叔的观点。一开始主人公也是比较自私自利的，在大叔面临困难的时候他居然不是救人而是关门。在他得知前面有危险时，他也并没有及时地告诉其他人，而是各自管各自的带着女儿走了。</p>\n<p>　　后来在遇到危险时，还是大叔和孕妇的帮助下，秀安才被救。他也被大叔和孕妇慢慢的感化，最后牺牲了自己，让秀安活了下来，在生命的最后还是惦记的女儿小时候的样子。看到最后这一幕，笔者也不禁为之所感动。主人公所代表的是一个不为女儿所理解的好父亲的形象，虽然他自身也有很多缺点，但是他还是会守护整个家庭，都在默默的为整个家庭所付出。<br><img src=\"/images/Film-TrainToBusan/protagonist.jpg\" alt=\"protagonist\"></p>\n<h2 id=\"2-一个内心热情的健壮大叔\"><a href=\"#2-一个内心热情的健壮大叔\" class=\"headerlink\" title=\"2.一个内心热情的健壮大叔\"></a>2.一个内心热情的健壮大叔</h2><p>　　其次是体格健壮的大叔，一开始，外表看起来不太友善，但是对已怀孕的妻子确实十分的呵护，妻子对他发火的时候他也只是脸上堆满笑容。在整个电影里一直在救人，十分的有正义感。他利用自己健壮的优势，打退僵尸大军，不断地保护自己的妻子，保护身边的人。他也心胸开阔，虽然之前主人公关门不救他，但是后来不计前嫌，在主人公危难的时候还是救了他一把，两人也并肩作战。在最危机的时刻，他主动牺牲了自己，让主人公带自己的妻子先行逃离，自己拖住了僵尸队伍，还不忘记给自己未出世的女儿起名字。他是一个好丈夫，好父亲，好公民的角色。在我们生活中，总能看到这样一群大叔的身影，对生活充满热情，在我们迷路时，他会热情的为我们指路，在有人需要帮助的时候，他总会第一时间站出来。<br><img src=\"/images/Film-TrainToBusan/strong.jpg\" alt=\"strong\"></p>\n<h2 id=\"3-一群涉世未深的高中生\"><a href=\"#3-一群涉世未深的高中生\" class=\"headerlink\" title=\"3.一群涉世未深的高中生\"></a>3.一群涉世未深的高中生</h2><p>　　然后是参加比赛的棒球队学生，他们刚开始在车上打打闹闹，玩的很开心，天真无邪。但是灾难发生的太突然了，除了女高中生和队长，其他的同学都被感染了。面对昔日的好友变成僵尸来攻击他们，队长拿着棒球拍愣住了，迟迟不敢动手，他内心肯定是不敢去相信的，自己的好朋友怎么会变成这样。到最后面对自己心爱的女生变成了僵尸，队长也只有一个劲的痛苦，却无可奈何，只能跟着爱情一起“陪葬”。学生是一群充满活力充满热情的群体，他们敢爱敢恨，能为爱情所牺牲，但是他们涉世未深，在困难面前容易不知所措，需要有人指引他们前进。<br><img src=\"/images/Film-TrainToBusan/student.jpg\" alt=\"student\"></p>\n<h2 id=\"4-一对中年姐妹花大妈\"><a href=\"#4-一对中年姐妹花大妈\" class=\"headerlink\" title=\"4.一对中年姐妹花大妈\"></a>4.一对中年姐妹花大妈</h2><p>　　还有就是一对中年大妈，一开始，姐姐给妹妹剥鸡蛋吃，对妹妹十分的“溺爱”，但是妹妹一脸嫌弃。他们的衣着也有着鲜明的对比，姐姐素颜素衣，头上带着些许的白发，看得出生活比较艰辛，历经岁月的沧桑。后来从妹妹的评价中得知，姐姐有一个儿子，把所有的都给了儿子，这应该是所有的母亲都会做的吧。妹妹打扮时髦，一身的花衣服，烫着头跟于谦老师一样，手上还涂着靓丽的指甲油。一开始妹妹跟广大的“吃瓜群众”一样冷漠，女学生说跟他们在一起比跟僵尸在一起还可怕。但是后来见到了已经变成了僵尸的姐姐，感叹她辛勤劳动了一辈子都是虚妄的。看到自己的亲人受到了社会不公平的待遇，她内心反人类反社会的性格开始表现，不顾他人的劳动成果，毅然地放僵尸大军进来，拉所有人跟她一起陪葬。<br><img src=\"/images/Film-TrainToBusan/sister.jpg\" alt=\"sister\"></p>\n<h2 id=\"5-一个只想自己活命的常务大叔\"><a href=\"#5-一个只想自己活命的常务大叔\" class=\"headerlink\" title=\"5.一个只想自己活命的常务大叔\"></a>5.一个只想自己活命的常务大叔</h2><p>　　最后是里面穿西装的常务大叔，一开始对秀安说，如果不认真学习也会变成流浪汉，天真无邪的秀安却引用妈妈的话，说他是坏人，感觉这是导演的铺垫？后来到了前面的车站，他主动跟列车长说要抛下其他乘客跑路。列车长还是挺热心肠的，为了更多乘客着想，拒绝了他，不过他的这种热心肠注定是要被常务大叔所利用的。后来主人公一行想要跟“吃瓜群众”汇合，但是常务大叔这个时候却开始热心肠起来了，口口声声说为了所有的乘客的安全着想，不能让他们把危险带过来，其实内心从头到尾都只是为了自己。他还欺骗“吃瓜群众”说主人公已经被感染，煽动其他乘客将主人公一行赶到了其他车厢去。后来当他和乘务长准备一起逃离时，骗乘务长先出去引开了僵尸，自己独自逃离；在被僵尸追上时，将女高中生推了下去，自己又跑了；在热心的列车长救他后，他却没有帮列车长，而是恩将仇报将列车长拉了下去，自己逃生。</p>\n<p>　　到了最后，交代了自己还有亲人在等他，他想要活着回去。很多人都很痛恨常务大叔，害死了这么多人，但是在灾难面前，有多少人会为他人考虑呢。每个人都想要在灾难面前活下去，每个人都有活下去的权利，我们没有权利决定他人的生死。<br><img src=\"/images/Film-TrainToBusan/bad.jpg\" alt=\"bad\"></p>\n<p>　　还记得有一个网友在豆瓣上的评论是这样的：比丧尸更可怕的是人性。确实，只有在危险的情况下才能展示一个人最真实的一面，人性才能够彻底的暴露出来，这才是最真实的。有的人可能会善良的帮助他人，有的人可能就自己只顾着自己逃生，每个人都有自己的选择，孰是孰非我觉得应该更加理性的看到。有的人总喜欢站在道德的至高点，对他人的言行指指点点，但是自己遇到了一样的情况却并没有做的比他人好，这样的人更加的可怕。</p>\n<p>　　最后，国庆马上要结束了，希望坐高铁回来的童鞋们旅途愉快;-)<br><img src=\"/images/Film-TrainToBusan/end.jpg\" alt=\"end\"></p>\n","excerpt":"<p>　　最近电影《釜山行》在各大荧幕热映，引起了观影群众的广泛热议。我身边的好多朋友看完了反响都还挺不错的，豆瓣也是给出了评分8.2的高分。今天在A站正好看到《釜山行》有资源，于是乎忍不住把它看完了。不得不说，韩国人拍的电影还是很不错的，给我的感触挺大的，想把自己的一些看法写下来。<br>","more":"<br>　　这部电影在两个小时里其实讲了挺多东西的，亲情、爱情、友情和人性善良还有丑恶。笔者觉得一部好的电影不仅仅在特效和演员方面做好，所要刻画的人物才是整个电影的灵魂所在。那么怎么样才能刻画好电影中的人物形象呢，就是通过人性的善恶来刻画，折射出一类人，折射出社会的通病，这样的电影才能算是成功的电影。<br>　　这部电影一共刻画了这么几类人物，一个是主人公，身份是一位父亲，职业是证券基金经纪人；一个是秀安，跟随父亲一起去釜山看妈妈；一个是体格健壮的大叔，身份是一位丈夫，孩子即将出世；一个是快要临盆的孕妇，跟随丈夫一起去釜山；还有是高中生棒球队学生，和同学们去釜山比赛；还有是穿西装的中年大叔，职业是巴士公司常务，属于中产阶级；最后是中年大妈们，是一对姐妹花。<br><img src=\"/images/Film-TrainToBusan/stage.jpg\" alt=\"stage\"></p>\n<h2 id=\"1-一个不被理解的父亲\"><a href=\"#1-一个不被理解的父亲\" class=\"headerlink\" title=\"1.一个不被理解的父亲\"></a>1.一个不被理解的父亲</h2><p>　　首先是我们的主人公，作为一名证券基金经纪人，他也是一位成功人士，但是由于工作繁忙，他经常不在家陪孩子，和孩子产生了很深的隔阂。在孩子的强烈要求下，才放下工作，进行了这趟釜山行。上车后，秀安去洗手间遇到了体格健壮的大叔，大叔说主人公是“吸血鬼”，秀安非但没有为父亲辩护，反而还赞同大叔的观点。一开始主人公也是比较自私自利的，在大叔面临困难的时候他居然不是救人而是关门。在他得知前面有危险时，他也并没有及时地告诉其他人，而是各自管各自的带着女儿走了。</p>\n<p>　　后来在遇到危险时，还是大叔和孕妇的帮助下，秀安才被救。他也被大叔和孕妇慢慢的感化，最后牺牲了自己，让秀安活了下来，在生命的最后还是惦记的女儿小时候的样子。看到最后这一幕，笔者也不禁为之所感动。主人公所代表的是一个不为女儿所理解的好父亲的形象，虽然他自身也有很多缺点，但是他还是会守护整个家庭，都在默默的为整个家庭所付出。<br><img src=\"/images/Film-TrainToBusan/protagonist.jpg\" alt=\"protagonist\"></p>\n<h2 id=\"2-一个内心热情的健壮大叔\"><a href=\"#2-一个内心热情的健壮大叔\" class=\"headerlink\" title=\"2.一个内心热情的健壮大叔\"></a>2.一个内心热情的健壮大叔</h2><p>　　其次是体格健壮的大叔，一开始，外表看起来不太友善，但是对已怀孕的妻子确实十分的呵护，妻子对他发火的时候他也只是脸上堆满笑容。在整个电影里一直在救人，十分的有正义感。他利用自己健壮的优势，打退僵尸大军，不断地保护自己的妻子，保护身边的人。他也心胸开阔，虽然之前主人公关门不救他，但是后来不计前嫌，在主人公危难的时候还是救了他一把，两人也并肩作战。在最危机的时刻，他主动牺牲了自己，让主人公带自己的妻子先行逃离，自己拖住了僵尸队伍，还不忘记给自己未出世的女儿起名字。他是一个好丈夫，好父亲，好公民的角色。在我们生活中，总能看到这样一群大叔的身影，对生活充满热情，在我们迷路时，他会热情的为我们指路，在有人需要帮助的时候，他总会第一时间站出来。<br><img src=\"/images/Film-TrainToBusan/strong.jpg\" alt=\"strong\"></p>\n<h2 id=\"3-一群涉世未深的高中生\"><a href=\"#3-一群涉世未深的高中生\" class=\"headerlink\" title=\"3.一群涉世未深的高中生\"></a>3.一群涉世未深的高中生</h2><p>　　然后是参加比赛的棒球队学生，他们刚开始在车上打打闹闹，玩的很开心，天真无邪。但是灾难发生的太突然了，除了女高中生和队长，其他的同学都被感染了。面对昔日的好友变成僵尸来攻击他们，队长拿着棒球拍愣住了，迟迟不敢动手，他内心肯定是不敢去相信的，自己的好朋友怎么会变成这样。到最后面对自己心爱的女生变成了僵尸，队长也只有一个劲的痛苦，却无可奈何，只能跟着爱情一起“陪葬”。学生是一群充满活力充满热情的群体，他们敢爱敢恨，能为爱情所牺牲，但是他们涉世未深，在困难面前容易不知所措，需要有人指引他们前进。<br><img src=\"/images/Film-TrainToBusan/student.jpg\" alt=\"student\"></p>\n<h2 id=\"4-一对中年姐妹花大妈\"><a href=\"#4-一对中年姐妹花大妈\" class=\"headerlink\" title=\"4.一对中年姐妹花大妈\"></a>4.一对中年姐妹花大妈</h2><p>　　还有就是一对中年大妈，一开始，姐姐给妹妹剥鸡蛋吃，对妹妹十分的“溺爱”，但是妹妹一脸嫌弃。他们的衣着也有着鲜明的对比，姐姐素颜素衣，头上带着些许的白发，看得出生活比较艰辛，历经岁月的沧桑。后来从妹妹的评价中得知，姐姐有一个儿子，把所有的都给了儿子，这应该是所有的母亲都会做的吧。妹妹打扮时髦，一身的花衣服，烫着头跟于谦老师一样，手上还涂着靓丽的指甲油。一开始妹妹跟广大的“吃瓜群众”一样冷漠，女学生说跟他们在一起比跟僵尸在一起还可怕。但是后来见到了已经变成了僵尸的姐姐，感叹她辛勤劳动了一辈子都是虚妄的。看到自己的亲人受到了社会不公平的待遇，她内心反人类反社会的性格开始表现，不顾他人的劳动成果，毅然地放僵尸大军进来，拉所有人跟她一起陪葬。<br><img src=\"/images/Film-TrainToBusan/sister.jpg\" alt=\"sister\"></p>\n<h2 id=\"5-一个只想自己活命的常务大叔\"><a href=\"#5-一个只想自己活命的常务大叔\" class=\"headerlink\" title=\"5.一个只想自己活命的常务大叔\"></a>5.一个只想自己活命的常务大叔</h2><p>　　最后是里面穿西装的常务大叔，一开始对秀安说，如果不认真学习也会变成流浪汉，天真无邪的秀安却引用妈妈的话，说他是坏人，感觉这是导演的铺垫？后来到了前面的车站，他主动跟列车长说要抛下其他乘客跑路。列车长还是挺热心肠的，为了更多乘客着想，拒绝了他，不过他的这种热心肠注定是要被常务大叔所利用的。后来主人公一行想要跟“吃瓜群众”汇合，但是常务大叔这个时候却开始热心肠起来了，口口声声说为了所有的乘客的安全着想，不能让他们把危险带过来，其实内心从头到尾都只是为了自己。他还欺骗“吃瓜群众”说主人公已经被感染，煽动其他乘客将主人公一行赶到了其他车厢去。后来当他和乘务长准备一起逃离时，骗乘务长先出去引开了僵尸，自己独自逃离；在被僵尸追上时，将女高中生推了下去，自己又跑了；在热心的列车长救他后，他却没有帮列车长，而是恩将仇报将列车长拉了下去，自己逃生。</p>\n<p>　　到了最后，交代了自己还有亲人在等他，他想要活着回去。很多人都很痛恨常务大叔，害死了这么多人，但是在灾难面前，有多少人会为他人考虑呢。每个人都想要在灾难面前活下去，每个人都有活下去的权利，我们没有权利决定他人的生死。<br><img src=\"/images/Film-TrainToBusan/bad.jpg\" alt=\"bad\"></p>\n<p>　　还记得有一个网友在豆瓣上的评论是这样的：比丧尸更可怕的是人性。确实，只有在危险的情况下才能展示一个人最真实的一面，人性才能够彻底的暴露出来，这才是最真实的。有的人可能会善良的帮助他人，有的人可能就自己只顾着自己逃生，每个人都有自己的选择，孰是孰非我觉得应该更加理性的看到。有的人总喜欢站在道德的至高点，对他人的言行指指点点，但是自己遇到了一样的情况却并没有做的比他人好，这样的人更加的可怕。</p>\n<p>　　最后，国庆马上要结束了，希望坐高铁回来的童鞋们旅途愉快;-)<br><img src=\"/images/Film-TrainToBusan/end.jpg\" alt=\"end\"></p>"},{"title":"Git命令学习（上）","date":"2016-09-11T01:48:00.000Z","description":null,"toc":true,"author":"Corner","comments":1,"original":null,"photos":[],"_content":"　　git是一个开源的分布式版本控制系统，可以很高效的处理不同规模的项目的版本管理。git的命令比较多，在这篇文章中主要介绍了各种git命令的基本操作。本文比较基础，适合入门。\n<!-- more -->\n\n\n## 1. 创建版本库\n\n### 创建目录\n\n```\nmkdir example\ncd example\n```\n\n### 将这个目录变成版本库\n```\ngit init\n```\n　　目录下多一个.git目录，用来跟踪管理版本库，你也可以把线上的项目克隆到本地，使用下面的命令\n\n```\ngit clone [url]\n```\n\n## 2.将文件添加到版本库\n\n### 追踪文件\n```\ngit add [filename]\n```\n或者一次性添加所有未追踪的文件\n```\ngit add .\n```\n### 提交到仓库\n```\ngit commit -m \"[you description]\"\n```\n\n## 3.查看当前仓库的状态\n\n```\ngit status\n```\n\n　　这个命令用来查看仓库的详细状态，添加-s查看简要的状态(s表示short)\n\n```\ngit status -s\n```\n\n　　简要状态下前面的符号代表的意思：\n\n* ?? 表示添加文件后而未追踪的文件\n* M 表示修改文件(Modify)\n* A 表示添加文件后追踪了该文件(Add)\n* D 表示删除文件(Delete)\n　　\n简要状态下颜色的不同也有区别。如果是红色，则表示该文件修改后没有追踪；是绿色则表示修改后追踪了改文件。\n\n## 4.对比文件差异\n\n　　git diff(difference)此命令比较的是工作目录中当前文件和暂存区域快照之间的差异,也就是修改之后还没有暂存起来的变化内容\n```\ngit diff\n```\n　　如果使用add命令追踪该文件后，diff命令失效。\n\n## 5.显示提交的日志\n```\ngit log\n```\n　　log命令用于显示从最近到以前的提交日志，commit后面显示的一长串字符数字是该次提交所对应的版本号，每次都不会重复的。log命令显示的信息比较多，可以加上 --pretty=oneline 参数\n```\ngit log --pretty=oneline\n```\n　　在下面的版本回退中需要用到提交日志的版本号，这时候就需要复制这个版本号。在windows下复制git窗口中的内容的快捷键是Ctrl+Insert，粘贴是Insert\n\n## 6.版本回退\n```\ngit reset --hard [LogId]\n```\n　　reset命令用于控制版本回退到之前提交时的状态。这边的LogId就是上一节中复制出来的版本号。\n\n## 7.撤销修改\n```\ngit checkout -- [filename]\n```\n　　checkout命令让你在工作区做的修改全部撤销，回到上一次commit时的状态。\n\n## 8.删除文件\n　　如果你在工作区删除了一个文件，那么status就会提醒你工作区和暂存区不一致。这时候你有两种选择，一个是git rm命令确认删除，\n```\ngit rm [filename]\n```\n　　这个命令相当于同时进行了删除命令和追踪文件命令，其等价命令如下：\n```\nrm [filename]\ngit add [filename]\n```\n　　另一个是通过checkout命令找回删除的文件\n```\ngit checkout -- [filename]\n```\n","source":"_posts/Git-Command-Start.md","raw":"title: Git命令学习（上）\ndate: 2016-09-11 09:48:00\ndescription: \ncategories:\n- 编程\ntags:\n- git\ntoc: true\nauthor: Corner\ncomments:\noriginal:\npermalink: \nphotos:\n---\n　　git是一个开源的分布式版本控制系统，可以很高效的处理不同规模的项目的版本管理。git的命令比较多，在这篇文章中主要介绍了各种git命令的基本操作。本文比较基础，适合入门。\n<!-- more -->\n\n\n## 1. 创建版本库\n\n### 创建目录\n\n```\nmkdir example\ncd example\n```\n\n### 将这个目录变成版本库\n```\ngit init\n```\n　　目录下多一个.git目录，用来跟踪管理版本库，你也可以把线上的项目克隆到本地，使用下面的命令\n\n```\ngit clone [url]\n```\n\n## 2.将文件添加到版本库\n\n### 追踪文件\n```\ngit add [filename]\n```\n或者一次性添加所有未追踪的文件\n```\ngit add .\n```\n### 提交到仓库\n```\ngit commit -m \"[you description]\"\n```\n\n## 3.查看当前仓库的状态\n\n```\ngit status\n```\n\n　　这个命令用来查看仓库的详细状态，添加-s查看简要的状态(s表示short)\n\n```\ngit status -s\n```\n\n　　简要状态下前面的符号代表的意思：\n\n* ?? 表示添加文件后而未追踪的文件\n* M 表示修改文件(Modify)\n* A 表示添加文件后追踪了该文件(Add)\n* D 表示删除文件(Delete)\n　　\n简要状态下颜色的不同也有区别。如果是红色，则表示该文件修改后没有追踪；是绿色则表示修改后追踪了改文件。\n\n## 4.对比文件差异\n\n　　git diff(difference)此命令比较的是工作目录中当前文件和暂存区域快照之间的差异,也就是修改之后还没有暂存起来的变化内容\n```\ngit diff\n```\n　　如果使用add命令追踪该文件后，diff命令失效。\n\n## 5.显示提交的日志\n```\ngit log\n```\n　　log命令用于显示从最近到以前的提交日志，commit后面显示的一长串字符数字是该次提交所对应的版本号，每次都不会重复的。log命令显示的信息比较多，可以加上 --pretty=oneline 参数\n```\ngit log --pretty=oneline\n```\n　　在下面的版本回退中需要用到提交日志的版本号，这时候就需要复制这个版本号。在windows下复制git窗口中的内容的快捷键是Ctrl+Insert，粘贴是Insert\n\n## 6.版本回退\n```\ngit reset --hard [LogId]\n```\n　　reset命令用于控制版本回退到之前提交时的状态。这边的LogId就是上一节中复制出来的版本号。\n\n## 7.撤销修改\n```\ngit checkout -- [filename]\n```\n　　checkout命令让你在工作区做的修改全部撤销，回到上一次commit时的状态。\n\n## 8.删除文件\n　　如果你在工作区删除了一个文件，那么status就会提醒你工作区和暂存区不一致。这时候你有两种选择，一个是git rm命令确认删除，\n```\ngit rm [filename]\n```\n　　这个命令相当于同时进行了删除命令和追踪文件命令，其等价命令如下：\n```\nrm [filename]\ngit add [filename]\n```\n　　另一个是通过checkout命令找回删除的文件\n```\ngit checkout -- [filename]\n```\n","slug":"Git-Command-Start","published":1,"updated":"2016-10-09T01:08:09.223Z","layout":"post","link":"","_id":"ciu99fu4g000jr8fib1inbdjy","content":"<p>　　git是一个开源的分布式版本控制系统，可以很高效的处理不同规模的项目的版本管理。git的命令比较多，在这篇文章中主要介绍了各种git命令的基本操作。本文比较基础，适合入门。<br><a id=\"more\"></a></p>\n<h2 id=\"1-创建版本库\"><a href=\"#1-创建版本库\" class=\"headerlink\" title=\"1. 创建版本库\"></a>1. 创建版本库</h2><h3 id=\"创建目录\"><a href=\"#创建目录\" class=\"headerlink\" title=\"创建目录\"></a>创建目录</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">mkdir example</div><div class=\"line\">cd example</div></pre></td></tr></table></figure>\n<h3 id=\"将这个目录变成版本库\"><a href=\"#将这个目录变成版本库\" class=\"headerlink\" title=\"将这个目录变成版本库\"></a>将这个目录变成版本库</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git init</div></pre></td></tr></table></figure>\n<p>　　目录下多一个.git目录，用来跟踪管理版本库，你也可以把线上的项目克隆到本地，使用下面的命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone [url]</div></pre></td></tr></table></figure>\n<h2 id=\"2-将文件添加到版本库\"><a href=\"#2-将文件添加到版本库\" class=\"headerlink\" title=\"2.将文件添加到版本库\"></a>2.将文件添加到版本库</h2><h3 id=\"追踪文件\"><a href=\"#追踪文件\" class=\"headerlink\" title=\"追踪文件\"></a>追踪文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git add [filename]</div></pre></td></tr></table></figure>\n<p>或者一次性添加所有未追踪的文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git add .</div></pre></td></tr></table></figure></p>\n<h3 id=\"提交到仓库\"><a href=\"#提交到仓库\" class=\"headerlink\" title=\"提交到仓库\"></a>提交到仓库</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git commit -m &quot;[you description]&quot;</div></pre></td></tr></table></figure>\n<h2 id=\"3-查看当前仓库的状态\"><a href=\"#3-查看当前仓库的状态\" class=\"headerlink\" title=\"3.查看当前仓库的状态\"></a>3.查看当前仓库的状态</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git status</div></pre></td></tr></table></figure>\n<p>　　这个命令用来查看仓库的详细状态，添加-s查看简要的状态(s表示short)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git status -s</div></pre></td></tr></table></figure>\n<p>　　简要状态下前面的符号代表的意思：</p>\n<ul>\n<li>?? 表示添加文件后而未追踪的文件</li>\n<li>M 表示修改文件(Modify)</li>\n<li>A 表示添加文件后追踪了该文件(Add)</li>\n<li>D 表示删除文件(Delete)<br>　　<br>简要状态下颜色的不同也有区别。如果是红色，则表示该文件修改后没有追踪；是绿色则表示修改后追踪了改文件。</li>\n</ul>\n<h2 id=\"4-对比文件差异\"><a href=\"#4-对比文件差异\" class=\"headerlink\" title=\"4.对比文件差异\"></a>4.对比文件差异</h2><p>　　git diff(difference)此命令比较的是工作目录中当前文件和暂存区域快照之间的差异,也就是修改之后还没有暂存起来的变化内容<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git diff</div></pre></td></tr></table></figure></p>\n<p>　　如果使用add命令追踪该文件后，diff命令失效。</p>\n<h2 id=\"5-显示提交的日志\"><a href=\"#5-显示提交的日志\" class=\"headerlink\" title=\"5.显示提交的日志\"></a>5.显示提交的日志</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git log</div></pre></td></tr></table></figure>\n<p>　　log命令用于显示从最近到以前的提交日志，commit后面显示的一长串字符数字是该次提交所对应的版本号，每次都不会重复的。log命令显示的信息比较多，可以加上 –pretty=oneline 参数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git log --pretty=oneline</div></pre></td></tr></table></figure></p>\n<p>　　在下面的版本回退中需要用到提交日志的版本号，这时候就需要复制这个版本号。在windows下复制git窗口中的内容的快捷键是Ctrl+Insert，粘贴是Insert</p>\n<h2 id=\"6-版本回退\"><a href=\"#6-版本回退\" class=\"headerlink\" title=\"6.版本回退\"></a>6.版本回退</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git reset --hard [LogId]</div></pre></td></tr></table></figure>\n<p>　　reset命令用于控制版本回退到之前提交时的状态。这边的LogId就是上一节中复制出来的版本号。</p>\n<h2 id=\"7-撤销修改\"><a href=\"#7-撤销修改\" class=\"headerlink\" title=\"7.撤销修改\"></a>7.撤销修改</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git checkout -- [filename]</div></pre></td></tr></table></figure>\n<p>　　checkout命令让你在工作区做的修改全部撤销，回到上一次commit时的状态。</p>\n<h2 id=\"8-删除文件\"><a href=\"#8-删除文件\" class=\"headerlink\" title=\"8.删除文件\"></a>8.删除文件</h2><p>　　如果你在工作区删除了一个文件，那么status就会提醒你工作区和暂存区不一致。这时候你有两种选择，一个是git rm命令确认删除，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git rm [filename]</div></pre></td></tr></table></figure></p>\n<p>　　这个命令相当于同时进行了删除命令和追踪文件命令，其等价命令如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">rm [filename]</div><div class=\"line\">git add [filename]</div></pre></td></tr></table></figure></p>\n<p>　　另一个是通过checkout命令找回删除的文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git checkout -- [filename]</div></pre></td></tr></table></figure></p>\n","excerpt":"<p>　　git是一个开源的分布式版本控制系统，可以很高效的处理不同规模的项目的版本管理。git的命令比较多，在这篇文章中主要介绍了各种git命令的基本操作。本文比较基础，适合入门。<br>","more":"</p>\n<h2 id=\"1-创建版本库\"><a href=\"#1-创建版本库\" class=\"headerlink\" title=\"1. 创建版本库\"></a>1. 创建版本库</h2><h3 id=\"创建目录\"><a href=\"#创建目录\" class=\"headerlink\" title=\"创建目录\"></a>创建目录</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">mkdir example</div><div class=\"line\">cd example</div></pre></td></tr></table></figure>\n<h3 id=\"将这个目录变成版本库\"><a href=\"#将这个目录变成版本库\" class=\"headerlink\" title=\"将这个目录变成版本库\"></a>将这个目录变成版本库</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git init</div></pre></td></tr></table></figure>\n<p>　　目录下多一个.git目录，用来跟踪管理版本库，你也可以把线上的项目克隆到本地，使用下面的命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone [url]</div></pre></td></tr></table></figure>\n<h2 id=\"2-将文件添加到版本库\"><a href=\"#2-将文件添加到版本库\" class=\"headerlink\" title=\"2.将文件添加到版本库\"></a>2.将文件添加到版本库</h2><h3 id=\"追踪文件\"><a href=\"#追踪文件\" class=\"headerlink\" title=\"追踪文件\"></a>追踪文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git add [filename]</div></pre></td></tr></table></figure>\n<p>或者一次性添加所有未追踪的文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git add .</div></pre></td></tr></table></figure></p>\n<h3 id=\"提交到仓库\"><a href=\"#提交到仓库\" class=\"headerlink\" title=\"提交到仓库\"></a>提交到仓库</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git commit -m &quot;[you description]&quot;</div></pre></td></tr></table></figure>\n<h2 id=\"3-查看当前仓库的状态\"><a href=\"#3-查看当前仓库的状态\" class=\"headerlink\" title=\"3.查看当前仓库的状态\"></a>3.查看当前仓库的状态</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git status</div></pre></td></tr></table></figure>\n<p>　　这个命令用来查看仓库的详细状态，添加-s查看简要的状态(s表示short)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git status -s</div></pre></td></tr></table></figure>\n<p>　　简要状态下前面的符号代表的意思：</p>\n<ul>\n<li>?? 表示添加文件后而未追踪的文件</li>\n<li>M 表示修改文件(Modify)</li>\n<li>A 表示添加文件后追踪了该文件(Add)</li>\n<li>D 表示删除文件(Delete)<br>　　<br>简要状态下颜色的不同也有区别。如果是红色，则表示该文件修改后没有追踪；是绿色则表示修改后追踪了改文件。</li>\n</ul>\n<h2 id=\"4-对比文件差异\"><a href=\"#4-对比文件差异\" class=\"headerlink\" title=\"4.对比文件差异\"></a>4.对比文件差异</h2><p>　　git diff(difference)此命令比较的是工作目录中当前文件和暂存区域快照之间的差异,也就是修改之后还没有暂存起来的变化内容<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git diff</div></pre></td></tr></table></figure></p>\n<p>　　如果使用add命令追踪该文件后，diff命令失效。</p>\n<h2 id=\"5-显示提交的日志\"><a href=\"#5-显示提交的日志\" class=\"headerlink\" title=\"5.显示提交的日志\"></a>5.显示提交的日志</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git log</div></pre></td></tr></table></figure>\n<p>　　log命令用于显示从最近到以前的提交日志，commit后面显示的一长串字符数字是该次提交所对应的版本号，每次都不会重复的。log命令显示的信息比较多，可以加上 –pretty=oneline 参数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git log --pretty=oneline</div></pre></td></tr></table></figure></p>\n<p>　　在下面的版本回退中需要用到提交日志的版本号，这时候就需要复制这个版本号。在windows下复制git窗口中的内容的快捷键是Ctrl+Insert，粘贴是Insert</p>\n<h2 id=\"6-版本回退\"><a href=\"#6-版本回退\" class=\"headerlink\" title=\"6.版本回退\"></a>6.版本回退</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git reset --hard [LogId]</div></pre></td></tr></table></figure>\n<p>　　reset命令用于控制版本回退到之前提交时的状态。这边的LogId就是上一节中复制出来的版本号。</p>\n<h2 id=\"7-撤销修改\"><a href=\"#7-撤销修改\" class=\"headerlink\" title=\"7.撤销修改\"></a>7.撤销修改</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git checkout -- [filename]</div></pre></td></tr></table></figure>\n<p>　　checkout命令让你在工作区做的修改全部撤销，回到上一次commit时的状态。</p>\n<h2 id=\"8-删除文件\"><a href=\"#8-删除文件\" class=\"headerlink\" title=\"8.删除文件\"></a>8.删除文件</h2><p>　　如果你在工作区删除了一个文件，那么status就会提醒你工作区和暂存区不一致。这时候你有两种选择，一个是git rm命令确认删除，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git rm [filename]</div></pre></td></tr></table></figure></p>\n<p>　　这个命令相当于同时进行了删除命令和追踪文件命令，其等价命令如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">rm [filename]</div><div class=\"line\">git add [filename]</div></pre></td></tr></table></figure></p>\n<p>　　另一个是通过checkout命令找回删除的文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git checkout -- [filename]</div></pre></td></tr></table></figure></p>"},{"title":"深入理解js中的变量和作用域","date":"2016-09-21T02:51:58.000Z","description":null,"toc":null,"author":"Corner","comments":1,"original":null,"photos":[],"_content":"　　如果把整个js比作是一个作战的军队，作用域就像是军队中的一个个编制单位，负责整编士兵；而变量就像军队中的最小单位---士兵。\n<!-- more -->\n\n# 变量\n## 变量分类\n　　js中的变量分为两种：全局变量和局部变量。全局变量很好理解，就是在js任何地方都能够调用的变量；而局部变量就只能在函数的内部才能够调用的变量。\n```javascript\nvar a=10;\nfunction show(){\n  console.log('a:'+a); //a:10\n  var b=2;\n  console.log('inside b:'+b); //inside b:2\n}\nshow();\nconsole.log('outside b:'+b); //b is no defined\n```\n　　在上面的程序中，变量a就是一个全局变量，在函数的内部能够调用。但是这里的变量b就是局部变量，当函数结束调用后，变量b就被回收了，因此在函数外部调用失败。\n\n**另外需要特别注意的是：**\n　　如果在声明局部变量时不用var声明，那么这个变量自动“提升”为全局变量。\n```javascript\nvar a=10;\nfunction show(){\n  console.log('a:'+a); //a:10\n  b=2;\n  console.log('inside b:'+b); //inside b:2\n}\nshow();\nconsole.log('outside b:'+b); //outside b:2\n```\n\n　　对比两段代码，如果你在声明b=2时没有写var，那么b就隐式地声明为全局变量，在函数外面还是能够被调用到的。\n　　虽然使用全局变量能够在任何地方调用，很方便，但是全局变量的优点也给他带来了缺点：\n\n1. 一直占用内存：全局变量保存在静态存储区，如果全局变量过多会占多大量内存，严重影响页面的性能。\n2. 影响了函数的独立性：一般函数都是传入参数和传出返回值进行运算的，如果函数依赖于全局变量，破坏了函数的这种独立性，同时也降低了函数的可移植性。\n\n*因此我们在定义变量时一般要尽可能少的定义全局变量。*\n\n## 变量声明\n\n> 函数声明优先于变量声明\n\n　　下面我们通过一段代码来说明.\n```javascript\nvar a; \nfunction a(){\n}\nconsole.log(typeof a); //function\n```\n\n　　或许有人是认为函数声明在后面的原因，那么调换一下位置。\n\n```javascript\nfunction a(){\n}\nvar a; \nconsole.log(typeof a); //function\n```\n\n　　调换位置后变量a的类型还是function，这时候声明变量a的语句没有起作用，被函数声明覆盖了。因此函数声明优先于变量的声明。\n　　但是如果我们在声明的同时给a进行赋值。\n\n```javascript\nfunction a(){\n}\nvar a='xyf'; \nconsole.log(typeof a); //string\n```\n\n　　我们将其调换一下位置再次进行验证。\n\n```javascript\nvar a='xyf'; \nfunction a(){\n}\nconsole.log(typeof a); //string\n```\n\n　　可以看到，给变量a进行赋值后，不管变量a在哪，其类型变为字符串类型，上面两段代码相当于如下代码：\n\n```javascript\nfunction a(){\n}\nvar a;\na='xyf';\nconsole.log(typeof a); //string\n```\n\n　　a最后被赋值为字符串，因此a的类型自然是字符串\n\n# 作用域\n## 块级作用域\n　　js中作用域只有一个函数作用域和全局作用域，一个很大的特点就是js中**没有块级作用域**。函数作用域是比较容易理解的，那么什么是块级作用域呢？\n\n> 任何一对花括号（｛和｝）中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。\n\n　　理解了块级作用域，来看一下下面的小例子。\n\n```javascript\nconsole.log(v); //undefined\nvar v = \"world\";\n```\n\n　　这段代码很好理解，由于变量v在没有赋值前使用了，所以是undefined。其实这里存在着声明的提前。\n\n> 当前作用域内的声明都会提升到作用域的最前面，包括变量和函数的声明\n\n　　由于js作用域中的声明都会被提升到作用域的最前面，所以，上面的代码相当于：\n\n```javascript\nvar v;\nconsole.log(v); //undefined\nv = \"world\";\n```\n\n　　这样就能很清晰地理解为什么变量v是undefined的了。\n　　下面我们把变量v放到一个方法中去：\n\n```javascript\nif(true){\n  var v = \"hello\";\n}\nconsole.log(v); //hello\n```\n\n　　在这里由于js没有块级作用域，所以if方法没有“形成”一个封闭的作用域，并不能够“阻挡”外面的代码获取里面的变量。\n\n## 函数作用域\n　　我们再把变量v放到函数中去：\n\n```javascript\nfunction show(){\n  var v='world';\n}\nshow();\nconsole.log(v); //undefined\n```\n\n　　由于show函数是一个函数作用域，“阻挡”外面的代码获取里面变量（并不能阻挡里面的代码获取外面的变量），所以函数外部并不能获取到函数里面的变量v。因此证明了js中只有函数作用域，没有块级作用域。\n　　再来看下面的一段代码：\n\n```javascript\nvar v='hello';\nfunction show(){\n  console.log(v); //undefined\n  var v='world';\n}\nshow();\n```\n\n　　很多人看到这边都会很疑惑，不是说这边show函数中能够获取到函数外面的变量的么？但是由于这边是一个函数作用域，而函数作用域存在着变量声明的提前，因此，上面的代码相当于下面的代码：\n\n```javascript\nvar v='hello';\nfunction show(){\n\tvar v;\n\tconsole.log(v); //undefined\n\tv='world';\n}\nshow();\n```\n\n　　这里把变量v的声明放到了整个函数作用域的最前面，因此显示为undefined。理解了上面的代码，相信下面的代码也不难理解了。\n\n```javascript\nvar v = \"hello\";\n(function(){\n  console.log(v);\n  var v = \"world\";\n})();\n```\n\n　　在这里自执行函数形成了函数作用域\n\n## 需要注意的是\n\n> 变量提升只提升函数的声明，并不提升函数的定义\n\n```javascript\nshow(); //show is not a function\nvar show=function(){\n\t//...\n}\nshow(); //成功运行\n```\n\n　　或许有人有疑问，为什么这边定义的函数就不能执行呢？在这里我们需要明白函数在js中是如何进行定义的。函数有两种定义方式，一种是函数声明，另一种是函数表达式。那么什么是函数声明什么是函数表达式呢？\n\n```javascript\n//函数声明\nfunction show(){\n\t//....\n}\n//函数表达式\nvar show=function(){\n\t//...\n}\n```\n\n　　乍一看，他们长得很像，写法都差不多，但是实际上还是有区别的。js的解析器对函数声明和函数表达式并不是一视同仁的对待的，有点“种族歧视”的意思在里面。\n　　函数声明就像是“一等公民”，js会优先读取，确保在执行前就已经被解析了，所以函数声明放在当前作用域的任何地方都能够被调用，甚至放到调用函数声明之后面。\n　　而函数表达式就显得比较“普通”，和一般的变量一样，只有到执行到该行时才进行解析，因此，调用函数表达式要在定义后进行使用。\n\n\n\n","source":"_posts/JS-Variate-Scope.md","raw":"title: 深入理解js中的变量和作用域\ndate: 2016-09-21 10:51:58\ndescription:\ncategories:\n- 编程\ntags:\n- 前端\n- js\ntoc:\nauthor: Corner\ncomments:\noriginal:\npermalink:\nphotos:\n---\n　　如果把整个js比作是一个作战的军队，作用域就像是军队中的一个个编制单位，负责整编士兵；而变量就像军队中的最小单位---士兵。\n<!-- more -->\n\n# 变量\n## 变量分类\n　　js中的变量分为两种：全局变量和局部变量。全局变量很好理解，就是在js任何地方都能够调用的变量；而局部变量就只能在函数的内部才能够调用的变量。\n```javascript\nvar a=10;\nfunction show(){\n  console.log('a:'+a); //a:10\n  var b=2;\n  console.log('inside b:'+b); //inside b:2\n}\nshow();\nconsole.log('outside b:'+b); //b is no defined\n```\n　　在上面的程序中，变量a就是一个全局变量，在函数的内部能够调用。但是这里的变量b就是局部变量，当函数结束调用后，变量b就被回收了，因此在函数外部调用失败。\n\n**另外需要特别注意的是：**\n　　如果在声明局部变量时不用var声明，那么这个变量自动“提升”为全局变量。\n```javascript\nvar a=10;\nfunction show(){\n  console.log('a:'+a); //a:10\n  b=2;\n  console.log('inside b:'+b); //inside b:2\n}\nshow();\nconsole.log('outside b:'+b); //outside b:2\n```\n\n　　对比两段代码，如果你在声明b=2时没有写var，那么b就隐式地声明为全局变量，在函数外面还是能够被调用到的。\n　　虽然使用全局变量能够在任何地方调用，很方便，但是全局变量的优点也给他带来了缺点：\n\n1. 一直占用内存：全局变量保存在静态存储区，如果全局变量过多会占多大量内存，严重影响页面的性能。\n2. 影响了函数的独立性：一般函数都是传入参数和传出返回值进行运算的，如果函数依赖于全局变量，破坏了函数的这种独立性，同时也降低了函数的可移植性。\n\n*因此我们在定义变量时一般要尽可能少的定义全局变量。*\n\n## 变量声明\n\n> 函数声明优先于变量声明\n\n　　下面我们通过一段代码来说明.\n```javascript\nvar a; \nfunction a(){\n}\nconsole.log(typeof a); //function\n```\n\n　　或许有人是认为函数声明在后面的原因，那么调换一下位置。\n\n```javascript\nfunction a(){\n}\nvar a; \nconsole.log(typeof a); //function\n```\n\n　　调换位置后变量a的类型还是function，这时候声明变量a的语句没有起作用，被函数声明覆盖了。因此函数声明优先于变量的声明。\n　　但是如果我们在声明的同时给a进行赋值。\n\n```javascript\nfunction a(){\n}\nvar a='xyf'; \nconsole.log(typeof a); //string\n```\n\n　　我们将其调换一下位置再次进行验证。\n\n```javascript\nvar a='xyf'; \nfunction a(){\n}\nconsole.log(typeof a); //string\n```\n\n　　可以看到，给变量a进行赋值后，不管变量a在哪，其类型变为字符串类型，上面两段代码相当于如下代码：\n\n```javascript\nfunction a(){\n}\nvar a;\na='xyf';\nconsole.log(typeof a); //string\n```\n\n　　a最后被赋值为字符串，因此a的类型自然是字符串\n\n# 作用域\n## 块级作用域\n　　js中作用域只有一个函数作用域和全局作用域，一个很大的特点就是js中**没有块级作用域**。函数作用域是比较容易理解的，那么什么是块级作用域呢？\n\n> 任何一对花括号（｛和｝）中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。\n\n　　理解了块级作用域，来看一下下面的小例子。\n\n```javascript\nconsole.log(v); //undefined\nvar v = \"world\";\n```\n\n　　这段代码很好理解，由于变量v在没有赋值前使用了，所以是undefined。其实这里存在着声明的提前。\n\n> 当前作用域内的声明都会提升到作用域的最前面，包括变量和函数的声明\n\n　　由于js作用域中的声明都会被提升到作用域的最前面，所以，上面的代码相当于：\n\n```javascript\nvar v;\nconsole.log(v); //undefined\nv = \"world\";\n```\n\n　　这样就能很清晰地理解为什么变量v是undefined的了。\n　　下面我们把变量v放到一个方法中去：\n\n```javascript\nif(true){\n  var v = \"hello\";\n}\nconsole.log(v); //hello\n```\n\n　　在这里由于js没有块级作用域，所以if方法没有“形成”一个封闭的作用域，并不能够“阻挡”外面的代码获取里面的变量。\n\n## 函数作用域\n　　我们再把变量v放到函数中去：\n\n```javascript\nfunction show(){\n  var v='world';\n}\nshow();\nconsole.log(v); //undefined\n```\n\n　　由于show函数是一个函数作用域，“阻挡”外面的代码获取里面变量（并不能阻挡里面的代码获取外面的变量），所以函数外部并不能获取到函数里面的变量v。因此证明了js中只有函数作用域，没有块级作用域。\n　　再来看下面的一段代码：\n\n```javascript\nvar v='hello';\nfunction show(){\n  console.log(v); //undefined\n  var v='world';\n}\nshow();\n```\n\n　　很多人看到这边都会很疑惑，不是说这边show函数中能够获取到函数外面的变量的么？但是由于这边是一个函数作用域，而函数作用域存在着变量声明的提前，因此，上面的代码相当于下面的代码：\n\n```javascript\nvar v='hello';\nfunction show(){\n\tvar v;\n\tconsole.log(v); //undefined\n\tv='world';\n}\nshow();\n```\n\n　　这里把变量v的声明放到了整个函数作用域的最前面，因此显示为undefined。理解了上面的代码，相信下面的代码也不难理解了。\n\n```javascript\nvar v = \"hello\";\n(function(){\n  console.log(v);\n  var v = \"world\";\n})();\n```\n\n　　在这里自执行函数形成了函数作用域\n\n## 需要注意的是\n\n> 变量提升只提升函数的声明，并不提升函数的定义\n\n```javascript\nshow(); //show is not a function\nvar show=function(){\n\t//...\n}\nshow(); //成功运行\n```\n\n　　或许有人有疑问，为什么这边定义的函数就不能执行呢？在这里我们需要明白函数在js中是如何进行定义的。函数有两种定义方式，一种是函数声明，另一种是函数表达式。那么什么是函数声明什么是函数表达式呢？\n\n```javascript\n//函数声明\nfunction show(){\n\t//....\n}\n//函数表达式\nvar show=function(){\n\t//...\n}\n```\n\n　　乍一看，他们长得很像，写法都差不多，但是实际上还是有区别的。js的解析器对函数声明和函数表达式并不是一视同仁的对待的，有点“种族歧视”的意思在里面。\n　　函数声明就像是“一等公民”，js会优先读取，确保在执行前就已经被解析了，所以函数声明放在当前作用域的任何地方都能够被调用，甚至放到调用函数声明之后面。\n　　而函数表达式就显得比较“普通”，和一般的变量一样，只有到执行到该行时才进行解析，因此，调用函数表达式要在定义后进行使用。\n\n\n\n","slug":"JS-Variate-Scope","published":1,"updated":"2016-10-09T01:08:09.223Z","layout":"post","link":"","_id":"ciu99fu4j000mr8finqe25z71","content":"<p>　　如果把整个js比作是一个作战的军队，作用域就像是军队中的一个个编制单位，负责整编士兵；而变量就像军队中的最小单位—士兵。<br><a id=\"more\"></a></p>\n<h1 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h1><h2 id=\"变量分类\"><a href=\"#变量分类\" class=\"headerlink\" title=\"变量分类\"></a>变量分类</h2><p>　　js中的变量分为两种：全局变量和局部变量。全局变量很好理解，就是在js任何地方都能够调用的变量；而局部变量就只能在函数的内部才能够调用的变量。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'a:'</span>+a); <span class=\"comment\">//a:10</span></div><div class=\"line\">  <span class=\"keyword\">var</span> b=<span class=\"number\">2</span>;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'inside b:'</span>+b); <span class=\"comment\">//inside b:2</span></div><div class=\"line\">&#125;</div><div class=\"line\">show();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'outside b:'</span>+b); <span class=\"comment\">//b is no defined</span></div></pre></td></tr></table></figure></p>\n<p>　　在上面的程序中，变量a就是一个全局变量，在函数的内部能够调用。但是这里的变量b就是局部变量，当函数结束调用后，变量b就被回收了，因此在函数外部调用失败。</p>\n<p><strong>另外需要特别注意的是：</strong><br>　　如果在声明局部变量时不用var声明，那么这个变量自动“提升”为全局变量。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'a:'</span>+a); <span class=\"comment\">//a:10</span></div><div class=\"line\">  b=<span class=\"number\">2</span>;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'inside b:'</span>+b); <span class=\"comment\">//inside b:2</span></div><div class=\"line\">&#125;</div><div class=\"line\">show();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'outside b:'</span>+b); <span class=\"comment\">//outside b:2</span></div></pre></td></tr></table></figure></p>\n<p>　　对比两段代码，如果你在声明b=2时没有写var，那么b就隐式地声明为全局变量，在函数外面还是能够被调用到的。<br>　　虽然使用全局变量能够在任何地方调用，很方便，但是全局变量的优点也给他带来了缺点：</p>\n<ol>\n<li>一直占用内存：全局变量保存在静态存储区，如果全局变量过多会占多大量内存，严重影响页面的性能。</li>\n<li>影响了函数的独立性：一般函数都是传入参数和传出返回值进行运算的，如果函数依赖于全局变量，破坏了函数的这种独立性，同时也降低了函数的可移植性。</li>\n</ol>\n<p><em>因此我们在定义变量时一般要尽可能少的定义全局变量。</em></p>\n<h2 id=\"变量声明\"><a href=\"#变量声明\" class=\"headerlink\" title=\"变量声明\"></a>变量声明</h2><blockquote>\n<p>函数声明优先于变量声明</p>\n</blockquote>\n<p>　　下面我们通过一段代码来说明.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a; </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> a); <span class=\"comment\">//function</span></div></pre></td></tr></table></figure></p>\n<p>　　或许有人是认为函数声明在后面的原因，那么调换一下位置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> a; </div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> a); <span class=\"comment\">//function</span></div></pre></td></tr></table></figure>\n<p>　　调换位置后变量a的类型还是function，这时候声明变量a的语句没有起作用，被函数声明覆盖了。因此函数声明优先于变量的声明。<br>　　但是如果我们在声明的同时给a进行赋值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"string\">'xyf'</span>; </div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> a); <span class=\"comment\">//string</span></div></pre></td></tr></table></figure>\n<p>　　我们将其调换一下位置再次进行验证。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"string\">'xyf'</span>; </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> a); <span class=\"comment\">//string</span></div></pre></td></tr></table></figure>\n<p>　　可以看到，给变量a进行赋值后，不管变量a在哪，其类型变为字符串类型，上面两段代码相当于如下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> a;</div><div class=\"line\">a=<span class=\"string\">'xyf'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> a); <span class=\"comment\">//string</span></div></pre></td></tr></table></figure>\n<p>　　a最后被赋值为字符串，因此a的类型自然是字符串</p>\n<h1 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h1><h2 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h2><p>　　js中作用域只有一个函数作用域和全局作用域，一个很大的特点就是js中<strong>没有块级作用域</strong>。函数作用域是比较容易理解的，那么什么是块级作用域呢？</p>\n<blockquote>\n<p>任何一对花括号（｛和｝）中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。</p>\n</blockquote>\n<p>　　理解了块级作用域，来看一下下面的小例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(v); <span class=\"comment\">//undefined</span></div><div class=\"line\"><span class=\"keyword\">var</span> v = <span class=\"string\">\"world\"</span>;</div></pre></td></tr></table></figure>\n<p>　　这段代码很好理解，由于变量v在没有赋值前使用了，所以是undefined。其实这里存在着声明的提前。</p>\n<blockquote>\n<p>当前作用域内的声明都会提升到作用域的最前面，包括变量和函数的声明</p>\n</blockquote>\n<p>　　由于js作用域中的声明都会被提升到作用域的最前面，所以，上面的代码相当于：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> v;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(v); <span class=\"comment\">//undefined</span></div><div class=\"line\">v = <span class=\"string\">\"world\"</span>;</div></pre></td></tr></table></figure>\n<p>　　这样就能很清晰地理解为什么变量v是undefined的了。<br>　　下面我们把变量v放到一个方法中去：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">true</span>)&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> v = <span class=\"string\">\"hello\"</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(v); <span class=\"comment\">//hello</span></div></pre></td></tr></table></figure>\n<p>　　在这里由于js没有块级作用域，所以if方法没有“形成”一个封闭的作用域，并不能够“阻挡”外面的代码获取里面的变量。</p>\n<h2 id=\"函数作用域\"><a href=\"#函数作用域\" class=\"headerlink\" title=\"函数作用域\"></a>函数作用域</h2><p>　　我们再把变量v放到函数中去：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> v=<span class=\"string\">'world'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">show();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(v); <span class=\"comment\">//undefined</span></div></pre></td></tr></table></figure>\n<p>　　由于show函数是一个函数作用域，“阻挡”外面的代码获取里面变量（并不能阻挡里面的代码获取外面的变量），所以函数外部并不能获取到函数里面的变量v。因此证明了js中只有函数作用域，没有块级作用域。<br>　　再来看下面的一段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> v=<span class=\"string\">'hello'</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(v); <span class=\"comment\">//undefined</span></div><div class=\"line\">  <span class=\"keyword\">var</span> v=<span class=\"string\">'world'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">show();</div></pre></td></tr></table></figure>\n<p>　　很多人看到这边都会很疑惑，不是说这边show函数中能够获取到函数外面的变量的么？但是由于这边是一个函数作用域，而函数作用域存在着变量声明的提前，因此，上面的代码相当于下面的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> v=<span class=\"string\">'hello'</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> v;</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(v); <span class=\"comment\">//undefined</span></div><div class=\"line\">\tv=<span class=\"string\">'world'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">show();</div></pre></td></tr></table></figure>\n<p>　　这里把变量v的声明放到了整个函数作用域的最前面，因此显示为undefined。理解了上面的代码，相信下面的代码也不难理解了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> v = <span class=\"string\">\"hello\"</span>;</div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(v);</div><div class=\"line\">  <span class=\"keyword\">var</span> v = <span class=\"string\">\"world\"</span>;</div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure>\n<p>　　在这里自执行函数形成了函数作用域</p>\n<h2 id=\"需要注意的是\"><a href=\"#需要注意的是\" class=\"headerlink\" title=\"需要注意的是\"></a>需要注意的是</h2><blockquote>\n<p>变量提升只提升函数的声明，并不提升函数的定义</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">show(); <span class=\"comment\">//show is not a function</span></div><div class=\"line\"><span class=\"keyword\">var</span> show=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t<span class=\"comment\">//...</span></div><div class=\"line\">&#125;</div><div class=\"line\">show(); <span class=\"comment\">//成功运行</span></div></pre></td></tr></table></figure>\n<p>　　或许有人有疑问，为什么这边定义的函数就不能执行呢？在这里我们需要明白函数在js中是如何进行定义的。函数有两种定义方式，一种是函数声明，另一种是函数表达式。那么什么是函数声明什么是函数表达式呢？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//函数声明</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t<span class=\"comment\">//....</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//函数表达式</span></div><div class=\"line\"><span class=\"keyword\">var</span> show=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t<span class=\"comment\">//...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>　　乍一看，他们长得很像，写法都差不多，但是实际上还是有区别的。js的解析器对函数声明和函数表达式并不是一视同仁的对待的，有点“种族歧视”的意思在里面。<br>　　函数声明就像是“一等公民”，js会优先读取，确保在执行前就已经被解析了，所以函数声明放在当前作用域的任何地方都能够被调用，甚至放到调用函数声明之后面。<br>　　而函数表达式就显得比较“普通”，和一般的变量一样，只有到执行到该行时才进行解析，因此，调用函数表达式要在定义后进行使用。</p>\n","excerpt":"<p>　　如果把整个js比作是一个作战的军队，作用域就像是军队中的一个个编制单位，负责整编士兵；而变量就像军队中的最小单位—士兵。<br>","more":"</p>\n<h1 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h1><h2 id=\"变量分类\"><a href=\"#变量分类\" class=\"headerlink\" title=\"变量分类\"></a>变量分类</h2><p>　　js中的变量分为两种：全局变量和局部变量。全局变量很好理解，就是在js任何地方都能够调用的变量；而局部变量就只能在函数的内部才能够调用的变量。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'a:'</span>+a); <span class=\"comment\">//a:10</span></div><div class=\"line\">  <span class=\"keyword\">var</span> b=<span class=\"number\">2</span>;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'inside b:'</span>+b); <span class=\"comment\">//inside b:2</span></div><div class=\"line\">&#125;</div><div class=\"line\">show();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'outside b:'</span>+b); <span class=\"comment\">//b is no defined</span></div></pre></td></tr></table></figure></p>\n<p>　　在上面的程序中，变量a就是一个全局变量，在函数的内部能够调用。但是这里的变量b就是局部变量，当函数结束调用后，变量b就被回收了，因此在函数外部调用失败。</p>\n<p><strong>另外需要特别注意的是：</strong><br>　　如果在声明局部变量时不用var声明，那么这个变量自动“提升”为全局变量。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'a:'</span>+a); <span class=\"comment\">//a:10</span></div><div class=\"line\">  b=<span class=\"number\">2</span>;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'inside b:'</span>+b); <span class=\"comment\">//inside b:2</span></div><div class=\"line\">&#125;</div><div class=\"line\">show();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'outside b:'</span>+b); <span class=\"comment\">//outside b:2</span></div></pre></td></tr></table></figure></p>\n<p>　　对比两段代码，如果你在声明b=2时没有写var，那么b就隐式地声明为全局变量，在函数外面还是能够被调用到的。<br>　　虽然使用全局变量能够在任何地方调用，很方便，但是全局变量的优点也给他带来了缺点：</p>\n<ol>\n<li>一直占用内存：全局变量保存在静态存储区，如果全局变量过多会占多大量内存，严重影响页面的性能。</li>\n<li>影响了函数的独立性：一般函数都是传入参数和传出返回值进行运算的，如果函数依赖于全局变量，破坏了函数的这种独立性，同时也降低了函数的可移植性。</li>\n</ol>\n<p><em>因此我们在定义变量时一般要尽可能少的定义全局变量。</em></p>\n<h2 id=\"变量声明\"><a href=\"#变量声明\" class=\"headerlink\" title=\"变量声明\"></a>变量声明</h2><blockquote>\n<p>函数声明优先于变量声明</p>\n</blockquote>\n<p>　　下面我们通过一段代码来说明.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a; </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> a); <span class=\"comment\">//function</span></div></pre></td></tr></table></figure></p>\n<p>　　或许有人是认为函数声明在后面的原因，那么调换一下位置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> a; </div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> a); <span class=\"comment\">//function</span></div></pre></td></tr></table></figure>\n<p>　　调换位置后变量a的类型还是function，这时候声明变量a的语句没有起作用，被函数声明覆盖了。因此函数声明优先于变量的声明。<br>　　但是如果我们在声明的同时给a进行赋值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"string\">'xyf'</span>; </div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> a); <span class=\"comment\">//string</span></div></pre></td></tr></table></figure>\n<p>　　我们将其调换一下位置再次进行验证。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a=<span class=\"string\">'xyf'</span>; </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> a); <span class=\"comment\">//string</span></div></pre></td></tr></table></figure>\n<p>　　可以看到，给变量a进行赋值后，不管变量a在哪，其类型变为字符串类型，上面两段代码相当于如下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> a;</div><div class=\"line\">a=<span class=\"string\">'xyf'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> a); <span class=\"comment\">//string</span></div></pre></td></tr></table></figure>\n<p>　　a最后被赋值为字符串，因此a的类型自然是字符串</p>\n<h1 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h1><h2 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h2><p>　　js中作用域只有一个函数作用域和全局作用域，一个很大的特点就是js中<strong>没有块级作用域</strong>。函数作用域是比较容易理解的，那么什么是块级作用域呢？</p>\n<blockquote>\n<p>任何一对花括号（｛和｝）中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。</p>\n</blockquote>\n<p>　　理解了块级作用域，来看一下下面的小例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(v); <span class=\"comment\">//undefined</span></div><div class=\"line\"><span class=\"keyword\">var</span> v = <span class=\"string\">\"world\"</span>;</div></pre></td></tr></table></figure>\n<p>　　这段代码很好理解，由于变量v在没有赋值前使用了，所以是undefined。其实这里存在着声明的提前。</p>\n<blockquote>\n<p>当前作用域内的声明都会提升到作用域的最前面，包括变量和函数的声明</p>\n</blockquote>\n<p>　　由于js作用域中的声明都会被提升到作用域的最前面，所以，上面的代码相当于：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> v;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(v); <span class=\"comment\">//undefined</span></div><div class=\"line\">v = <span class=\"string\">\"world\"</span>;</div></pre></td></tr></table></figure>\n<p>　　这样就能很清晰地理解为什么变量v是undefined的了。<br>　　下面我们把变量v放到一个方法中去：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">true</span>)&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> v = <span class=\"string\">\"hello\"</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(v); <span class=\"comment\">//hello</span></div></pre></td></tr></table></figure>\n<p>　　在这里由于js没有块级作用域，所以if方法没有“形成”一个封闭的作用域，并不能够“阻挡”外面的代码获取里面的变量。</p>\n<h2 id=\"函数作用域\"><a href=\"#函数作用域\" class=\"headerlink\" title=\"函数作用域\"></a>函数作用域</h2><p>　　我们再把变量v放到函数中去：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> v=<span class=\"string\">'world'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">show();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(v); <span class=\"comment\">//undefined</span></div></pre></td></tr></table></figure>\n<p>　　由于show函数是一个函数作用域，“阻挡”外面的代码获取里面变量（并不能阻挡里面的代码获取外面的变量），所以函数外部并不能获取到函数里面的变量v。因此证明了js中只有函数作用域，没有块级作用域。<br>　　再来看下面的一段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> v=<span class=\"string\">'hello'</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(v); <span class=\"comment\">//undefined</span></div><div class=\"line\">  <span class=\"keyword\">var</span> v=<span class=\"string\">'world'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">show();</div></pre></td></tr></table></figure>\n<p>　　很多人看到这边都会很疑惑，不是说这边show函数中能够获取到函数外面的变量的么？但是由于这边是一个函数作用域，而函数作用域存在着变量声明的提前，因此，上面的代码相当于下面的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> v=<span class=\"string\">'hello'</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> v;</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(v); <span class=\"comment\">//undefined</span></div><div class=\"line\">\tv=<span class=\"string\">'world'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">show();</div></pre></td></tr></table></figure>\n<p>　　这里把变量v的声明放到了整个函数作用域的最前面，因此显示为undefined。理解了上面的代码，相信下面的代码也不难理解了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> v = <span class=\"string\">\"hello\"</span>;</div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(v);</div><div class=\"line\">  <span class=\"keyword\">var</span> v = <span class=\"string\">\"world\"</span>;</div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure>\n<p>　　在这里自执行函数形成了函数作用域</p>\n<h2 id=\"需要注意的是\"><a href=\"#需要注意的是\" class=\"headerlink\" title=\"需要注意的是\"></a>需要注意的是</h2><blockquote>\n<p>变量提升只提升函数的声明，并不提升函数的定义</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">show(); <span class=\"comment\">//show is not a function</span></div><div class=\"line\"><span class=\"keyword\">var</span> show=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t<span class=\"comment\">//...</span></div><div class=\"line\">&#125;</div><div class=\"line\">show(); <span class=\"comment\">//成功运行</span></div></pre></td></tr></table></figure>\n<p>　　或许有人有疑问，为什么这边定义的函数就不能执行呢？在这里我们需要明白函数在js中是如何进行定义的。函数有两种定义方式，一种是函数声明，另一种是函数表达式。那么什么是函数声明什么是函数表达式呢？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//函数声明</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t<span class=\"comment\">//....</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//函数表达式</span></div><div class=\"line\"><span class=\"keyword\">var</span> show=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t<span class=\"comment\">//...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>　　乍一看，他们长得很像，写法都差不多，但是实际上还是有区别的。js的解析器对函数声明和函数表达式并不是一视同仁的对待的，有点“种族歧视”的意思在里面。<br>　　函数声明就像是“一等公民”，js会优先读取，确保在执行前就已经被解析了，所以函数声明放在当前作用域的任何地方都能够被调用，甚至放到调用函数声明之后面。<br>　　而函数表达式就显得比较“普通”，和一般的变量一样，只有到执行到该行时才进行解析，因此，调用函数表达式要在定义后进行使用。</p>"},{"title":"JAVA处理跨域问题","date":"2016-05-28T05:58:00.000Z","description":null,"toc":true,"author":"Corner","comments":1,"original":null,"photos":[],"_content":"　　在写前端脚本的时候我们经常会遇到发送数据到后台的情况，但是由于浏览器的限制，不同域名之间的数据是不能互相访问的，那前端怎么和后端如何进行数据之间的交换呢？\n<!-- more -->\n\n　　JavaScript由于安全性方面的考虑，不允许页面跨域调用其他页面的对象，那么问题来了，什么是跨域问题？\n答：这是由于浏览器同源策略的限制，现在所有支持JavaScript的浏览器都使用了这个策略。那么什么是同源呢？所谓的同源是指三个方面“相同”：\n\n1. 域名相同\n2. 协议相同\n3. 端口相同\n\n下面就举几个例子来帮助更好的理解同源策略。\n\n| URL        |      说明      | 是否允许通信  |\n| ---------- | -------------- | ------------- |\n| http://www.a.com/a.js <br> http://www.a.com/b.js       | 同一域名           |  允许    |\n| http://www.a.com/a.js <br> http://www.b.com/a.js       | 不同域名           |  不允许  |\n| http://www.a.com:8000/a.js<br>http://www.a.com/b.js    |  同一域名不同端口  |  不允许  |\n| https://www.a.com/a.js <br> http://www.a.com/b.js      | 同一域名不同协议   |  不允许  |\n\n\n　　在JAVA中处理跨域问题，通常有以下两种常用的解决方法。\n\n## 第一种解决方法\n　　后台代码在被请求的Servlet中添加Header设置：\n\n```java\nresponse.setHeader(\"Access-Control-Allow-Origin\", \"*\");\nPrintWriter out =null;\ntry\n{\n\tout = response.getWriter();\n} catch (IOException e)\n{\n\t// TODO Auto-generated catch block\n\te.printStackTrace();\n}\nout.print(\"{'status':'ok'}\");\nout.flush();\nout.close();\n```\n\n　　Access-Control-Allow-Origin这个Header在W3C标准里用来检查该跨域请求是否可以被通过，如果值为*则表明当前页面可以跨域访问。默认的情况下是不允许的。\n　　在前端JS中需要向Servlet发出请求，请求代码如下所示：\n\n```javascript\n$.ajax({\n  url: \"your url\",\n  type:\"get or post\",\n  dataType:\"json\",\n  data:{\n    ....\n  },\n  success:function(data){\n    ...\n  }\n```\n\n## 第二种解决方法\n　　通过jsonp跨域请求的方式。JSONP和JSON虽然只有一个字母的区别，但是他们完全就是两回事，很多人很容易把他们搞混。JSON是一种数据交换的格式，而JSONP则是一种非官方跨域数据交互协议。\n　　首先来说一下前端JS是怎么发送请求。代码如下所示：\n\n```javascript\n$.ajax({\n  url:\"your url\",\n  type:\"get or post\",\n  async:false,\n  dataType : \"jsonp\",\n  //服务端用于接收callback调用的function名的参数\n  jsonp:\"callbackparam\",\n  //callback的function名称\n  jsonpCallback:\"success_jsonpCallback\",\n  success:function(data){\n    console.log(data);\n  },\n  error:function(data){\n    console.log(data);\n  }\n});\n```\n\n　　这里的callbackparam和success_jsonpCallback可以理解为发送的data数据的键值对，可以自定义，但是callbackparam需要和后台约定好参数名称，因为后台需要获取到这个参数里面的值（即success_jsonpCallback）。\n　　下面，最重要的来了，后台怎么样获取和返回数据呢。代码如下所示:\n\n```java\n  PrintWriter out =null;\n  String callback=req.getParameter(\"callbackparam\");\n  String json=callback+\"({'status':'ok'})\";\n  try\n  {\n    out = resp.getWriter();\n  } catch (IOException e)\n  {\n    // TODO Auto-generated catch block\n    e.printStackTrace();\n  }\n  out.print(json);\n  out.flush();\n  out.close();\n```\n\n　　首先需要获取参数名为callbackparam的值，这里获取到的值就是“success_jsonpCallback”。然后将这个值加上一对小括号。小括号里放入你需要返回的数据内容，比如这里我返回一个JSON对象。当然你也可以返回其他对象，比如只返回一个字符串类型数据也可以。最后前端JS返回的数据就是这样的：\n\n```java\nsuccess_jsonpCallback({'status':'ok'})\n```\n\n　　浏览器会自动解析为json对象，这时候你只需要在success回调函数中直接用data.status就可以了。\n\n\n\n\n\n","source":"_posts/Java-Ajax.md","raw":"title: JAVA处理跨域问题\ndate: 2016-05-28 13:58:00\ndescription: \ncategories:\n- 编程\ntags:\n- Java\n- 异步跨域\ntoc: true\nauthor: Corner\ncomments:\noriginal:\npermalink: \nphotos:\n---\n　　在写前端脚本的时候我们经常会遇到发送数据到后台的情况，但是由于浏览器的限制，不同域名之间的数据是不能互相访问的，那前端怎么和后端如何进行数据之间的交换呢？\n<!-- more -->\n\n　　JavaScript由于安全性方面的考虑，不允许页面跨域调用其他页面的对象，那么问题来了，什么是跨域问题？\n答：这是由于浏览器同源策略的限制，现在所有支持JavaScript的浏览器都使用了这个策略。那么什么是同源呢？所谓的同源是指三个方面“相同”：\n\n1. 域名相同\n2. 协议相同\n3. 端口相同\n\n下面就举几个例子来帮助更好的理解同源策略。\n\n| URL        |      说明      | 是否允许通信  |\n| ---------- | -------------- | ------------- |\n| http://www.a.com/a.js <br> http://www.a.com/b.js       | 同一域名           |  允许    |\n| http://www.a.com/a.js <br> http://www.b.com/a.js       | 不同域名           |  不允许  |\n| http://www.a.com:8000/a.js<br>http://www.a.com/b.js    |  同一域名不同端口  |  不允许  |\n| https://www.a.com/a.js <br> http://www.a.com/b.js      | 同一域名不同协议   |  不允许  |\n\n\n　　在JAVA中处理跨域问题，通常有以下两种常用的解决方法。\n\n## 第一种解决方法\n　　后台代码在被请求的Servlet中添加Header设置：\n\n```java\nresponse.setHeader(\"Access-Control-Allow-Origin\", \"*\");\nPrintWriter out =null;\ntry\n{\n\tout = response.getWriter();\n} catch (IOException e)\n{\n\t// TODO Auto-generated catch block\n\te.printStackTrace();\n}\nout.print(\"{'status':'ok'}\");\nout.flush();\nout.close();\n```\n\n　　Access-Control-Allow-Origin这个Header在W3C标准里用来检查该跨域请求是否可以被通过，如果值为*则表明当前页面可以跨域访问。默认的情况下是不允许的。\n　　在前端JS中需要向Servlet发出请求，请求代码如下所示：\n\n```javascript\n$.ajax({\n  url: \"your url\",\n  type:\"get or post\",\n  dataType:\"json\",\n  data:{\n    ....\n  },\n  success:function(data){\n    ...\n  }\n```\n\n## 第二种解决方法\n　　通过jsonp跨域请求的方式。JSONP和JSON虽然只有一个字母的区别，但是他们完全就是两回事，很多人很容易把他们搞混。JSON是一种数据交换的格式，而JSONP则是一种非官方跨域数据交互协议。\n　　首先来说一下前端JS是怎么发送请求。代码如下所示：\n\n```javascript\n$.ajax({\n  url:\"your url\",\n  type:\"get or post\",\n  async:false,\n  dataType : \"jsonp\",\n  //服务端用于接收callback调用的function名的参数\n  jsonp:\"callbackparam\",\n  //callback的function名称\n  jsonpCallback:\"success_jsonpCallback\",\n  success:function(data){\n    console.log(data);\n  },\n  error:function(data){\n    console.log(data);\n  }\n});\n```\n\n　　这里的callbackparam和success_jsonpCallback可以理解为发送的data数据的键值对，可以自定义，但是callbackparam需要和后台约定好参数名称，因为后台需要获取到这个参数里面的值（即success_jsonpCallback）。\n　　下面，最重要的来了，后台怎么样获取和返回数据呢。代码如下所示:\n\n```java\n  PrintWriter out =null;\n  String callback=req.getParameter(\"callbackparam\");\n  String json=callback+\"({'status':'ok'})\";\n  try\n  {\n    out = resp.getWriter();\n  } catch (IOException e)\n  {\n    // TODO Auto-generated catch block\n    e.printStackTrace();\n  }\n  out.print(json);\n  out.flush();\n  out.close();\n```\n\n　　首先需要获取参数名为callbackparam的值，这里获取到的值就是“success_jsonpCallback”。然后将这个值加上一对小括号。小括号里放入你需要返回的数据内容，比如这里我返回一个JSON对象。当然你也可以返回其他对象，比如只返回一个字符串类型数据也可以。最后前端JS返回的数据就是这样的：\n\n```java\nsuccess_jsonpCallback({'status':'ok'})\n```\n\n　　浏览器会自动解析为json对象，这时候你只需要在success回调函数中直接用data.status就可以了。\n\n\n\n\n\n","slug":"Java-Ajax","published":1,"updated":"2016-10-09T01:08:09.223Z","layout":"post","link":"","_id":"ciu99fu4m000rr8fijg3tteph","content":"<p>　　在写前端脚本的时候我们经常会遇到发送数据到后台的情况，但是由于浏览器的限制，不同域名之间的数据是不能互相访问的，那前端怎么和后端如何进行数据之间的交换呢？<br><a id=\"more\"></a></p>\n<p>　　JavaScript由于安全性方面的考虑，不允许页面跨域调用其他页面的对象，那么问题来了，什么是跨域问题？<br>答：这是由于浏览器同源策略的限制，现在所有支持JavaScript的浏览器都使用了这个策略。那么什么是同源呢？所谓的同源是指三个方面“相同”：</p>\n<ol>\n<li>域名相同</li>\n<li>协议相同</li>\n<li>端口相同</li>\n</ol>\n<p>下面就举几个例子来帮助更好的理解同源策略。</p>\n<table>\n<thead>\n<tr>\n<th>URL</th>\n<th>说明</th>\n<th>是否允许通信</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"http://www.a.com/a.js\" target=\"_blank\" rel=\"external\">http://www.a.com/a.js</a> <br> <a href=\"http://www.a.com/b.js\" target=\"_blank\" rel=\"external\">http://www.a.com/b.js</a></td>\n<td>同一域名</td>\n<td>允许</td>\n</tr>\n<tr>\n<td><a href=\"http://www.a.com/a.js\" target=\"_blank\" rel=\"external\">http://www.a.com/a.js</a> <br> <a href=\"http://www.b.com/a.js\" target=\"_blank\" rel=\"external\">http://www.b.com/a.js</a></td>\n<td>不同域名</td>\n<td>不允许</td>\n</tr>\n<tr>\n<td><a href=\"http://www.a.com:8000/a.js\" target=\"_blank\" rel=\"external\">http://www.a.com:8000/a.js</a><br><a href=\"http://www.a.com/b.js\" target=\"_blank\" rel=\"external\">http://www.a.com/b.js</a></td>\n<td>同一域名不同端口</td>\n<td>不允许</td>\n</tr>\n<tr>\n<td><a href=\"https://www.a.com/a.js\" target=\"_blank\" rel=\"external\">https://www.a.com/a.js</a> <br> <a href=\"http://www.a.com/b.js\" target=\"_blank\" rel=\"external\">http://www.a.com/b.js</a></td>\n<td>同一域名不同协议</td>\n<td>不允许</td>\n</tr>\n</tbody>\n</table>\n<p>　　在JAVA中处理跨域问题，通常有以下两种常用的解决方法。</p>\n<h2 id=\"第一种解决方法\"><a href=\"#第一种解决方法\" class=\"headerlink\" title=\"第一种解决方法\"></a>第一种解决方法</h2><p>　　后台代码在被请求的Servlet中添加Header设置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">response.setHeader(<span class=\"string\">\"Access-Control-Allow-Origin\"</span>, <span class=\"string\">\"*\"</span>);</div><div class=\"line\">PrintWriter out =<span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"keyword\">try</span></div><div class=\"line\">&#123;</div><div class=\"line\">\tout = response.getWriter();</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e)</div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"comment\">// TODO Auto-generated catch block</span></div><div class=\"line\">\te.printStackTrace();</div><div class=\"line\">&#125;</div><div class=\"line\">out.print(<span class=\"string\">\"&#123;'status':'ok'&#125;\"</span>);</div><div class=\"line\">out.flush();</div><div class=\"line\">out.close();</div></pre></td></tr></table></figure>\n<p>　　Access-Control-Allow-Origin这个Header在W3C标准里用来检查该跨域请求是否可以被通过，如果值为*则表明当前页面可以跨域访问。默认的情况下是不允许的。<br>　　在前端JS中需要向Servlet发出请求，请求代码如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">  url: <span class=\"string\">\"your url\"</span>,</div><div class=\"line\">  type:<span class=\"string\">\"get or post\"</span>,</div><div class=\"line\">  dataType:<span class=\"string\">\"json\"</span>,</div><div class=\"line\">  data:&#123;</div><div class=\"line\">    ....</div><div class=\"line\">  &#125;,</div><div class=\"line\">  success:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"第二种解决方法\"><a href=\"#第二种解决方法\" class=\"headerlink\" title=\"第二种解决方法\"></a>第二种解决方法</h2><p>　　通过jsonp跨域请求的方式。JSONP和JSON虽然只有一个字母的区别，但是他们完全就是两回事，很多人很容易把他们搞混。JSON是一种数据交换的格式，而JSONP则是一种非官方跨域数据交互协议。<br>　　首先来说一下前端JS是怎么发送请求。代码如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">  url:<span class=\"string\">\"your url\"</span>,</div><div class=\"line\">  type:<span class=\"string\">\"get or post\"</span>,</div><div class=\"line\">  <span class=\"keyword\">async</span>:<span class=\"literal\">false</span>,</div><div class=\"line\">  dataType : <span class=\"string\">\"jsonp\"</span>,</div><div class=\"line\">  <span class=\"comment\">//服务端用于接收callback调用的function名的参数</span></div><div class=\"line\">  jsonp:<span class=\"string\">\"callbackparam\"</span>,</div><div class=\"line\">  <span class=\"comment\">//callback的function名称</span></div><div class=\"line\">  jsonpCallback:<span class=\"string\">\"success_jsonpCallback\"</span>,</div><div class=\"line\">  success:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(data);</div><div class=\"line\">  &#125;,</div><div class=\"line\">  error:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(data);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>　　这里的callbackparam和success_jsonpCallback可以理解为发送的data数据的键值对，可以自定义，但是callbackparam需要和后台约定好参数名称，因为后台需要获取到这个参数里面的值（即success_jsonpCallback）。<br>　　下面，最重要的来了，后台怎么样获取和返回数据呢。代码如下所示:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">PrintWriter out =<span class=\"keyword\">null</span>;</div><div class=\"line\">String callback=req.getParameter(<span class=\"string\">\"callbackparam\"</span>);</div><div class=\"line\">String json=callback+<span class=\"string\">\"(&#123;'status':'ok'&#125;)\"</span>;</div><div class=\"line\"><span class=\"keyword\">try</span></div><div class=\"line\">&#123;</div><div class=\"line\">  out = resp.getWriter();</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e)</div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"comment\">// TODO Auto-generated catch block</span></div><div class=\"line\">  e.printStackTrace();</div><div class=\"line\">&#125;</div><div class=\"line\">out.print(json);</div><div class=\"line\">out.flush();</div><div class=\"line\">out.close();</div></pre></td></tr></table></figure>\n<p>　　首先需要获取参数名为callbackparam的值，这里获取到的值就是“success_jsonpCallback”。然后将这个值加上一对小括号。小括号里放入你需要返回的数据内容，比如这里我返回一个JSON对象。当然你也可以返回其他对象，比如只返回一个字符串类型数据也可以。最后前端JS返回的数据就是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">success_jsonpCallback(&#123;<span class=\"string\">'status'</span>:<span class=\"string\">'ok'</span>&#125;)</div></pre></td></tr></table></figure>\n<p>　　浏览器会自动解析为json对象，这时候你只需要在success回调函数中直接用data.status就可以了。</p>\n","excerpt":"<p>　　在写前端脚本的时候我们经常会遇到发送数据到后台的情况，但是由于浏览器的限制，不同域名之间的数据是不能互相访问的，那前端怎么和后端如何进行数据之间的交换呢？<br>","more":"</p>\n<p>　　JavaScript由于安全性方面的考虑，不允许页面跨域调用其他页面的对象，那么问题来了，什么是跨域问题？<br>答：这是由于浏览器同源策略的限制，现在所有支持JavaScript的浏览器都使用了这个策略。那么什么是同源呢？所谓的同源是指三个方面“相同”：</p>\n<ol>\n<li>域名相同</li>\n<li>协议相同</li>\n<li>端口相同</li>\n</ol>\n<p>下面就举几个例子来帮助更好的理解同源策略。</p>\n<table>\n<thead>\n<tr>\n<th>URL</th>\n<th>说明</th>\n<th>是否允许通信</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"http://www.a.com/a.js\">http://www.a.com/a.js</a> <br> <a href=\"http://www.a.com/b.js\">http://www.a.com/b.js</a></td>\n<td>同一域名</td>\n<td>允许</td>\n</tr>\n<tr>\n<td><a href=\"http://www.a.com/a.js\">http://www.a.com/a.js</a> <br> <a href=\"http://www.b.com/a.js\">http://www.b.com/a.js</a></td>\n<td>不同域名</td>\n<td>不允许</td>\n</tr>\n<tr>\n<td><a href=\"http://www.a.com:8000/a.js\">http://www.a.com:8000/a.js</a><br><a href=\"http://www.a.com/b.js\">http://www.a.com/b.js</a></td>\n<td>同一域名不同端口</td>\n<td>不允许</td>\n</tr>\n<tr>\n<td><a href=\"https://www.a.com/a.js\">https://www.a.com/a.js</a> <br> <a href=\"http://www.a.com/b.js\">http://www.a.com/b.js</a></td>\n<td>同一域名不同协议</td>\n<td>不允许</td>\n</tr>\n</tbody>\n</table>\n<p>　　在JAVA中处理跨域问题，通常有以下两种常用的解决方法。</p>\n<h2 id=\"第一种解决方法\"><a href=\"#第一种解决方法\" class=\"headerlink\" title=\"第一种解决方法\"></a>第一种解决方法</h2><p>　　后台代码在被请求的Servlet中添加Header设置：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">response.setHeader(<span class=\"string\">\"Access-Control-Allow-Origin\"</span>, <span class=\"string\">\"*\"</span>);</div><div class=\"line\">PrintWriter out =<span class=\"keyword\">null</span>;</div><div class=\"line\"><span class=\"keyword\">try</span></div><div class=\"line\">&#123;</div><div class=\"line\">\tout = response.getWriter();</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e)</div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"comment\">// TODO Auto-generated catch block</span></div><div class=\"line\">\te.printStackTrace();</div><div class=\"line\">&#125;</div><div class=\"line\">out.print(<span class=\"string\">\"&#123;'status':'ok'&#125;\"</span>);</div><div class=\"line\">out.flush();</div><div class=\"line\">out.close();</div></pre></td></tr></table></figure>\n<p>　　Access-Control-Allow-Origin这个Header在W3C标准里用来检查该跨域请求是否可以被通过，如果值为*则表明当前页面可以跨域访问。默认的情况下是不允许的。<br>　　在前端JS中需要向Servlet发出请求，请求代码如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">  url: <span class=\"string\">\"your url\"</span>,</div><div class=\"line\">  type:<span class=\"string\">\"get or post\"</span>,</div><div class=\"line\">  dataType:<span class=\"string\">\"json\"</span>,</div><div class=\"line\">  data:&#123;</div><div class=\"line\">    ....</div><div class=\"line\">  &#125;,</div><div class=\"line\">  success:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"第二种解决方法\"><a href=\"#第二种解决方法\" class=\"headerlink\" title=\"第二种解决方法\"></a>第二种解决方法</h2><p>　　通过jsonp跨域请求的方式。JSONP和JSON虽然只有一个字母的区别，但是他们完全就是两回事，很多人很容易把他们搞混。JSON是一种数据交换的格式，而JSONP则是一种非官方跨域数据交互协议。<br>　　首先来说一下前端JS是怎么发送请求。代码如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">$.ajax(&#123;</div><div class=\"line\">  url:<span class=\"string\">\"your url\"</span>,</div><div class=\"line\">  type:<span class=\"string\">\"get or post\"</span>,</div><div class=\"line\">  <span class=\"keyword\">async</span>:<span class=\"literal\">false</span>,</div><div class=\"line\">  dataType : <span class=\"string\">\"jsonp\"</span>,</div><div class=\"line\">  <span class=\"comment\">//服务端用于接收callback调用的function名的参数</span></div><div class=\"line\">  jsonp:<span class=\"string\">\"callbackparam\"</span>,</div><div class=\"line\">  <span class=\"comment\">//callback的function名称</span></div><div class=\"line\">  jsonpCallback:<span class=\"string\">\"success_jsonpCallback\"</span>,</div><div class=\"line\">  success:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(data);</div><div class=\"line\">  &#125;,</div><div class=\"line\">  error:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(data);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>　　这里的callbackparam和success_jsonpCallback可以理解为发送的data数据的键值对，可以自定义，但是callbackparam需要和后台约定好参数名称，因为后台需要获取到这个参数里面的值（即success_jsonpCallback）。<br>　　下面，最重要的来了，后台怎么样获取和返回数据呢。代码如下所示:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">PrintWriter out =<span class=\"keyword\">null</span>;</div><div class=\"line\">String callback=req.getParameter(<span class=\"string\">\"callbackparam\"</span>);</div><div class=\"line\">String json=callback+<span class=\"string\">\"(&#123;'status':'ok'&#125;)\"</span>;</div><div class=\"line\"><span class=\"keyword\">try</span></div><div class=\"line\">&#123;</div><div class=\"line\">  out = resp.getWriter();</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e)</div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"comment\">// TODO Auto-generated catch block</span></div><div class=\"line\">  e.printStackTrace();</div><div class=\"line\">&#125;</div><div class=\"line\">out.print(json);</div><div class=\"line\">out.flush();</div><div class=\"line\">out.close();</div></pre></td></tr></table></figure>\n<p>　　首先需要获取参数名为callbackparam的值，这里获取到的值就是“success_jsonpCallback”。然后将这个值加上一对小括号。小括号里放入你需要返回的数据内容，比如这里我返回一个JSON对象。当然你也可以返回其他对象，比如只返回一个字符串类型数据也可以。最后前端JS返回的数据就是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">success_jsonpCallback(&#123;<span class=\"string\">'status'</span>:<span class=\"string\">'ok'</span>&#125;)</div></pre></td></tr></table></figure>\n<p>　　浏览器会自动解析为json对象，这时候你只需要在success回调函数中直接用data.status就可以了。</p>"},{"title":"Windows程序员必备小工具推荐","date":"2016-09-16T00:49:40.000Z","description":null,"toc":null,"author":"Corner","comments":1,"original":null,"photos":[],"_content":"　　作为一个程序猿，有一个好的撸码工具肯定会让你的效率成倍的提升。这篇文章总结了自笔者工作以来用过的比较好的提升效率的Windows下的小工具，推荐给大家来用(非广告)，这些小工具不仅仅是撸码的，还有其他的一些软件。\n<!-- more -->\n\n> 工欲善其事，必先利其器\n\n　　“工”是指的工作，一件事情要想做好，必定先要让工具“锋利”。\n\n# 撸码神器Sublime Text\n## 推荐指数★★★★★\n\n　　Sublime是我用过的最好的撸码神器，没有之一。那些撸码还在用什么EditPlus、DreamWeaver的，和Sublime比，简直就是拿石器时代的石器武器和二十一世纪的大规模杀伤性武器做比较。Sublime拥有漂亮的用户界面和无比强大的功能，例如代码的缩略图、自定义按键绑定、拼写检查、项目切换、多窗口等等。Sublime的界面如下：\n\n![Sublime界面](/images/Windows-Tools-Recommend/Sublime-UI.png)\n\n　　Sublime还能支持多种编程语言的语法高亮，有优秀的代码自动补全的功能。而且Sublime还有非常强大的插件系统作为其功能的补充。一些常见和实用的插件如Emmet(快速编写 HTML/CSS 代码的方案)、ColorPicker(颜色选择器)、MarkdownPreview(markdown预览)、DocBlockr(代码注释规范)、SideBar(侧边栏工具)等等，其他一些强大的插件等待读者去体验。\n\n\n# 小孩桌面便签\n## 推荐指数★★★☆☆\n\n　　大家在上学的时候肯定都用过便签纸一类的东西来记一些上课笔记之类的东西，然后贴在课本上，整个课本就贴的花花绿绿的。小孩桌面便签就是这样一个在桌面上贴上便签的工具。正如它的名字一样：DeskNotes(桌面贴纸)。\n\n　　这是我一个女同事推荐我使用的，刚开始我还很不屑的，没怎么用。后来随着工作越来越多，渐渐的发现......脑子越来越不够用了。然后我就把这个工具用起来了，确实能够提醒我很多事情。它的界面如下：\n\n![小孩桌面便签界面](/images/Windows-Tools-Recommend/DesktopNotes.jpg)\n\n　　除了能够添加贴纸外，小孩便签还增加了实用的小功能，如闹钟提醒和定时关机。\n\n# FastStone Capture\n## 推荐指数★★☆☆☆\n\n　　由于笔者从事网页的工作，经常要和图片打交道，所以经常需要截图、取色、测量像素等等。这是笔者在上学时一个老师推荐的软件，基本能够解决上述需求。FastStone Capture的界面如下：\n\n![FastStone Capture](/images/Windows-Tools-Recommend/FastStone-Capture.png)\n\n　　很多读者可能会说：那你用PhotoShop啊，功能更强悍。诚然，PhotoShop功能确实相当的强悍，笔者的电脑里也装了，但是体积大，而且又十分的吃内存，每次打开都要耗不少时间(估计是电脑太老了)。\n\n　　相比于PhotoShop，FastStone Capture就轻巧了不少。整个软件的大小不超过3MB，通过任务管理器看到所占用的内存仅0.3MB，基本上可以忽略不计，每次打开基本上都是秒开的。\n\n　　它的主要功能有截图、屏幕录像、图像处理(裁切，改变图像效果等)。附带的特色小功能有屏幕放大器、屏幕取色器、屏幕标尺、图像转为PDF，功能可是非常的强大。\n\n\n# 有道云笔记\n## 推荐指数★★☆☆☆\n\n　　有的读者可能会说：欸，上面不是有小孩桌面便签可以用来记事了么，怎么还要有道云笔记呢。诚然，便签是可以记录生活中的琐事，但是要想把记录的内容从一台电脑转移到另一台电脑却比较费时。\n\n　　笔者的所处的环境就是需要在多个地点记录，比如上班的时候看到有用的东西需要记录下来，下班在家里做一些学习笔记也需要记录下来，虽然小孩桌面便签有强大的导入导出功能，但是频繁的导入导出操作也是比较麻烦的，或许是笔者比较懒。\n\n![有道云笔记](/images/Windows-Tools-Recommend/YNote.png)\n\n　　这个时候使用有道云笔记就可以很方便的在“云上”进行办公，而且还支持Android、iPhone、iPad、Mac、WP和web等平台，让工作摆脱了平台和设备的限制。有道云笔记还支持多种编辑格式，可以用富文本进行编辑也可以采用Markdown语法进行编辑，Markdown支持有预览的功能。读者还可以将写的文章比较好的文章在微博、微信和扣扣中进行分享。\n\n# Beyond Compare\n## 推荐指数★★★★☆\n\n　　在工作和生活中，笔者经常会将文件添加上版本号以区分，但是时间一长，就会忘记不同的版本号所更改的内容，所以经常需要一一地比对，这就让笔者很苦恼。有一天在上网时无意中发现了这款“神器”，让我们来看看它长什么样：\n\n![Beyond Compare](/images/Windows-Tools-Recommend/Beyond-Compare.png)\n\n　　Beyond Compare主要用途是对比两个文件夹或者文件的不同，并将差异 通过颜色的不同以标识。对的，你没有看错，就是文件夹的不同。它还可以按照你的需要进行比较，比如需要对比文件的不同或者对比文件的相同，都可以显示。\n\n\n# Everything\n## 推荐指数★★★★★\n\n　　由于笔者的每天工作都会收到很多不同文件，但是笔者又不善于对文件归类存放，都是杂乱的放在桌面，需要用到的时候找起来又相当的麻烦。这时候Everything这款文件快速搜索软件就成为我们这种“懒人”的福音了。他的界面如下：\n\n![Everything](/images/Windows-Tools-Recommend/everything.png)\n\n　　它的体积也相当的轻巧，才30多MB，和现在动辄几百MB的软件相比确实小了很多；它的界面也很简洁易用，常用的就一个输入框和下面的文件列表，非常方便日常的使用；占用系统资源极低，Everything搜索只基于文件和文件夹的名称，所以建立起搜索数据库非常的快，搜索文件基本上都是秒搜。\n\n# Chrome\n## 推荐指数★★★★★\n\n　　Chrome是笔者用过最好用的浏览器，没有之一。不管是日常生活中的使用还是开发中的测试等，Chrome都能够轻松胜任。\n\n![Chrome](/images/Windows-Tools-Recommend/chrome.jpg)\n\n　　Chrome的特点是简洁、快速。它支持多个标签进行浏览，即使有一个标签崩溃，其他标签页不会崩溃。而且，Chrome是基于V8 JavaScript引擎的，页面性能更加优异。\n\n　　对于像笔者一样的网页开发者来说，Chrome更是开发网页的“利器”。使用F12调出控制台，在这里你能看到Elements(页面元素)、Console(网页运行的提示消息)、Sources(页面运行所加载的源码)、Resources(页面所需要的文件、存储的cookie和session等资源)、Network(可以看到网页加载脚本样式页面的时间还有异步的资源)\n\n","source":"_posts/Windows-Tools-Recommend.md","raw":"title: Windows程序员必备小工具推荐\ndate: 2016-09-16 08:49:40\ndescription:\ncategories:\n- 工具\ntags:\n- 推荐\ntoc:\nauthor: Corner\ncomments:\noriginal:\npermalink:\nphotos:\n---\n　　作为一个程序猿，有一个好的撸码工具肯定会让你的效率成倍的提升。这篇文章总结了自笔者工作以来用过的比较好的提升效率的Windows下的小工具，推荐给大家来用(非广告)，这些小工具不仅仅是撸码的，还有其他的一些软件。\n<!-- more -->\n\n> 工欲善其事，必先利其器\n\n　　“工”是指的工作，一件事情要想做好，必定先要让工具“锋利”。\n\n# 撸码神器Sublime Text\n## 推荐指数★★★★★\n\n　　Sublime是我用过的最好的撸码神器，没有之一。那些撸码还在用什么EditPlus、DreamWeaver的，和Sublime比，简直就是拿石器时代的石器武器和二十一世纪的大规模杀伤性武器做比较。Sublime拥有漂亮的用户界面和无比强大的功能，例如代码的缩略图、自定义按键绑定、拼写检查、项目切换、多窗口等等。Sublime的界面如下：\n\n![Sublime界面](/images/Windows-Tools-Recommend/Sublime-UI.png)\n\n　　Sublime还能支持多种编程语言的语法高亮，有优秀的代码自动补全的功能。而且Sublime还有非常强大的插件系统作为其功能的补充。一些常见和实用的插件如Emmet(快速编写 HTML/CSS 代码的方案)、ColorPicker(颜色选择器)、MarkdownPreview(markdown预览)、DocBlockr(代码注释规范)、SideBar(侧边栏工具)等等，其他一些强大的插件等待读者去体验。\n\n\n# 小孩桌面便签\n## 推荐指数★★★☆☆\n\n　　大家在上学的时候肯定都用过便签纸一类的东西来记一些上课笔记之类的东西，然后贴在课本上，整个课本就贴的花花绿绿的。小孩桌面便签就是这样一个在桌面上贴上便签的工具。正如它的名字一样：DeskNotes(桌面贴纸)。\n\n　　这是我一个女同事推荐我使用的，刚开始我还很不屑的，没怎么用。后来随着工作越来越多，渐渐的发现......脑子越来越不够用了。然后我就把这个工具用起来了，确实能够提醒我很多事情。它的界面如下：\n\n![小孩桌面便签界面](/images/Windows-Tools-Recommend/DesktopNotes.jpg)\n\n　　除了能够添加贴纸外，小孩便签还增加了实用的小功能，如闹钟提醒和定时关机。\n\n# FastStone Capture\n## 推荐指数★★☆☆☆\n\n　　由于笔者从事网页的工作，经常要和图片打交道，所以经常需要截图、取色、测量像素等等。这是笔者在上学时一个老师推荐的软件，基本能够解决上述需求。FastStone Capture的界面如下：\n\n![FastStone Capture](/images/Windows-Tools-Recommend/FastStone-Capture.png)\n\n　　很多读者可能会说：那你用PhotoShop啊，功能更强悍。诚然，PhotoShop功能确实相当的强悍，笔者的电脑里也装了，但是体积大，而且又十分的吃内存，每次打开都要耗不少时间(估计是电脑太老了)。\n\n　　相比于PhotoShop，FastStone Capture就轻巧了不少。整个软件的大小不超过3MB，通过任务管理器看到所占用的内存仅0.3MB，基本上可以忽略不计，每次打开基本上都是秒开的。\n\n　　它的主要功能有截图、屏幕录像、图像处理(裁切，改变图像效果等)。附带的特色小功能有屏幕放大器、屏幕取色器、屏幕标尺、图像转为PDF，功能可是非常的强大。\n\n\n# 有道云笔记\n## 推荐指数★★☆☆☆\n\n　　有的读者可能会说：欸，上面不是有小孩桌面便签可以用来记事了么，怎么还要有道云笔记呢。诚然，便签是可以记录生活中的琐事，但是要想把记录的内容从一台电脑转移到另一台电脑却比较费时。\n\n　　笔者的所处的环境就是需要在多个地点记录，比如上班的时候看到有用的东西需要记录下来，下班在家里做一些学习笔记也需要记录下来，虽然小孩桌面便签有强大的导入导出功能，但是频繁的导入导出操作也是比较麻烦的，或许是笔者比较懒。\n\n![有道云笔记](/images/Windows-Tools-Recommend/YNote.png)\n\n　　这个时候使用有道云笔记就可以很方便的在“云上”进行办公，而且还支持Android、iPhone、iPad、Mac、WP和web等平台，让工作摆脱了平台和设备的限制。有道云笔记还支持多种编辑格式，可以用富文本进行编辑也可以采用Markdown语法进行编辑，Markdown支持有预览的功能。读者还可以将写的文章比较好的文章在微博、微信和扣扣中进行分享。\n\n# Beyond Compare\n## 推荐指数★★★★☆\n\n　　在工作和生活中，笔者经常会将文件添加上版本号以区分，但是时间一长，就会忘记不同的版本号所更改的内容，所以经常需要一一地比对，这就让笔者很苦恼。有一天在上网时无意中发现了这款“神器”，让我们来看看它长什么样：\n\n![Beyond Compare](/images/Windows-Tools-Recommend/Beyond-Compare.png)\n\n　　Beyond Compare主要用途是对比两个文件夹或者文件的不同，并将差异 通过颜色的不同以标识。对的，你没有看错，就是文件夹的不同。它还可以按照你的需要进行比较，比如需要对比文件的不同或者对比文件的相同，都可以显示。\n\n\n# Everything\n## 推荐指数★★★★★\n\n　　由于笔者的每天工作都会收到很多不同文件，但是笔者又不善于对文件归类存放，都是杂乱的放在桌面，需要用到的时候找起来又相当的麻烦。这时候Everything这款文件快速搜索软件就成为我们这种“懒人”的福音了。他的界面如下：\n\n![Everything](/images/Windows-Tools-Recommend/everything.png)\n\n　　它的体积也相当的轻巧，才30多MB，和现在动辄几百MB的软件相比确实小了很多；它的界面也很简洁易用，常用的就一个输入框和下面的文件列表，非常方便日常的使用；占用系统资源极低，Everything搜索只基于文件和文件夹的名称，所以建立起搜索数据库非常的快，搜索文件基本上都是秒搜。\n\n# Chrome\n## 推荐指数★★★★★\n\n　　Chrome是笔者用过最好用的浏览器，没有之一。不管是日常生活中的使用还是开发中的测试等，Chrome都能够轻松胜任。\n\n![Chrome](/images/Windows-Tools-Recommend/chrome.jpg)\n\n　　Chrome的特点是简洁、快速。它支持多个标签进行浏览，即使有一个标签崩溃，其他标签页不会崩溃。而且，Chrome是基于V8 JavaScript引擎的，页面性能更加优异。\n\n　　对于像笔者一样的网页开发者来说，Chrome更是开发网页的“利器”。使用F12调出控制台，在这里你能看到Elements(页面元素)、Console(网页运行的提示消息)、Sources(页面运行所加载的源码)、Resources(页面所需要的文件、存储的cookie和session等资源)、Network(可以看到网页加载脚本样式页面的时间还有异步的资源)\n\n","slug":"Windows-Tools-Recommend","published":1,"updated":"2016-10-09T01:08:09.223Z","layout":"post","link":"","_id":"ciu99fu4q000tr8fikwob6tr0","content":"<p>　　作为一个程序猿，有一个好的撸码工具肯定会让你的效率成倍的提升。这篇文章总结了自笔者工作以来用过的比较好的提升效率的Windows下的小工具，推荐给大家来用(非广告)，这些小工具不仅仅是撸码的，还有其他的一些软件。<br><a id=\"more\"></a></p>\n<blockquote>\n<p>工欲善其事，必先利其器</p>\n</blockquote>\n<p>　　“工”是指的工作，一件事情要想做好，必定先要让工具“锋利”。</p>\n<h1 id=\"撸码神器Sublime-Text\"><a href=\"#撸码神器Sublime-Text\" class=\"headerlink\" title=\"撸码神器Sublime Text\"></a>撸码神器Sublime Text</h1><h2 id=\"推荐指数★★★★★\"><a href=\"#推荐指数★★★★★\" class=\"headerlink\" title=\"推荐指数★★★★★\"></a>推荐指数★★★★★</h2><p>　　Sublime是我用过的最好的撸码神器，没有之一。那些撸码还在用什么EditPlus、DreamWeaver的，和Sublime比，简直就是拿石器时代的石器武器和二十一世纪的大规模杀伤性武器做比较。Sublime拥有漂亮的用户界面和无比强大的功能，例如代码的缩略图、自定义按键绑定、拼写检查、项目切换、多窗口等等。Sublime的界面如下：</p>\n<p><img src=\"/images/Windows-Tools-Recommend/Sublime-UI.png\" alt=\"Sublime界面\"></p>\n<p>　　Sublime还能支持多种编程语言的语法高亮，有优秀的代码自动补全的功能。而且Sublime还有非常强大的插件系统作为其功能的补充。一些常见和实用的插件如Emmet(快速编写 HTML/CSS 代码的方案)、ColorPicker(颜色选择器)、MarkdownPreview(markdown预览)、DocBlockr(代码注释规范)、SideBar(侧边栏工具)等等，其他一些强大的插件等待读者去体验。</p>\n<h1 id=\"小孩桌面便签\"><a href=\"#小孩桌面便签\" class=\"headerlink\" title=\"小孩桌面便签\"></a>小孩桌面便签</h1><h2 id=\"推荐指数★★★☆☆\"><a href=\"#推荐指数★★★☆☆\" class=\"headerlink\" title=\"推荐指数★★★☆☆\"></a>推荐指数★★★☆☆</h2><p>　　大家在上学的时候肯定都用过便签纸一类的东西来记一些上课笔记之类的东西，然后贴在课本上，整个课本就贴的花花绿绿的。小孩桌面便签就是这样一个在桌面上贴上便签的工具。正如它的名字一样：DeskNotes(桌面贴纸)。</p>\n<p>　　这是我一个女同事推荐我使用的，刚开始我还很不屑的，没怎么用。后来随着工作越来越多，渐渐的发现……脑子越来越不够用了。然后我就把这个工具用起来了，确实能够提醒我很多事情。它的界面如下：</p>\n<p><img src=\"/images/Windows-Tools-Recommend/DesktopNotes.jpg\" alt=\"小孩桌面便签界面\"></p>\n<p>　　除了能够添加贴纸外，小孩便签还增加了实用的小功能，如闹钟提醒和定时关机。</p>\n<h1 id=\"FastStone-Capture\"><a href=\"#FastStone-Capture\" class=\"headerlink\" title=\"FastStone Capture\"></a>FastStone Capture</h1><h2 id=\"推荐指数★★☆☆☆\"><a href=\"#推荐指数★★☆☆☆\" class=\"headerlink\" title=\"推荐指数★★☆☆☆\"></a>推荐指数★★☆☆☆</h2><p>　　由于笔者从事网页的工作，经常要和图片打交道，所以经常需要截图、取色、测量像素等等。这是笔者在上学时一个老师推荐的软件，基本能够解决上述需求。FastStone Capture的界面如下：</p>\n<p><img src=\"/images/Windows-Tools-Recommend/FastStone-Capture.png\" alt=\"FastStone Capture\"></p>\n<p>　　很多读者可能会说：那你用PhotoShop啊，功能更强悍。诚然，PhotoShop功能确实相当的强悍，笔者的电脑里也装了，但是体积大，而且又十分的吃内存，每次打开都要耗不少时间(估计是电脑太老了)。</p>\n<p>　　相比于PhotoShop，FastStone Capture就轻巧了不少。整个软件的大小不超过3MB，通过任务管理器看到所占用的内存仅0.3MB，基本上可以忽略不计，每次打开基本上都是秒开的。</p>\n<p>　　它的主要功能有截图、屏幕录像、图像处理(裁切，改变图像效果等)。附带的特色小功能有屏幕放大器、屏幕取色器、屏幕标尺、图像转为PDF，功能可是非常的强大。</p>\n<h1 id=\"有道云笔记\"><a href=\"#有道云笔记\" class=\"headerlink\" title=\"有道云笔记\"></a>有道云笔记</h1><h2 id=\"推荐指数★★☆☆☆-1\"><a href=\"#推荐指数★★☆☆☆-1\" class=\"headerlink\" title=\"推荐指数★★☆☆☆\"></a>推荐指数★★☆☆☆</h2><p>　　有的读者可能会说：欸，上面不是有小孩桌面便签可以用来记事了么，怎么还要有道云笔记呢。诚然，便签是可以记录生活中的琐事，但是要想把记录的内容从一台电脑转移到另一台电脑却比较费时。</p>\n<p>　　笔者的所处的环境就是需要在多个地点记录，比如上班的时候看到有用的东西需要记录下来，下班在家里做一些学习笔记也需要记录下来，虽然小孩桌面便签有强大的导入导出功能，但是频繁的导入导出操作也是比较麻烦的，或许是笔者比较懒。</p>\n<p><img src=\"/images/Windows-Tools-Recommend/YNote.png\" alt=\"有道云笔记\"></p>\n<p>　　这个时候使用有道云笔记就可以很方便的在“云上”进行办公，而且还支持Android、iPhone、iPad、Mac、WP和web等平台，让工作摆脱了平台和设备的限制。有道云笔记还支持多种编辑格式，可以用富文本进行编辑也可以采用Markdown语法进行编辑，Markdown支持有预览的功能。读者还可以将写的文章比较好的文章在微博、微信和扣扣中进行分享。</p>\n<h1 id=\"Beyond-Compare\"><a href=\"#Beyond-Compare\" class=\"headerlink\" title=\"Beyond Compare\"></a>Beyond Compare</h1><h2 id=\"推荐指数★★★★☆\"><a href=\"#推荐指数★★★★☆\" class=\"headerlink\" title=\"推荐指数★★★★☆\"></a>推荐指数★★★★☆</h2><p>　　在工作和生活中，笔者经常会将文件添加上版本号以区分，但是时间一长，就会忘记不同的版本号所更改的内容，所以经常需要一一地比对，这就让笔者很苦恼。有一天在上网时无意中发现了这款“神器”，让我们来看看它长什么样：</p>\n<p><img src=\"/images/Windows-Tools-Recommend/Beyond-Compare.png\" alt=\"Beyond Compare\"></p>\n<p>　　Beyond Compare主要用途是对比两个文件夹或者文件的不同，并将差异 通过颜色的不同以标识。对的，你没有看错，就是文件夹的不同。它还可以按照你的需要进行比较，比如需要对比文件的不同或者对比文件的相同，都可以显示。</p>\n<h1 id=\"Everything\"><a href=\"#Everything\" class=\"headerlink\" title=\"Everything\"></a>Everything</h1><h2 id=\"推荐指数★★★★★-1\"><a href=\"#推荐指数★★★★★-1\" class=\"headerlink\" title=\"推荐指数★★★★★\"></a>推荐指数★★★★★</h2><p>　　由于笔者的每天工作都会收到很多不同文件，但是笔者又不善于对文件归类存放，都是杂乱的放在桌面，需要用到的时候找起来又相当的麻烦。这时候Everything这款文件快速搜索软件就成为我们这种“懒人”的福音了。他的界面如下：</p>\n<p><img src=\"/images/Windows-Tools-Recommend/everything.png\" alt=\"Everything\"></p>\n<p>　　它的体积也相当的轻巧，才30多MB，和现在动辄几百MB的软件相比确实小了很多；它的界面也很简洁易用，常用的就一个输入框和下面的文件列表，非常方便日常的使用；占用系统资源极低，Everything搜索只基于文件和文件夹的名称，所以建立起搜索数据库非常的快，搜索文件基本上都是秒搜。</p>\n<h1 id=\"Chrome\"><a href=\"#Chrome\" class=\"headerlink\" title=\"Chrome\"></a>Chrome</h1><h2 id=\"推荐指数★★★★★-2\"><a href=\"#推荐指数★★★★★-2\" class=\"headerlink\" title=\"推荐指数★★★★★\"></a>推荐指数★★★★★</h2><p>　　Chrome是笔者用过最好用的浏览器，没有之一。不管是日常生活中的使用还是开发中的测试等，Chrome都能够轻松胜任。</p>\n<p><img src=\"/images/Windows-Tools-Recommend/chrome.jpg\" alt=\"Chrome\"></p>\n<p>　　Chrome的特点是简洁、快速。它支持多个标签进行浏览，即使有一个标签崩溃，其他标签页不会崩溃。而且，Chrome是基于V8 JavaScript引擎的，页面性能更加优异。</p>\n<p>　　对于像笔者一样的网页开发者来说，Chrome更是开发网页的“利器”。使用F12调出控制台，在这里你能看到Elements(页面元素)、Console(网页运行的提示消息)、Sources(页面运行所加载的源码)、Resources(页面所需要的文件、存储的cookie和session等资源)、Network(可以看到网页加载脚本样式页面的时间还有异步的资源)</p>\n","excerpt":"<p>　　作为一个程序猿，有一个好的撸码工具肯定会让你的效率成倍的提升。这篇文章总结了自笔者工作以来用过的比较好的提升效率的Windows下的小工具，推荐给大家来用(非广告)，这些小工具不仅仅是撸码的，还有其他的一些软件。<br>","more":"</p>\n<blockquote>\n<p>工欲善其事，必先利其器</p>\n</blockquote>\n<p>　　“工”是指的工作，一件事情要想做好，必定先要让工具“锋利”。</p>\n<h1 id=\"撸码神器Sublime-Text\"><a href=\"#撸码神器Sublime-Text\" class=\"headerlink\" title=\"撸码神器Sublime Text\"></a>撸码神器Sublime Text</h1><h2 id=\"推荐指数★★★★★\"><a href=\"#推荐指数★★★★★\" class=\"headerlink\" title=\"推荐指数★★★★★\"></a>推荐指数★★★★★</h2><p>　　Sublime是我用过的最好的撸码神器，没有之一。那些撸码还在用什么EditPlus、DreamWeaver的，和Sublime比，简直就是拿石器时代的石器武器和二十一世纪的大规模杀伤性武器做比较。Sublime拥有漂亮的用户界面和无比强大的功能，例如代码的缩略图、自定义按键绑定、拼写检查、项目切换、多窗口等等。Sublime的界面如下：</p>\n<p><img src=\"/images/Windows-Tools-Recommend/Sublime-UI.png\" alt=\"Sublime界面\"></p>\n<p>　　Sublime还能支持多种编程语言的语法高亮，有优秀的代码自动补全的功能。而且Sublime还有非常强大的插件系统作为其功能的补充。一些常见和实用的插件如Emmet(快速编写 HTML/CSS 代码的方案)、ColorPicker(颜色选择器)、MarkdownPreview(markdown预览)、DocBlockr(代码注释规范)、SideBar(侧边栏工具)等等，其他一些强大的插件等待读者去体验。</p>\n<h1 id=\"小孩桌面便签\"><a href=\"#小孩桌面便签\" class=\"headerlink\" title=\"小孩桌面便签\"></a>小孩桌面便签</h1><h2 id=\"推荐指数★★★☆☆\"><a href=\"#推荐指数★★★☆☆\" class=\"headerlink\" title=\"推荐指数★★★☆☆\"></a>推荐指数★★★☆☆</h2><p>　　大家在上学的时候肯定都用过便签纸一类的东西来记一些上课笔记之类的东西，然后贴在课本上，整个课本就贴的花花绿绿的。小孩桌面便签就是这样一个在桌面上贴上便签的工具。正如它的名字一样：DeskNotes(桌面贴纸)。</p>\n<p>　　这是我一个女同事推荐我使用的，刚开始我还很不屑的，没怎么用。后来随着工作越来越多，渐渐的发现……脑子越来越不够用了。然后我就把这个工具用起来了，确实能够提醒我很多事情。它的界面如下：</p>\n<p><img src=\"/images/Windows-Tools-Recommend/DesktopNotes.jpg\" alt=\"小孩桌面便签界面\"></p>\n<p>　　除了能够添加贴纸外，小孩便签还增加了实用的小功能，如闹钟提醒和定时关机。</p>\n<h1 id=\"FastStone-Capture\"><a href=\"#FastStone-Capture\" class=\"headerlink\" title=\"FastStone Capture\"></a>FastStone Capture</h1><h2 id=\"推荐指数★★☆☆☆\"><a href=\"#推荐指数★★☆☆☆\" class=\"headerlink\" title=\"推荐指数★★☆☆☆\"></a>推荐指数★★☆☆☆</h2><p>　　由于笔者从事网页的工作，经常要和图片打交道，所以经常需要截图、取色、测量像素等等。这是笔者在上学时一个老师推荐的软件，基本能够解决上述需求。FastStone Capture的界面如下：</p>\n<p><img src=\"/images/Windows-Tools-Recommend/FastStone-Capture.png\" alt=\"FastStone Capture\"></p>\n<p>　　很多读者可能会说：那你用PhotoShop啊，功能更强悍。诚然，PhotoShop功能确实相当的强悍，笔者的电脑里也装了，但是体积大，而且又十分的吃内存，每次打开都要耗不少时间(估计是电脑太老了)。</p>\n<p>　　相比于PhotoShop，FastStone Capture就轻巧了不少。整个软件的大小不超过3MB，通过任务管理器看到所占用的内存仅0.3MB，基本上可以忽略不计，每次打开基本上都是秒开的。</p>\n<p>　　它的主要功能有截图、屏幕录像、图像处理(裁切，改变图像效果等)。附带的特色小功能有屏幕放大器、屏幕取色器、屏幕标尺、图像转为PDF，功能可是非常的强大。</p>\n<h1 id=\"有道云笔记\"><a href=\"#有道云笔记\" class=\"headerlink\" title=\"有道云笔记\"></a>有道云笔记</h1><h2 id=\"推荐指数★★☆☆☆-1\"><a href=\"#推荐指数★★☆☆☆-1\" class=\"headerlink\" title=\"推荐指数★★☆☆☆\"></a>推荐指数★★☆☆☆</h2><p>　　有的读者可能会说：欸，上面不是有小孩桌面便签可以用来记事了么，怎么还要有道云笔记呢。诚然，便签是可以记录生活中的琐事，但是要想把记录的内容从一台电脑转移到另一台电脑却比较费时。</p>\n<p>　　笔者的所处的环境就是需要在多个地点记录，比如上班的时候看到有用的东西需要记录下来，下班在家里做一些学习笔记也需要记录下来，虽然小孩桌面便签有强大的导入导出功能，但是频繁的导入导出操作也是比较麻烦的，或许是笔者比较懒。</p>\n<p><img src=\"/images/Windows-Tools-Recommend/YNote.png\" alt=\"有道云笔记\"></p>\n<p>　　这个时候使用有道云笔记就可以很方便的在“云上”进行办公，而且还支持Android、iPhone、iPad、Mac、WP和web等平台，让工作摆脱了平台和设备的限制。有道云笔记还支持多种编辑格式，可以用富文本进行编辑也可以采用Markdown语法进行编辑，Markdown支持有预览的功能。读者还可以将写的文章比较好的文章在微博、微信和扣扣中进行分享。</p>\n<h1 id=\"Beyond-Compare\"><a href=\"#Beyond-Compare\" class=\"headerlink\" title=\"Beyond Compare\"></a>Beyond Compare</h1><h2 id=\"推荐指数★★★★☆\"><a href=\"#推荐指数★★★★☆\" class=\"headerlink\" title=\"推荐指数★★★★☆\"></a>推荐指数★★★★☆</h2><p>　　在工作和生活中，笔者经常会将文件添加上版本号以区分，但是时间一长，就会忘记不同的版本号所更改的内容，所以经常需要一一地比对，这就让笔者很苦恼。有一天在上网时无意中发现了这款“神器”，让我们来看看它长什么样：</p>\n<p><img src=\"/images/Windows-Tools-Recommend/Beyond-Compare.png\" alt=\"Beyond Compare\"></p>\n<p>　　Beyond Compare主要用途是对比两个文件夹或者文件的不同，并将差异 通过颜色的不同以标识。对的，你没有看错，就是文件夹的不同。它还可以按照你的需要进行比较，比如需要对比文件的不同或者对比文件的相同，都可以显示。</p>\n<h1 id=\"Everything\"><a href=\"#Everything\" class=\"headerlink\" title=\"Everything\"></a>Everything</h1><h2 id=\"推荐指数★★★★★-1\"><a href=\"#推荐指数★★★★★-1\" class=\"headerlink\" title=\"推荐指数★★★★★\"></a>推荐指数★★★★★</h2><p>　　由于笔者的每天工作都会收到很多不同文件，但是笔者又不善于对文件归类存放，都是杂乱的放在桌面，需要用到的时候找起来又相当的麻烦。这时候Everything这款文件快速搜索软件就成为我们这种“懒人”的福音了。他的界面如下：</p>\n<p><img src=\"/images/Windows-Tools-Recommend/everything.png\" alt=\"Everything\"></p>\n<p>　　它的体积也相当的轻巧，才30多MB，和现在动辄几百MB的软件相比确实小了很多；它的界面也很简洁易用，常用的就一个输入框和下面的文件列表，非常方便日常的使用；占用系统资源极低，Everything搜索只基于文件和文件夹的名称，所以建立起搜索数据库非常的快，搜索文件基本上都是秒搜。</p>\n<h1 id=\"Chrome\"><a href=\"#Chrome\" class=\"headerlink\" title=\"Chrome\"></a>Chrome</h1><h2 id=\"推荐指数★★★★★-2\"><a href=\"#推荐指数★★★★★-2\" class=\"headerlink\" title=\"推荐指数★★★★★\"></a>推荐指数★★★★★</h2><p>　　Chrome是笔者用过最好用的浏览器，没有之一。不管是日常生活中的使用还是开发中的测试等，Chrome都能够轻松胜任。</p>\n<p><img src=\"/images/Windows-Tools-Recommend/chrome.jpg\" alt=\"Chrome\"></p>\n<p>　　Chrome的特点是简洁、快速。它支持多个标签进行浏览，即使有一个标签崩溃，其他标签页不会崩溃。而且，Chrome是基于V8 JavaScript引擎的，页面性能更加优异。</p>\n<p>　　对于像笔者一样的网页开发者来说，Chrome更是开发网页的“利器”。使用F12调出控制台，在这里你能看到Elements(页面元素)、Console(网页运行的提示消息)、Sources(页面运行所加载的源码)、Resources(页面所需要的文件、存储的cookie和session等资源)、Network(可以看到网页加载脚本样式页面的时间还有异步的资源)</p>"},{"title":"js中闭包的用法整理","date":"2016-09-20T13:48:47.000Z","description":null,"toc":null,"author":"Corner","comments":1,"original":null,"photos":[],"_content":"　　闭包在js中比较常见，是js的一种特色，但同时也是js的一个难点。很多面试题都喜欢考核对js闭包的理解。这篇文章整理了js的一些常见的用法。\n<!-- more -->\n\n# 什么是js闭包\n　　对于js闭包，官方的解释是这样的：\n\n> 一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。\n\n　　第一次读估计很难理解，什么绑定变量的环境表达式、表达式的一部分，都是些什么鬼。用通俗一点的话来说就是：\n\n> 一个函数中有许多变量，这些变量变成了函数的一部分。闭包就是能够获取到函数内部变量的函数。\n\n　　因此，闭包也称为闭包数据，闭包的本质也就是函数。\n　　要理解闭包，首先要来理解两个概念：变量和作用域。在这里不多阐述，可以看笔者的另一篇文章[《深入理解js中的变量和作用域》](//xieyufei.com/2016/09/21/JS-Variate-Scope.html)。\n\n# 闭包的产生\n　　由于函数作用域的封闭性，函数外部并不能访问函数内部的变量。\n\n```javascript\nfunction func(){\n  var n=999;\n}\nconsole.log(n); // n is not defined\n```\n\n　　但是有时候我们需要用到函数内部的变量，这时候闭包就派上用处了。我们将上面的代码改造一下，就能够获取到func函数内部的变量。\n\n```javascript\nfunction func(){\n  var n=999;\n  add=function(){\n    n++;\n  }\n  function show(){\n    return n;\n  }\n  return show;\n}\nvar tempShow=func();\nconsole.log(tempShow()); //999\nadd();\nconsole.log(tempShow()); //1000\n```\n\n　　这里的tempShow函数其实就是一个闭包show函数。它是通过最外层的func函数运行后进行赋值的。tempShow函数运行后就获取到了func函数内部的变量n。\n　　那为什么func函数运行之后变量n没有被垃圾回收机制回收掉呢？在[《深入理解js中的变量和作用域》](//xieyufei.com/2016/09/21/JS-Variate-Scope.html)中我们说过了，全局变量是保存在静态存储区的，由于静态存储区中的变量是不会被回收掉的。而在这里我们将函数show赋值给全局变量tempShow，而函数show是函数func的子函数，因此，函数func也保存在静态存储区了。所以我们可以在任何地方调用tempShow方法。\n　　在这段代码中，很巧妙的定义了一个add函数，没有在add前使用var关键字，因此函数add是一个全局变量而不是局部变量，可以在函数的外部调用对变量n进行操作。函数add也是一个闭包函数。\n　　理解了上面的代码，相信下面的代码也不难理解了。\n\n```javascript\nvar name = \"The Window\";\nvar object = {\n　　name : \"My Object\",\n　　getNameFunc : function(){\n　　　　return function(){\n　　　　　　return this.name;\n　　　　};\n　　}\n};\nvar temp=object.getNameFunc();\nconsole.log(temp()); //The Window\n```\n\n　　在这里出现了一个新的变量this，读者们可以通过笔者的这篇文章[《Js中this的用法》](//xieyufei.com/2016/09/18/Explain-Js-This.html)大致的了解this。由于函数temp调用的环境不在object内部进行了调用，因此函数中的this指代了全局变量window。为了达到获取object内部name的效果，我们对上面的代码进行改造：\n\n```javascript\nvar name = \"The Window\";\nvar object = {\n　　name : \"My Object\",\n　　getNameFunc : function(){\n　　　　var that = this;\n　　　　return function(){\n　　　　　　return that.name;\n　　　　};\n　　}\n};\nvar temp=object.getNameFunc();\nconsole.log(temp()); //My Object\n```\n\n　　或者这样改造，使用bind方法，将temp函数的作用域绑定到object上。\n\n```javascript\nvar name = \"The Window\";\nvar object = {\n　　name : \"My Object\",\n　　getNameFunc : function(){\n　　　　var that = this;\n　　　　return function(){\n　　　　　　return that.name;\n　　　　};\n　　}\n};\nvar temp=object.getNameFunc().bind(object);\nconsole.log(temp()); //My Object\n```\n\n　　闭包不仅能够返回一个函数，还能够返回其他类型的数据，比如下面的代码返回了一个数组对象。\n\n```javascript\nfunction createFunctions(){\n  var result = new Array();\n  for (var i=0; i < 10; i++){\n    result[i] = function(){\n      return i;\n    };\n  }\n  return result;\n}\nvar funcs = createFunctions();\nfor (var i=0; i < funcs.length; i++){\n  console.log(funcs[i]()); //10个10\n}\n```\n\n\n\n\n\n","source":"_posts/Js-Closure.md","raw":"title: js中闭包的用法整理\ndate: 2016-09-20 21:48:47\ndescription:\ncategories:\n- 编程\ntags:\n- 前端\n- js\ntoc:\nauthor: Corner\ncomments:\noriginal:\npermalink:\nphotos:\n---\n　　闭包在js中比较常见，是js的一种特色，但同时也是js的一个难点。很多面试题都喜欢考核对js闭包的理解。这篇文章整理了js的一些常见的用法。\n<!-- more -->\n\n# 什么是js闭包\n　　对于js闭包，官方的解释是这样的：\n\n> 一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。\n\n　　第一次读估计很难理解，什么绑定变量的环境表达式、表达式的一部分，都是些什么鬼。用通俗一点的话来说就是：\n\n> 一个函数中有许多变量，这些变量变成了函数的一部分。闭包就是能够获取到函数内部变量的函数。\n\n　　因此，闭包也称为闭包数据，闭包的本质也就是函数。\n　　要理解闭包，首先要来理解两个概念：变量和作用域。在这里不多阐述，可以看笔者的另一篇文章[《深入理解js中的变量和作用域》](//xieyufei.com/2016/09/21/JS-Variate-Scope.html)。\n\n# 闭包的产生\n　　由于函数作用域的封闭性，函数外部并不能访问函数内部的变量。\n\n```javascript\nfunction func(){\n  var n=999;\n}\nconsole.log(n); // n is not defined\n```\n\n　　但是有时候我们需要用到函数内部的变量，这时候闭包就派上用处了。我们将上面的代码改造一下，就能够获取到func函数内部的变量。\n\n```javascript\nfunction func(){\n  var n=999;\n  add=function(){\n    n++;\n  }\n  function show(){\n    return n;\n  }\n  return show;\n}\nvar tempShow=func();\nconsole.log(tempShow()); //999\nadd();\nconsole.log(tempShow()); //1000\n```\n\n　　这里的tempShow函数其实就是一个闭包show函数。它是通过最外层的func函数运行后进行赋值的。tempShow函数运行后就获取到了func函数内部的变量n。\n　　那为什么func函数运行之后变量n没有被垃圾回收机制回收掉呢？在[《深入理解js中的变量和作用域》](//xieyufei.com/2016/09/21/JS-Variate-Scope.html)中我们说过了，全局变量是保存在静态存储区的，由于静态存储区中的变量是不会被回收掉的。而在这里我们将函数show赋值给全局变量tempShow，而函数show是函数func的子函数，因此，函数func也保存在静态存储区了。所以我们可以在任何地方调用tempShow方法。\n　　在这段代码中，很巧妙的定义了一个add函数，没有在add前使用var关键字，因此函数add是一个全局变量而不是局部变量，可以在函数的外部调用对变量n进行操作。函数add也是一个闭包函数。\n　　理解了上面的代码，相信下面的代码也不难理解了。\n\n```javascript\nvar name = \"The Window\";\nvar object = {\n　　name : \"My Object\",\n　　getNameFunc : function(){\n　　　　return function(){\n　　　　　　return this.name;\n　　　　};\n　　}\n};\nvar temp=object.getNameFunc();\nconsole.log(temp()); //The Window\n```\n\n　　在这里出现了一个新的变量this，读者们可以通过笔者的这篇文章[《Js中this的用法》](//xieyufei.com/2016/09/18/Explain-Js-This.html)大致的了解this。由于函数temp调用的环境不在object内部进行了调用，因此函数中的this指代了全局变量window。为了达到获取object内部name的效果，我们对上面的代码进行改造：\n\n```javascript\nvar name = \"The Window\";\nvar object = {\n　　name : \"My Object\",\n　　getNameFunc : function(){\n　　　　var that = this;\n　　　　return function(){\n　　　　　　return that.name;\n　　　　};\n　　}\n};\nvar temp=object.getNameFunc();\nconsole.log(temp()); //My Object\n```\n\n　　或者这样改造，使用bind方法，将temp函数的作用域绑定到object上。\n\n```javascript\nvar name = \"The Window\";\nvar object = {\n　　name : \"My Object\",\n　　getNameFunc : function(){\n　　　　var that = this;\n　　　　return function(){\n　　　　　　return that.name;\n　　　　};\n　　}\n};\nvar temp=object.getNameFunc().bind(object);\nconsole.log(temp()); //My Object\n```\n\n　　闭包不仅能够返回一个函数，还能够返回其他类型的数据，比如下面的代码返回了一个数组对象。\n\n```javascript\nfunction createFunctions(){\n  var result = new Array();\n  for (var i=0; i < 10; i++){\n    result[i] = function(){\n      return i;\n    };\n  }\n  return result;\n}\nvar funcs = createFunctions();\nfor (var i=0; i < funcs.length; i++){\n  console.log(funcs[i]()); //10个10\n}\n```\n\n\n\n\n\n","slug":"Js-Closure","published":1,"updated":"2016-10-09T01:08:09.223Z","layout":"post","link":"","_id":"ciu99fu4u000wr8fi34nvkgui","content":"<p>　　闭包在js中比较常见，是js的一种特色，但同时也是js的一个难点。很多面试题都喜欢考核对js闭包的理解。这篇文章整理了js的一些常见的用法。<br><a id=\"more\"></a></p>\n<h1 id=\"什么是js闭包\"><a href=\"#什么是js闭包\" class=\"headerlink\" title=\"什么是js闭包\"></a>什么是js闭包</h1><p>　　对于js闭包，官方的解释是这样的：</p>\n<blockquote>\n<p>一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。</p>\n</blockquote>\n<p>　　第一次读估计很难理解，什么绑定变量的环境表达式、表达式的一部分，都是些什么鬼。用通俗一点的话来说就是：</p>\n<blockquote>\n<p>一个函数中有许多变量，这些变量变成了函数的一部分。闭包就是能够获取到函数内部变量的函数。</p>\n</blockquote>\n<p>　　因此，闭包也称为闭包数据，闭包的本质也就是函数。<br>　　要理解闭包，首先要来理解两个概念：变量和作用域。在这里不多阐述，可以看笔者的另一篇文章<a href=\"//xieyufei.com/2016/09/21/JS-Variate-Scope.html\">《深入理解js中的变量和作用域》</a>。</p>\n<h1 id=\"闭包的产生\"><a href=\"#闭包的产生\" class=\"headerlink\" title=\"闭包的产生\"></a>闭包的产生</h1><p>　　由于函数作用域的封闭性，函数外部并不能访问函数内部的变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> n=<span class=\"number\">999</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(n); <span class=\"comment\">// n is not defined</span></div></pre></td></tr></table></figure>\n<p>　　但是有时候我们需要用到函数内部的变量，这时候闭包就派上用处了。我们将上面的代码改造一下，就能够获取到func函数内部的变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> n=<span class=\"number\">999</span>;</div><div class=\"line\">  add=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    n++;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> n;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> show;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> tempShow=func();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(tempShow()); <span class=\"comment\">//999</span></div><div class=\"line\">add();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(tempShow()); <span class=\"comment\">//1000</span></div></pre></td></tr></table></figure>\n<p>　　这里的tempShow函数其实就是一个闭包show函数。它是通过最外层的func函数运行后进行赋值的。tempShow函数运行后就获取到了func函数内部的变量n。<br>　　那为什么func函数运行之后变量n没有被垃圾回收机制回收掉呢？在<a href=\"//xieyufei.com/2016/09/21/JS-Variate-Scope.html\">《深入理解js中的变量和作用域》</a>中我们说过了，全局变量是保存在静态存储区的，由于静态存储区中的变量是不会被回收掉的。而在这里我们将函数show赋值给全局变量tempShow，而函数show是函数func的子函数，因此，函数func也保存在静态存储区了。所以我们可以在任何地方调用tempShow方法。<br>　　在这段代码中，很巧妙的定义了一个add函数，没有在add前使用var关键字，因此函数add是一个全局变量而不是局部变量，可以在函数的外部调用对变量n进行操作。函数add也是一个闭包函数。<br>　　理解了上面的代码，相信下面的代码也不难理解了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">\"The Window\"</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> object = &#123;</div><div class=\"line\">　　name : <span class=\"string\">\"My Object\"</span>,</div><div class=\"line\">　　getNameFunc : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">　　　　<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">　　　　　　<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</div><div class=\"line\">　　　　&#125;;</div><div class=\"line\">　　&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> temp=object.getNameFunc();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(temp()); <span class=\"comment\">//The Window</span></div></pre></td></tr></table></figure>\n<p>　　在这里出现了一个新的变量this，读者们可以通过笔者的这篇文章<a href=\"//xieyufei.com/2016/09/18/Explain-Js-This.html\">《Js中this的用法》</a>大致的了解this。由于函数temp调用的环境不在object内部进行了调用，因此函数中的this指代了全局变量window。为了达到获取object内部name的效果，我们对上面的代码进行改造：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">\"The Window\"</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> object = &#123;</div><div class=\"line\">　　name : <span class=\"string\">\"My Object\"</span>,</div><div class=\"line\">　　getNameFunc : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">　　　　<span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>;</div><div class=\"line\">　　　　<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">　　　　　　<span class=\"keyword\">return</span> that.name;</div><div class=\"line\">　　　　&#125;;</div><div class=\"line\">　　&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> temp=object.getNameFunc();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(temp()); <span class=\"comment\">//My Object</span></div></pre></td></tr></table></figure>\n<p>　　或者这样改造，使用bind方法，将temp函数的作用域绑定到object上。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">\"The Window\"</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> object = &#123;</div><div class=\"line\">　　name : <span class=\"string\">\"My Object\"</span>,</div><div class=\"line\">　　getNameFunc : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">　　　　<span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>;</div><div class=\"line\">　　　　<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">　　　　　　<span class=\"keyword\">return</span> that.name;</div><div class=\"line\">　　　　&#125;;</div><div class=\"line\">　　&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> temp=object.getNameFunc().bind(object);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(temp()); <span class=\"comment\">//My Object</span></div></pre></td></tr></table></figure>\n<p>　　闭包不仅能够返回一个函数，还能够返回其他类型的数据，比如下面的代码返回了一个数组对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createFunctions</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)&#123;</div><div class=\"line\">    result[i] = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> i;</div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> funcs = createFunctions();</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i &lt; funcs.length; i++)&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(funcs[i]()); <span class=\"comment\">//10个10</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"<p>　　闭包在js中比较常见，是js的一种特色，但同时也是js的一个难点。很多面试题都喜欢考核对js闭包的理解。这篇文章整理了js的一些常见的用法。<br>","more":"</p>\n<h1 id=\"什么是js闭包\"><a href=\"#什么是js闭包\" class=\"headerlink\" title=\"什么是js闭包\"></a>什么是js闭包</h1><p>　　对于js闭包，官方的解释是这样的：</p>\n<blockquote>\n<p>一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。</p>\n</blockquote>\n<p>　　第一次读估计很难理解，什么绑定变量的环境表达式、表达式的一部分，都是些什么鬼。用通俗一点的话来说就是：</p>\n<blockquote>\n<p>一个函数中有许多变量，这些变量变成了函数的一部分。闭包就是能够获取到函数内部变量的函数。</p>\n</blockquote>\n<p>　　因此，闭包也称为闭包数据，闭包的本质也就是函数。<br>　　要理解闭包，首先要来理解两个概念：变量和作用域。在这里不多阐述，可以看笔者的另一篇文章<a href=\"//xieyufei.com/2016/09/21/JS-Variate-Scope.html\">《深入理解js中的变量和作用域》</a>。</p>\n<h1 id=\"闭包的产生\"><a href=\"#闭包的产生\" class=\"headerlink\" title=\"闭包的产生\"></a>闭包的产生</h1><p>　　由于函数作用域的封闭性，函数外部并不能访问函数内部的变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> n=<span class=\"number\">999</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(n); <span class=\"comment\">// n is not defined</span></div></pre></td></tr></table></figure>\n<p>　　但是有时候我们需要用到函数内部的变量，这时候闭包就派上用处了。我们将上面的代码改造一下，就能够获取到func函数内部的变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> n=<span class=\"number\">999</span>;</div><div class=\"line\">  add=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    n++;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">show</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> n;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> show;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> tempShow=func();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(tempShow()); <span class=\"comment\">//999</span></div><div class=\"line\">add();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(tempShow()); <span class=\"comment\">//1000</span></div></pre></td></tr></table></figure>\n<p>　　这里的tempShow函数其实就是一个闭包show函数。它是通过最外层的func函数运行后进行赋值的。tempShow函数运行后就获取到了func函数内部的变量n。<br>　　那为什么func函数运行之后变量n没有被垃圾回收机制回收掉呢？在<a href=\"//xieyufei.com/2016/09/21/JS-Variate-Scope.html\">《深入理解js中的变量和作用域》</a>中我们说过了，全局变量是保存在静态存储区的，由于静态存储区中的变量是不会被回收掉的。而在这里我们将函数show赋值给全局变量tempShow，而函数show是函数func的子函数，因此，函数func也保存在静态存储区了。所以我们可以在任何地方调用tempShow方法。<br>　　在这段代码中，很巧妙的定义了一个add函数，没有在add前使用var关键字，因此函数add是一个全局变量而不是局部变量，可以在函数的外部调用对变量n进行操作。函数add也是一个闭包函数。<br>　　理解了上面的代码，相信下面的代码也不难理解了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">\"The Window\"</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> object = &#123;</div><div class=\"line\">　　name : <span class=\"string\">\"My Object\"</span>,</div><div class=\"line\">　　getNameFunc : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">　　　　<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">　　　　　　<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</div><div class=\"line\">　　　　&#125;;</div><div class=\"line\">　　&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> temp=object.getNameFunc();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(temp()); <span class=\"comment\">//The Window</span></div></pre></td></tr></table></figure>\n<p>　　在这里出现了一个新的变量this，读者们可以通过笔者的这篇文章<a href=\"//xieyufei.com/2016/09/18/Explain-Js-This.html\">《Js中this的用法》</a>大致的了解this。由于函数temp调用的环境不在object内部进行了调用，因此函数中的this指代了全局变量window。为了达到获取object内部name的效果，我们对上面的代码进行改造：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">\"The Window\"</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> object = &#123;</div><div class=\"line\">　　name : <span class=\"string\">\"My Object\"</span>,</div><div class=\"line\">　　getNameFunc : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">　　　　<span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>;</div><div class=\"line\">　　　　<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">　　　　　　<span class=\"keyword\">return</span> that.name;</div><div class=\"line\">　　　　&#125;;</div><div class=\"line\">　　&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> temp=object.getNameFunc();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(temp()); <span class=\"comment\">//My Object</span></div></pre></td></tr></table></figure>\n<p>　　或者这样改造，使用bind方法，将temp函数的作用域绑定到object上。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">\"The Window\"</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> object = &#123;</div><div class=\"line\">　　name : <span class=\"string\">\"My Object\"</span>,</div><div class=\"line\">　　getNameFunc : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">　　　　<span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>;</div><div class=\"line\">　　　　<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">　　　　　　<span class=\"keyword\">return</span> that.name;</div><div class=\"line\">　　　　&#125;;</div><div class=\"line\">　　&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> temp=object.getNameFunc().bind(object);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(temp()); <span class=\"comment\">//My Object</span></div></pre></td></tr></table></figure>\n<p>　　闭包不仅能够返回一个函数，还能够返回其他类型的数据，比如下面的代码返回了一个数组对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createFunctions</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)&#123;</div><div class=\"line\">    result[i] = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> i;</div><div class=\"line\">    &#125;;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> funcs = createFunctions();</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i &lt; funcs.length; i++)&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(funcs[i]()); <span class=\"comment\">//10个10</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[{"post_id":"ciu99fu430008r8ficm64h0yq","category_id":"ciu99fu3u0004r8fieittj659","_id":"ciu99fu4a000er8fibmrfqm9q"},{"post_id":"ciu99fu3m0000r8filpw4svbb","category_id":"ciu99fu3u0004r8fieittj659","_id":"ciu99fu4f000ir8fidxufrh3s"},{"post_id":"ciu99fu45000ar8fi1pk38h64","category_id":"ciu99fu3u0004r8fieittj659","_id":"ciu99fu4i000lr8fiz0id7awi"},{"post_id":"ciu99fu48000dr8fiux8rks2u","category_id":"ciu99fu3u0004r8fieittj659","_id":"ciu99fu4l000qr8fih218l4ja"},{"post_id":"ciu99fu3r0002r8fia6jfgkst","category_id":"ciu99fu3u0004r8fieittj659","_id":"ciu99fu4q000sr8fir92v03u4"},{"post_id":"ciu99fu4g000jr8fib1inbdjy","category_id":"ciu99fu3u0004r8fieittj659","_id":"ciu99fu4u000vr8fi3r40uh1m"},{"post_id":"ciu99fu400006r8fi02bhbkmp","category_id":"ciu99fu3u0004r8fieittj659","_id":"ciu99fu4y000zr8fitzwnnez9"},{"post_id":"ciu99fu4j000mr8finqe25z71","category_id":"ciu99fu3u0004r8fieittj659","_id":"ciu99fu4z0012r8fimbkvgkqn"},{"post_id":"ciu99fu4m000rr8fijg3tteph","category_id":"ciu99fu3u0004r8fieittj659","_id":"ciu99fu4z0013r8fism67qql1"},{"post_id":"ciu99fu4b000fr8fidsqmuag5","category_id":"ciu99fu4k000nr8fipusf7cdq","_id":"ciu99fu500015r8fi4b9s0k23"},{"post_id":"ciu99fu4u000wr8fi34nvkgui","category_id":"ciu99fu3u0004r8fieittj659","_id":"ciu99fu510016r8fi00qawpc5"},{"post_id":"ciu99fu4q000tr8fikwob6tr0","category_id":"ciu99fu4x000yr8fiqy9tfelw","_id":"ciu99fu510017r8fi11vg3hq6"}],"PostTag":[{"post_id":"ciu99fu3m0000r8filpw4svbb","tag_id":"ciu99fu3y0005r8fidsimhe2n","_id":"ciu99fu4i000kr8fiqhxv4poy"},{"post_id":"ciu99fu3m0000r8filpw4svbb","tag_id":"ciu99fu47000cr8fibe1jq1e4","_id":"ciu99fu4k000or8fi80y6rx2f"},{"post_id":"ciu99fu3r0002r8fia6jfgkst","tag_id":"ciu99fu3y0005r8fidsimhe2n","_id":"ciu99fu4v000xr8fiuex3i2s8"},{"post_id":"ciu99fu3r0002r8fia6jfgkst","tag_id":"ciu99fu47000cr8fibe1jq1e4","_id":"ciu99fu4y0010r8filifzztxk"},{"post_id":"ciu99fu400006r8fi02bhbkmp","tag_id":"ciu99fu3y0005r8fidsimhe2n","_id":"ciu99fu510019r8fidab8i4w4"},{"post_id":"ciu99fu400006r8fi02bhbkmp","tag_id":"ciu99fu4y0011r8fipc3vg419","_id":"ciu99fu52001ar8fi1zieyhhf"},{"post_id":"ciu99fu400006r8fi02bhbkmp","tag_id":"ciu99fu4z0014r8fihkwtagy8","_id":"ciu99fu52001cr8fig9uqka2z"},{"post_id":"ciu99fu430008r8ficm64h0yq","tag_id":"ciu99fu510018r8fix4n7zu72","_id":"ciu99fu53001dr8fiusw209zd"},{"post_id":"ciu99fu45000ar8fi1pk38h64","tag_id":"ciu99fu52001br8fiiqi6x2xo","_id":"ciu99fu54001fr8fip7p8ttp1"},{"post_id":"ciu99fu45000ar8fi1pk38h64","tag_id":"ciu99fu3y0005r8fidsimhe2n","_id":"ciu99fu54001gr8fic7bbxg5s"},{"post_id":"ciu99fu48000dr8fiux8rks2u","tag_id":"ciu99fu510018r8fix4n7zu72","_id":"ciu99fu54001ir8fimhksq1x9"},{"post_id":"ciu99fu4b000fr8fidsqmuag5","tag_id":"ciu99fu54001hr8fi6gr63foi","_id":"ciu99fu57001lr8fi98xmoo1e"},{"post_id":"ciu99fu4b000fr8fidsqmuag5","tag_id":"ciu99fu55001jr8fide0wvivc","_id":"ciu99fu57001mr8fiff1nv9dn"},{"post_id":"ciu99fu4g000jr8fib1inbdjy","tag_id":"ciu99fu510018r8fix4n7zu72","_id":"ciu99fu57001or8fiqb5nr9wh"},{"post_id":"ciu99fu4j000mr8finqe25z71","tag_id":"ciu99fu3y0005r8fidsimhe2n","_id":"ciu99fu58001qr8fiygfj2zf8"},{"post_id":"ciu99fu4j000mr8finqe25z71","tag_id":"ciu99fu57001nr8fif0rha9dj","_id":"ciu99fu58001rr8fioyghd70j"},{"post_id":"ciu99fu4m000rr8fijg3tteph","tag_id":"ciu99fu58001pr8fi9bpwkrwu","_id":"ciu99fu59001ur8fiiol95ll1"},{"post_id":"ciu99fu4m000rr8fijg3tteph","tag_id":"ciu99fu58001sr8fih586qtvm","_id":"ciu99fu59001vr8fiee6gwmsd"},{"post_id":"ciu99fu4q000tr8fikwob6tr0","tag_id":"ciu99fu54001hr8fi6gr63foi","_id":"ciu99fu5b001xr8fihose73di"},{"post_id":"ciu99fu4u000wr8fi34nvkgui","tag_id":"ciu99fu3y0005r8fidsimhe2n","_id":"ciu99fu5c001yr8fiph4y3v6m"},{"post_id":"ciu99fu4u000wr8fi34nvkgui","tag_id":"ciu99fu57001nr8fif0rha9dj","_id":"ciu99fu5c001zr8figla8cus7"}],"Tag":[{"name":"前端","_id":"ciu99fu3y0005r8fidsimhe2n"},{"name":"WeChat","_id":"ciu99fu47000cr8fibe1jq1e4"},{"name":"游戏引擎","_id":"ciu99fu4y0011r8fipc3vg419"},{"name":"CraftyJs","_id":"ciu99fu4z0014r8fihkwtagy8"},{"name":"git","_id":"ciu99fu510018r8fix4n7zu72"},{"name":"JS","_id":"ciu99fu52001br8fiiqi6x2xo"},{"name":"推荐","_id":"ciu99fu54001hr8fi6gr63foi"},{"name":"电影","_id":"ciu99fu55001jr8fide0wvivc"},{"name":"js","_id":"ciu99fu57001nr8fif0rha9dj"},{"name":"Java","_id":"ciu99fu58001pr8fi9bpwkrwu"},{"name":"异步跨域","_id":"ciu99fu58001sr8fih586qtvm"}]}}